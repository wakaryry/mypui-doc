{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"src/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/vue/source/browserconfig.xml","path":"browserconfig.xml","modified":0,"renderable":1},{"_id":"themes/vue/source/manifest.json","path":"manifest.json","modified":0,"renderable":1},{"_id":"src/images/data.png","path":"images/data.png","modified":0,"renderable":0},{"_id":"src/images/devtools-storage-chrome.png","path":"images/devtools-storage-chrome.png","modified":0,"renderable":0},{"_id":"src/images/devtools-storage-edge.png","path":"images/devtools-storage-edge.png","modified":0,"renderable":0},{"_id":"src/images/dom-tree.png","path":"images/dom-tree.png","modified":0,"renderable":0},{"_id":"src/images/hn-architecture.png","path":"images/hn-architecture.png","modified":0,"renderable":0},{"_id":"src/images/hn.png","path":"images/hn.png","modified":0,"renderable":0},{"_id":"src/images/lifecycle.png","path":"images/lifecycle.png","modified":0,"renderable":0},{"_id":"src/images/logged-proxied-data.png","path":"images/logged-proxied-data.png","modified":0,"renderable":0},{"_id":"src/images/components.png","path":"images/components.png","modified":0,"renderable":0},{"_id":"src/images/mvvm.png","path":"images/mvvm.png","modified":0,"renderable":0},{"_id":"src/images/props-events.png","path":"images/props-events.png","modified":0,"renderable":0},{"_id":"src/images/search-by-algolia.png","path":"images/search-by-algolia.png","modified":0,"renderable":0},{"_id":"src/images/state.png","path":"images/state.png","modified":0,"renderable":0},{"_id":"src/images/transition.png","path":"images/transition.png","modified":0,"renderable":0},{"_id":"src/images/typescript-type-error.png","path":"images/typescript-type-error.png","modified":0,"renderable":0},{"_id":"src/images/vue-component.png","path":"images/vue-component.png","modified":0,"renderable":0},{"_id":"src/images/vue-component-with-preprocessors.png","path":"images/vue-component-with-preprocessors.png","modified":0,"renderable":0},{"_id":"src/images/devtools-storage.png","path":"images/devtools-storage.png","modified":0,"renderable":0},{"_id":"themes/vue/source/css/page.styl","path":"css/page.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/css/search.styl","path":"css/search.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/css/benchmark.styl","path":"css/benchmark.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/js/css.escape.js","path":"js/css.escape.js","modified":0,"renderable":1},{"_id":"themes/vue/source/js/smooth-scroll.min.js","path":"js/smooth-scroll.min.js","modified":0,"renderable":1},{"_id":"themes/vue/source/js/common.js","path":"js/common.js","modified":0,"renderable":1},{"_id":"themes/vue/source/js/theme-data.js","path":"js/theme-data.js","modified":0,"renderable":1},{"_id":"themes/vue/source/images/aaha.png","path":"images/aaha.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/alligator_io.svg","path":"images/alligator_io.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/autocode.svg","path":"images/autocode.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/bit.png","path":"images/bit.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/blokt_cryptocurrency_news.png","path":"images/blokt_cryptocurrency_news.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/chaitin.png","path":"images/chaitin.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/check.png","path":"images/check.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/cloudstudio.png","path":"images/cloudstudio.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/coding.png","path":"images/coding.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/coin-bch.png","path":"images/coin-bch.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/coin-btc.png","path":"images/coin-btc.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/coin-eth.png","path":"images/coin-eth.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/coin-ltc.png","path":"images/coin-ltc.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/daily.png","path":"images/daily.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/dcloud.gif","path":"images/dcloud.gif","modified":0,"renderable":1},{"_id":"themes/vue/source/images/derek_pollard.png","path":"images/derek_pollard.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/devexpress.png","path":"images/devexpress.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/devsquad.png","path":"images/devsquad.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/dopamine.png","path":"images/dopamine.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/down.png","path":"images/down.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/earthlink.png","path":"images/earthlink.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/energy_comparison.png","path":"images/energy_comparison.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/fastcoding_inc.png","path":"images/fastcoding_inc.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/fastcoding_inc.svg","path":"images/fastcoding_inc.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/feed.png","path":"images/feed.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/firestick_tricks.png","path":"images/firestick_tricks.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/frontend_love.png","path":"images/frontend_love.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/frontendlove.png","path":"images/frontendlove.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/geekbang-ad.jpg","path":"images/geekbang-ad.jpg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/geekbang-vue-ad.gif","path":"images/geekbang-vue-ad.gif","modified":0,"renderable":1},{"_id":"themes/vue/source/images/gitee.png","path":"images/gitee.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/gridsome.png","path":"images/gridsome.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/happy_programmer_llc.png","path":"images/happy_programmer_llc.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/html_burger.png","path":"images/html_burger.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons.png","path":"images/icons.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons_8.png","path":"images/icons_8.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/imooc-ad.png","path":"images/imooc-ad.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/imooc-ad2.png","path":"images/imooc-ad2.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/imooc-ad3.png","path":"images/imooc-ad3.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/imooc-sponsor2.png","path":"images/imooc-sponsor2.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/imooc-sponsor.png","path":"images/imooc-sponsor.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/inkoop.png","path":"images/inkoop.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/intygrate.png","path":"images/intygrate.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/isle_of_code.png","path":"images/isle_of_code.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/isolutions_uk_limited.png","path":"images/isolutions_uk_limited.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/jqwidgets_.png","path":"images/jqwidgets_.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/jqwidgets_ltd.png","path":"images/jqwidgets_ltd.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/laravel.png","path":"images/laravel.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/marcus_hiles.png","path":"images/marcus_hiles.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/menu.png","path":"images/menu.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/modus.png","path":"images/modus.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/nativescript.png","path":"images/nativescript.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/neds.png","path":"images/neds.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/netflix_vpn.png","path":"images/netflix_vpn.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/onsen_ui.png","path":"images/onsen_ui.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/bestvpn_co.png","path":"images/bestvpn_co.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/Monterail.png","path":"images/Monterail.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/patreon.png","path":"images/patreon.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/passionate_people.png","path":"images/passionate_people.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/opteo.png","path":"images/opteo.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/paypal.png","path":"images/paypal.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/philip_john_basile.gif","path":"images/philip_john_basile.gif","modified":0,"renderable":1},{"_id":"themes/vue/source/images/piratebay_proxy.png","path":"images/piratebay_proxy.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/piratebayproxy.png","path":"images/piratebayproxy.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/programmers_io.png","path":"images/programmers_io.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/pullrequest.svg","path":"images/pullrequest.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/roadster.png","path":"images/roadster.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/search.png","path":"images/search.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/shopware_ag.png","path":"images/shopware_ag.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/shopware_ag.svg","path":"images/shopware_ag.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/retool.png","path":"images/retool.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/primevue.png","path":"images/primevue.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/staff_augmentation.png","path":"images/staff_augmentation.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/storekit.png","path":"images/storekit.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/syncfusion.png","path":"images/syncfusion.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/tee__.png","path":"images/tee__.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/tidelift.png","path":"images/tidelift.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/tighten_co.png","path":"images/tighten_co.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/tooltwist.png","path":"images/tooltwist.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/unicorn_io.png","path":"images/unicorn_io.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/stdlib.png","path":"images/stdlib.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/tencent-ad.png","path":"images/tencent-ad.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vehikl.png","path":"images/vehikl.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vpnranks.png","path":"images/vpnranks.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/valuecoders.png","path":"images/valuecoders.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vant.png","path":"images/vant.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vuemastery.png","path":"images/vuemastery.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vuetify.png","path":"images/vuetify.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vuejobs.png","path":"images/vuejobs.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/webdock.png","path":"images/webdock.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/wilderminds.png","path":"images/wilderminds.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vueschool.png","path":"images/vueschool.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/watchcartoononline.png","path":"images/watchcartoononline.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/y8.png","path":"images/y8.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/x_team.png","path":"images/x_team.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/xinguan.png","path":"images/xinguan.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/youku.png","path":"images/youku.png","modified":0,"renderable":1},{"_id":"themes/vue/source/js/vue.min.js","path":"js/vue.min.js","modified":0,"renderable":1},{"_id":"themes/vue/source/images/accelebrate.png","path":"images/accelebrate.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/pay_ali_68.png","path":"images/pay_ali_68.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/pay_wx.png","path":"images/pay_wx.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/pay_wx_68.png","path":"images/pay_wx_68.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/usave.png","path":"images/usave.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/webucator.png","path":"images/webucator.png","modified":0,"renderable":1},{"_id":"src/images/doc/button.png","path":"images/doc/button.png","modified":0,"renderable":0},{"_id":"themes/vue/source/images/yakaz.png","path":"images/yakaz.png","modified":0,"renderable":1},{"_id":"src/images/memory-leak-example.png","path":"images/memory-leak-example.png","modified":0,"renderable":0},{"_id":"src/images/oxford-comma.jpg","path":"images/oxford-comma.jpg","modified":0,"renderable":0},{"_id":"themes/vue/source/fonts/Dosis/OFL.txt","path":"fonts/Dosis/OFL.txt","modified":0,"renderable":1},{"_id":"themes/vue/source/fonts/Roboto_Mono/LICENSE.txt","path":"fonts/Roboto_Mono/LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/vue/source/fonts/Source_Sans_Pro/OFL.txt","path":"fonts/Source_Sans_Pro/OFL.txt","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-144x144.png","path":"images/icons/android-icon-144x144.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-192x192.png","path":"images/icons/android-icon-192x192.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-36x36.png","path":"images/icons/android-icon-36x36.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-48x48.png","path":"images/icons/android-icon-48x48.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-72x72.png","path":"images/icons/android-icon-72x72.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-96x96.png","path":"images/icons/android-icon-96x96.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-114x114.png","path":"images/icons/apple-icon-114x114.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-120x120.png","path":"images/icons/apple-icon-120x120.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-144x144.png","path":"images/icons/apple-icon-144x144.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-152x152.png","path":"images/icons/apple-icon-152x152.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-180x180.png","path":"images/icons/apple-icon-180x180.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-57x57.png","path":"images/icons/apple-icon-57x57.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-60x60.png","path":"images/icons/apple-icon-60x60.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-72x72.png","path":"images/icons/apple-icon-72x72.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-76x76.png","path":"images/icons/apple-icon-76x76.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-precomposed.png","path":"images/icons/apple-icon-precomposed.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon.png","path":"images/icons/apple-icon.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/bacancy_technology.png","path":"images/bacancy_technology.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon-16x16.png","path":"images/icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon-32x32.png","path":"images/icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon.ico","path":"images/icons/favicon.ico","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon-96x96.png","path":"images/icons/favicon-96x96.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-150x150.png","path":"images/icons/ms-icon-150x150.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-144x144.png","path":"images/icons/ms-icon-144x144.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-70x70.png","path":"images/icons/ms-icon-70x70.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-310x310.png","path":"images/icons/ms-icon-310x310.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/storyblok.png","path":"images/storyblok.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/writers_per_hour.jpg","path":"images/writers_per_hour.jpg","modified":0,"renderable":1},{"_id":"themes/vue/source/fonts/Roboto_Mono/RobotoMono-Regular.ttf","path":"fonts/Roboto_Mono/RobotoMono-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/vue/source/fonts/Dosis/Dosis-Medium.ttf","path":"fonts/Dosis/Dosis-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/vue/source/fonts/Source_Sans_Pro/SourceSansPro-Regular.ttf","path":"fonts/Source_Sans_Pro/SourceSansPro-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/vue/source/fonts/Source_Sans_Pro/SourceSansPro-Semibold.ttf","path":"fonts/Source_Sans_Pro/SourceSansPro-Semibold.ttf","modified":0,"renderable":1},{"_id":"themes/vue/source/js/vue.js","path":"js/vue.js","modified":0,"renderable":1},{"_id":"themes/vue/source/images/special-sponsor-spot.png","path":"images/special-sponsor-spot.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/bacancy_technology.png","path":"images/icons/bacancy_technology.png","modified":0,"renderable":1},{"_id":"themes/vue/source/fonts/Source_Sans_Pro/SourceSansPro-Light.ttf","path":"fonts/Source_Sans_Pro/SourceSansPro-Light.ttf","modified":0,"renderable":1},{"_id":"src/images/devtools-timetravel.gif","path":"images/devtools-timetravel.gif","modified":0,"renderable":0},{"_id":"themes/vue/source/images/pay_ali.jpeg","path":"images/pay_ali.jpeg","modified":0,"renderable":1},{"_id":"src/images/breakpoint_set.png","path":"images/breakpoint_set.png","modified":0,"renderable":0},{"_id":"src/images/config_add.png","path":"images/config_add.png","modified":0,"renderable":0},{"_id":"src/images/breakpoint_hit.png","path":"images/breakpoint_hit.png","modified":0,"renderable":0}],"Cache":[{"_id":"src/index.md","hash":"fd945de1e31344f0d8be59bcc87e3f5fda468e11","modified":1594687607803},{"_id":"src/CNAME","hash":"a8b86229a3e3f0382629c91bd7a6755f7ca4976c","modified":1594963836433},{"_id":"themes/vue/_config.yml","hash":"a697d9581cae298d29441b6dc67691cadb157fa7","modified":1594902145848},{"_id":"themes/vue/layout/page.ejs","hash":"71818654ce63c8ccfd5f66e18b15adf8c1a62655","modified":1594952577045},{"_id":"themes/vue/layout/index.ejs","hash":"b6eb425cef1bf660db4903340c79bfd2596c4d28","modified":1594906941568},{"_id":"themes/vue/layout/layout.ejs","hash":"e23afbce483e0d7a796b238a3e72abcb2e833f98","modified":1594956447760},{"_id":"themes/vue/layout/partners-page.ejs","hash":"456b21d664191b007cb329c100c00e2e060a7334","modified":1594687607849},{"_id":"themes/vue/layout/post.ejs","hash":"c14db1616a9c9e3023e2b4dfb97a031a196e9475","modified":1594687607849},{"_id":"themes/vue/source/browserconfig.xml","hash":"7836fcf8b3a9a39ea41b1193d08521ca2cd20539","modified":1594687607850},{"_id":"themes/vue/layout/search-page.ejs","hash":"1bd32a68fff114c6e04160d3e4b2c1476060ae8d","modified":1594687607850},{"_id":"themes/vue/layout/sponsors-page.ejs","hash":"c4a8f1f0ef755b146c8eb2ab0ca05488fc6c5efc","modified":1594952139123},{"_id":"themes/vue/source/manifest.json","hash":"663e9e63f03ec67a6a08c842ce06b6d748aaf0c5","modified":1594901914474},{"_id":"src/_posts/hello.md","hash":"3f022d4d32f1f6bc79488cbaa420990bda38853a","modified":1594687607770},{"_id":"src/about/index.md","hash":"bb8049cee48b60a7f8d93b037d164c84ad0c221b","modified":1594687607770},{"_id":"src/coc/index.md","hash":"dd6cb88296917f08b0ee3694c5af244139317b62","modified":1594687607771},{"_id":"src/images/data.png","hash":"7071337f9071f93ebf85639ede38b0f40fd75d98","modified":1594687607787},{"_id":"src/images/devtools-storage-chrome.png","hash":"4c6defcd7f965e743c5a9d9242766e67b7a79a38","modified":1594687607788},{"_id":"src/images/devtools-storage-edge.png","hash":"4550f8c408787ed427c5f6b07530533690be1a3c","modified":1594687607789},{"_id":"src/images/dom-tree.png","hash":"820025017bfcf319d411f6eb2a6f07d543132028","modified":1594687607795},{"_id":"src/images/hn-architecture.png","hash":"0b4adafb587478119e1fb5808f8f04481268a3ce","modified":1594687607796},{"_id":"src/images/hn.png","hash":"d0a6b7b011d305d62504cae3bbce54d111783e82","modified":1594687607796},{"_id":"src/images/lifecycle.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1594687607797},{"_id":"src/images/logged-proxied-data.png","hash":"0e875c2ded04180d9fc73785fbc91351b8159648","modified":1594687607797},{"_id":"src/images/components.png","hash":"2f4056d9c0448a3204386ddefd84025ea8a58967","modified":1594687607782},{"_id":"src/images/mvvm.png","hash":"b83d7f54d5f2df09a662a7057cd521d23b67e451","modified":1594687607799},{"_id":"src/images/props-events.png","hash":"0f0328ec572bda3f864bb65eea5dbbf32b59504c","modified":1594687607801},{"_id":"src/images/search-by-algolia.png","hash":"b580b0eb3965b62ce9bb1bab1ed0577448f73075","modified":1594687607801},{"_id":"src/images/state.png","hash":"8d8033027c49fee1f795cdca0736c4315efc54fa","modified":1594687607801},{"_id":"src/images/transition.png","hash":"918faae8f4e8e8d0b02c7516ba3c9931b9161487","modified":1594687607802},{"_id":"src/images/typescript-type-error.png","hash":"f282f85d3fe94a7ebd2f741efad3d55a5469dcc5","modified":1594687607802},{"_id":"src/images/vue-component.png","hash":"a9155a78d17b79c5f8e28f4ccf48864fcf172efb","modified":1594687607803},{"_id":"src/menu/index.md","hash":"189f0685b3420069e60d21599ace0e653ed99ecb","modified":1594687607804},{"_id":"src/images/vue-component-with-preprocessors.png","hash":"daed0210c92685fd128bd5e8b9338700619b2442","modified":1594687607803},{"_id":"src/perf/index.md","hash":"4e99a00b4c42175ad476c1ed112e02c144ff630f","modified":1594687607804},{"_id":"src/resources/themes.md","hash":"6218de9c9a80620f044a2f4583f52b55c5bd2438","modified":1594687607804},{"_id":"src/resources/partners.md","hash":"22b131c77a3db61d066bb0066c56e7729eb780c2","modified":1594687607804},{"_id":"src/support-mypui/index.md","hash":"6348a4b94c23a55e433d78c2283e9e5f6b16ea3e","modified":1594687607804},{"_id":"src/images/devtools-storage.png","hash":"edc4425d005028a30d2f2ae66183ecb65f0d988f","modified":1594687607790},{"_id":"themes/vue/layout/icons/btc.ejs","hash":"fed9b5d4b5e19813dc6dea1e58143d402b8692e0","modified":1594687607844},{"_id":"themes/vue/layout/icons/eth.ejs","hash":"36e176c7e64e56c0e2b5da03d6a297344862b550","modified":1594687607844},{"_id":"themes/vue/layout/icons/bch.ejs","hash":"d5d3f724738964e5ea4dcb5ca733c5a3ce6268ad","modified":1594687607843},{"_id":"themes/vue/layout/icons/github-dark.ejs","hash":"a06780311d7f5ec2f962bd23ff8964befbbcdd93","modified":1594687607844},{"_id":"themes/vue/layout/icons/github.ejs","hash":"188ffb2152598973849360eafeb18d4f907cf32a","modified":1594687607844},{"_id":"themes/vue/layout/icons/ltc.ejs","hash":"6d74d8a03ae0729d84e58c5a776916d7fb217543","modified":1594687607844},{"_id":"themes/vue/layout/icons/play.ejs","hash":"af4cb73bbfdadd794e0fba125fdcd66fc3263f22","modified":1594687607845},{"_id":"themes/vue/layout/icons/twitter.ejs","hash":"4fc8410bd2bc266c81d87399c8b66c5cbae5ce69","modified":1594687607845},{"_id":"themes/vue/layout/icons/medium.ejs","hash":"11850bc444cc7b966bc804930fb7aa9bb4790f8d","modified":1594687607845},{"_id":"themes/vue/layout/partials/ad-text.ejs","hash":"37f6ad840c7f6e2450fc8c53880db7878f53baff","modified":1594687607846},{"_id":"themes/vue/layout/partials/ad-pagetop.ejs","hash":"1e88e650d35822f6126f57c57d8a82f44ab5aee8","modified":1594687607846},{"_id":"themes/vue/layout/partials/ad.ejs","hash":"d29f33ea71b3d21df0f9f55fdd22084a673206d4","modified":1594687607846},{"_id":"themes/vue/layout/partials/contributors.ejs","hash":"19cbb08d56735c7215c47ec46fdcc656cb10dab0","modified":1594687607846},{"_id":"themes/vue/layout/partials/header.ejs","hash":"7687154d1ad6045dbadf2df511e06f51ec43300f","modified":1594904118648},{"_id":"themes/vue/layout/partials/language_dropdown.ejs","hash":"4ee191490cee1bc9abcd2dee35b829fdb8fcff15","modified":1594687607847},{"_id":"themes/vue/layout/partials/learn_dropdown.ejs","hash":"b02de946af6521e6d8b10c13ce6701e292040dae","modified":1594964557539},{"_id":"themes/vue/layout/partials/ecosystem_dropdown.ejs","hash":"062de014134b6668953fbed5d827833e0a1f7160","modified":1594964910544},{"_id":"themes/vue/layout/partials/platinum_sponsors.ejs","hash":"2bcc12d732ad5f65109e02f56ffdf3e59b44e3b9","modified":1594687607848},{"_id":"themes/vue/layout/partials/resources_dropdown.ejs","hash":"e7897ffe069983a316f4f0fe61f844dd62208787","modified":1594687607848},{"_id":"themes/vue/layout/partials/sponsors.ejs","hash":"2b66b8e1414497ac59618e89e435575c7327f20a","modified":1594687607848},{"_id":"themes/vue/layout/partials/main_menu.ejs","hash":"0f7faae3d63c44055c0b8df5331fa75b66985a65","modified":1594907607146},{"_id":"themes/vue/layout/partials/sponsors_sidebar.ejs","hash":"17827efa8c7348739c473eacc5fda3a50084e124","modified":1594687607849},{"_id":"themes/vue/layout/partials/sidebar.ejs","hash":"4342814e858947f99aae31eb07168895d3ad758c","modified":1594964973002},{"_id":"themes/vue/source/css/_ad-pagetop.styl","hash":"db923b32fe1c78fab2dca8f2e1af691821f9ae4e","modified":1594687607850},{"_id":"themes/vue/source/css/_ad.styl","hash":"05aeb9ed010a1c5767d9f09a0533385602032033","modified":1594687607851},{"_id":"themes/vue/source/css/_animations.styl","hash":"709eff86f230249ea35a7d6374d21b81e870cb1c","modified":1594687607851},{"_id":"themes/vue/source/css/_api.styl","hash":"d1d041953b75246d6733324ea0073bc5491468b1","modified":1594687607851},{"_id":"themes/vue/source/css/_common.styl","hash":"f06192d1b1b8fab9b9711a4cde7313ab3edfda31","modified":1594687607851},{"_id":"themes/vue/source/css/_demo.styl","hash":"587c26bdedf0bcbaed841fe4222431439ed7d16e","modified":1594687607851},{"_id":"themes/vue/source/css/_fonts.styl","hash":"c2d6a6f72f961f37f42c559bc394637ab62f0400","modified":1594687607852},{"_id":"themes/vue/source/css/_header.styl","hash":"04cbe57a25170928b8dc372634c544197432be78","modified":1594687607852},{"_id":"themes/vue/source/css/_migration.styl","hash":"6c95c614220e0318913282fe793f84b0e99ab7a6","modified":1594687607852},{"_id":"themes/vue/source/css/_modal.styl","hash":"30889e0ba319a2b9564d3b48d25bb2dea1920566","modified":1594687607852},{"_id":"themes/vue/source/css/_offline-menu.styl","hash":"bdd13f1a8814197cd629fc433ca8874b5af929ec","modified":1594687607852},{"_id":"themes/vue/source/css/_partners.styl","hash":"4e98cd0683722b1139a100197552107c8c454f52","modified":1594687607853},{"_id":"themes/vue/source/css/_scrimba.styl","hash":"1c0424ed1fd81b6ff2dc7bce8689d7bda677e824","modified":1594687607853},{"_id":"themes/vue/source/css/_search-page.styl","hash":"b836d30b5fa0366ea1308b2e1d8e5fa987e0ccd2","modified":1594687607853},{"_id":"themes/vue/source/css/_settings.styl","hash":"22a4814f51fb1e50ba7bbcfd02972ee41e022193","modified":1594687607853},{"_id":"themes/vue/source/css/_sidebar.styl","hash":"e52d4e26544e1d7bcd0ded68513fa6c475fec816","modified":1594687607853},{"_id":"themes/vue/layout/partials/support_mypui_dropdown.ejs","hash":"92a67a80400436b51e8f3b4871e7c604925b74d6","modified":1594907690736},{"_id":"themes/vue/layout/partials/toc.ejs","hash":"865527ec96fcca4e76eb9030327f01a7cb2f9f67","modified":1595339560146},{"_id":"themes/vue/source/css/_sponsors-page.styl","hash":"2920beb84c8f9b93acd2ff161991240e6389db94","modified":1594687607854},{"_id":"themes/vue/source/css/_sponsors-sidebar.styl","hash":"cd66f0d0ee354221665533674e160c83019b2d16","modified":1594687607854},{"_id":"themes/vue/source/css/_style-guide.styl","hash":"bdf64ffc2e6c67d2e752953de93c63566cbb483b","modified":1594687607854},{"_id":"themes/vue/source/css/_syntax.styl","hash":"0e7423aab803b9e3f4006cfd28eb668c4fa3a6e4","modified":1594687607854},{"_id":"themes/vue/source/css/_team.styl","hash":"d6e2de47ad3d2bbcc1f11ae4b3f9566378f6a372","modified":1594687607855},{"_id":"themes/vue/source/css/_themes.styl","hash":"7899e87c3c04fd004d81e3c16e13aa38f900db1d","modified":1594687607855},{"_id":"themes/vue/source/css/_vue-mastery.styl","hash":"6c966e992658619c5f82895ee51cf1d499b023f8","modified":1594687607855},{"_id":"themes/vue/source/css/_sponsors-index.styl","hash":"7ab6d71fb235e8979c7a6661622ad750192ad167","modified":1594687607854},{"_id":"themes/vue/source/css/page.styl","hash":"4150b5efc68406a379900ed54e8af3f547871673","modified":1594687607856},{"_id":"themes/vue/source/css/search.styl","hash":"006d48944e9513d569ba68ed054755a5aa42c338","modified":1594687607856},{"_id":"themes/vue/source/css/benchmark.styl","hash":"f676e3d142530aef8a4f29a22360f4516047a1ff","modified":1594687607855},{"_id":"themes/vue/source/css/index.styl","hash":"a03a490be4c45031ceb6cefadd690ec17ca8a41e","modified":1594687607856},{"_id":"themes/vue/source/js/css.escape.js","hash":"1d0e28a08261de3955b0ee18432e304c1f468441","modified":1594687607953},{"_id":"themes/vue/source/js/smooth-scroll.min.js","hash":"90cdfb5d91db8cce21ab705335d591768555f474","modified":1594687607954},{"_id":"themes/vue/source/js/common.js","hash":"fb0e5a8ccc5a28de3162ae31fc5f955a89eab2a2","modified":1594687607953},{"_id":"themes/vue/source/js/theme-data.js","hash":"a2413c5177734143b997b9bb2070b54c00c9e138","modified":1594687607954},{"_id":"themes/vue/source/images/aaha.png","hash":"081c1d01fd9d611e6270d45d87c15b41fbc1aaed","modified":1594687607866},{"_id":"themes/vue/source/images/alligator_io.svg","hash":"95f65bec674298d1fe49b46768034dbf64b4adbf","modified":1594687607867},{"_id":"themes/vue/source/images/autocode.svg","hash":"79d1bed665a919f9bf5ea6da67906a05cd68dc69","modified":1594687607867},{"_id":"themes/vue/source/images/bit.png","hash":"c017f11268e43727a12aa40885ea1f18056233b1","modified":1594687607869},{"_id":"themes/vue/source/images/blokt_cryptocurrency_news.png","hash":"fa2ac30a25830e9ef383fdb8c4efc5cc98aaff8f","modified":1594687607869},{"_id":"themes/vue/source/images/chaitin.png","hash":"a61b1ec393b9600d173255fed72fd873a72b8225","modified":1594687607870},{"_id":"themes/vue/source/images/check.png","hash":"b22174f8a966abf7a46eba7991be7a7ae5e16637","modified":1594687607870},{"_id":"themes/vue/source/images/cloudstudio.png","hash":"a0cb4e3d6a3f8f06e0c0416c71427dd01f3af52b","modified":1594687607870},{"_id":"themes/vue/source/images/coding.png","hash":"42d13e784d11c72f8bb40042b2d99761ddbe8559","modified":1594687607870},{"_id":"themes/vue/source/images/coin-bch.png","hash":"783293c8b782e7772e61f62e1168ae175a0a1456","modified":1594687607870},{"_id":"themes/vue/source/images/coin-btc.png","hash":"4dc6d5b671dba33b3e293180ccc9ec2f0b480a6b","modified":1594687607871},{"_id":"themes/vue/source/images/coin-eth.png","hash":"aadb0a7d299f9a2baf2bf2d281f70d1e26e15a48","modified":1594687607871},{"_id":"themes/vue/source/images/coin-ltc.png","hash":"2bf87f92612990bc609dcc8826a344be05166717","modified":1594687607871},{"_id":"themes/vue/source/images/daily.png","hash":"0671abb13bb622f27b85e14eb5341813219c3548","modified":1594687607871},{"_id":"themes/vue/source/images/dcloud.gif","hash":"fbff46821a116457ec0f656296bba91d29403f7e","modified":1594687607872},{"_id":"themes/vue/source/images/derek_pollard.png","hash":"a09bcb5d8fe8a712b31591aa2169f751ea7591ba","modified":1594687607872},{"_id":"themes/vue/source/images/devexpress.png","hash":"8b39711fba0756c8407e27de46f2641ac651f30b","modified":1594687607872},{"_id":"themes/vue/source/images/devsquad.png","hash":"f96551ba232f1b005512892334e912b45cc37374","modified":1594687607873},{"_id":"themes/vue/source/images/dopamine.png","hash":"2ea0928227dd6cb44ceeca4ed877feb2be741ff1","modified":1594687607874},{"_id":"themes/vue/source/images/down.png","hash":"6ded74a98bb128e76bfd45cffede2679fd0598f0","modified":1594687607874},{"_id":"themes/vue/source/images/earthlink.png","hash":"b47c30f0093a0e8c48c5d0ae1feff24d6ef64de4","modified":1594687607874},{"_id":"themes/vue/source/images/energy_comparison.png","hash":"eb8657097242bd990585ddae38ad72e8388917ca","modified":1594687607875},{"_id":"themes/vue/source/images/fastcoding_inc.png","hash":"91d2a1c0d7b5eaf71051341a2c3b718bd8770ad1","modified":1594687607875},{"_id":"themes/vue/source/images/fastcoding_inc.svg","hash":"12cfd6800f3b3b37999001eb41f9ff515888bc8c","modified":1594687607875},{"_id":"themes/vue/source/images/feed.png","hash":"eba32c4f87e5ea1f89dce9c68d8603c8f82a8cd9","modified":1594687607875},{"_id":"themes/vue/source/images/firestick_tricks.png","hash":"b43bc723f029191685f77fb573b5c0aadbc2a12d","modified":1594687607875},{"_id":"themes/vue/source/images/frontend_love.png","hash":"ef3695d6a19646599211f886e3a27cd75a374ef6","modified":1594687607875},{"_id":"themes/vue/source/images/frontendlove.png","hash":"ef3695d6a19646599211f886e3a27cd75a374ef6","modified":1594687607876},{"_id":"themes/vue/source/images/geekbang-ad.jpg","hash":"6c6856ceaca0c502e8f815c91e44e7a971c4daf2","modified":1594687607876},{"_id":"themes/vue/source/images/geekbang-vue-ad.gif","hash":"c24983efc7dba466d8c4cc56a1c5749c19f73602","modified":1594687607876},{"_id":"themes/vue/source/images/gitee.png","hash":"29fbe638ec4e24faad12f345399eac7f426b2772","modified":1594687607877},{"_id":"themes/vue/source/images/gridsome.png","hash":"85adec48d683c206a5ccfaaf2de39c8b12ce09fb","modified":1594687607877},{"_id":"themes/vue/source/images/happy_programmer_llc.png","hash":"bd82c4e12cffa604e3e2d1688b333fba1eaa7113","modified":1594687607877},{"_id":"themes/vue/source/images/html_burger.png","hash":"a6c54ce4ae3ad4b5f1b02a3bb1ca7da838eee8f5","modified":1594687607878},{"_id":"themes/vue/source/images/icons.png","hash":"50aa19eac3a7bf6acb435838b7a890050a4a6d8d","modified":1594687607878},{"_id":"themes/vue/source/images/icons_8.png","hash":"4d44e5b251f72dffe37ac7007042fc0b7beb34fb","modified":1594687607885},{"_id":"themes/vue/source/images/imooc-ad.png","hash":"9033e757b13c9b0be56271d795f5ff97723afcb3","modified":1594687607886},{"_id":"themes/vue/source/images/imooc-ad2.png","hash":"8d8844d3d605c89be17cfd9b8603d1ac5e8437a5","modified":1594687607886},{"_id":"themes/vue/source/images/imooc-ad3.png","hash":"9e2e9d7a8f18f3cfcc42ae9c3570adcb8c5c8c56","modified":1594687607887},{"_id":"themes/vue/source/images/imooc-sponsor2.png","hash":"253b0acbd6ce31a94222b70cead2e304cf8275e3","modified":1594687607887},{"_id":"themes/vue/source/images/imooc-sponsor.png","hash":"f02558d853476a26f29ffe69261eb21b230b57ca","modified":1594687607887},{"_id":"themes/vue/source/images/inkoop.png","hash":"fb568c6e466a6c19e5ee40bf92cf2527c58a6db2","modified":1594687607887},{"_id":"themes/vue/source/images/intygrate.png","hash":"f55e418bdf6b1a9fc72fee3d86ec02cc51c6d83b","modified":1594687607888},{"_id":"themes/vue/source/images/isle_of_code.png","hash":"ff273db09eb5ca17d047c73256ee311a9a04d911","modified":1594687607888},{"_id":"themes/vue/source/images/isolutions_uk_limited.png","hash":"067c63b7e2da8667e49f1c63a398094814657742","modified":1594687607889},{"_id":"themes/vue/source/images/jqwidgets_.png","hash":"6ffa378d97190dc88d4d54fa0051c36c6088e03d","modified":1594687607889},{"_id":"themes/vue/source/images/jqwidgets_ltd.png","hash":"eb4da2aec072a3f2a6c3cd322e1a44528f737177","modified":1594687607889},{"_id":"themes/vue/source/images/laravel.png","hash":"010281d898830dbb8c848f6a272ba46ddc95e800","modified":1594687607890},{"_id":"themes/vue/source/images/logo.png","hash":"fe6aa6171025d850637e513eefa0a52c5848baae","modified":1594900028533},{"_id":"themes/vue/source/images/marcus_hiles.png","hash":"08a36fa5f6bd0156a8b7ccd86ff74baf56776536","modified":1594687607891},{"_id":"themes/vue/source/images/menu.png","hash":"45d62574f2a22017c2aa2001964eaf560f1f70c6","modified":1594687607891},{"_id":"themes/vue/source/images/modus.png","hash":"d4f2c2f7292b26ce11d88d2b08ff299f4e8eb2d4","modified":1594687607891},{"_id":"themes/vue/source/images/nativescript.png","hash":"ce3751738de68182c1e9ebab7d345227753cc5dc","modified":1594687607892},{"_id":"themes/vue/source/images/neds.png","hash":"675a3f7997063c12a48946219db52948732b71b2","modified":1594687607892},{"_id":"themes/vue/source/images/netflix_vpn.png","hash":"54c1e9c816588a0f9d0b5619d62f953707e77dba","modified":1594687607892},{"_id":"themes/vue/source/images/onsen_ui.png","hash":"0dc98d72d447a8f4d3b8c43cb0890362597de194","modified":1594687607895},{"_id":"themes/vue/source/images/bestvpn_co.png","hash":"499990e72cb49b3c53316d376c787ff1c5f17a7f","modified":1594687607869},{"_id":"themes/vue/source/images/Monterail.png","hash":"5f347b6677637054908e4599709134f4606285cd","modified":1594687607866},{"_id":"themes/vue/source/images/patreon.png","hash":"bb0d0dd23c4058d8be63cdf0ccba1e6a13b05acf","modified":1594687607898},{"_id":"themes/vue/source/images/passionate_people.png","hash":"c637a4f55fe9d8f469a20796fe159b18fe54b327","modified":1594687607897},{"_id":"themes/vue/source/images/opteo.png","hash":"1915a34af45592878eacc3764dc603a81491f4ae","modified":1594687607897},{"_id":"themes/vue/source/images/paypal.png","hash":"b1c3741633ff0c0f8f8a0e80d68202c14a524009","modified":1594687607898},{"_id":"themes/vue/source/images/philip_john_basile.gif","hash":"33e8f13ef9678b8ecaa146fb45acda0057b2e090","modified":1594687607898},{"_id":"themes/vue/source/images/piratebay_proxy.png","hash":"98588ad87fc245df67b26bd5ada2b3b506a61f86","modified":1594687607898},{"_id":"themes/vue/source/images/piratebayproxy.png","hash":"98588ad87fc245df67b26bd5ada2b3b506a61f86","modified":1594687607899},{"_id":"themes/vue/source/images/programmers_io.png","hash":"97990feb9b226ad06f55e7dd8e7432d3cf39cc63","modified":1594687607900},{"_id":"themes/vue/source/images/pullrequest.svg","hash":"335566b90d53b7f844c9c41812952042fdf55225","modified":1594687607900},{"_id":"themes/vue/source/images/roadster.png","hash":"5581867231c0f4059c0ea63f20717886a6e7ac9d","modified":1594687607901},{"_id":"themes/vue/source/images/search.png","hash":"7f519d31bc3c6ca005b6ca5d8ff5ded172df627a","modified":1594687607902},{"_id":"themes/vue/source/images/shopware_ag.png","hash":"c440385ade9c0f9c66104bd1b1b7d41d32c0251a","modified":1594687607902},{"_id":"themes/vue/source/images/shopware_ag.svg","hash":"658c483629cfce8eed7221d1f8463b532abaab02","modified":1594687607902},{"_id":"themes/vue/source/images/retool.png","hash":"08c4cbd16f45b2fe1cdc8e095982f07e959a82dc","modified":1594687607901},{"_id":"themes/vue/source/images/primevue.png","hash":"636a57faddf5950b8e47319456ae1d7a0f88fd29","modified":1594687607900},{"_id":"themes/vue/source/images/staff_augmentation.png","hash":"4d9475570c70eac3c3ada6ee8614b2e4a30f7d80","modified":1594687607906},{"_id":"themes/vue/source/images/storekit.png","hash":"47774422bb1bd1ed985ea3bb2f2ecb7754bb9983","modified":1594687607906},{"_id":"themes/vue/source/images/syncfusion.png","hash":"688285b2ae526c27aaa5cd081a95c881750c59cc","modified":1594687607909},{"_id":"themes/vue/source/images/tee__.png","hash":"e9fc652b1ed66c56be035c1a4607ade5724efc1f","modified":1594687607909},{"_id":"themes/vue/source/images/tidelift.png","hash":"63c60abbab4bcc37340f29e0db8290383fb35631","modified":1594687607910},{"_id":"themes/vue/source/images/tighten_co.png","hash":"a0f3f8614ad7f9a4e0eaa0793cf24519b5b25e45","modified":1594687607910},{"_id":"themes/vue/source/images/tooltwist.png","hash":"e625a481e2eb3f7194273d58b250d0fafd42e462","modified":1594687607911},{"_id":"themes/vue/source/images/unicorn_io.png","hash":"c93b60e72d38a6bb313a805d2d276d224fd591e8","modified":1594687607911},{"_id":"themes/vue/source/images/stdlib.png","hash":"7adff740e3c1a55e243dff2fb903250d1ba3f559","modified":1594687607906},{"_id":"themes/vue/source/images/tencent-ad.png","hash":"91e12bd1f3ec7dd78592d5a0d340731a1ad804f2","modified":1594687607910},{"_id":"themes/vue/source/images/vehikl.png","hash":"e5f045088e79ac5d3aedd2d4efc5b37d15431df0","modified":1594687607922},{"_id":"themes/vue/source/images/vpnranks.png","hash":"249546e6076846f8fbc7d772a6f51badd20f45af","modified":1594687607922},{"_id":"themes/vue/source/images/valuecoders.png","hash":"ae72f75eea4e7864c06b7641d0a4d426bdc59f18","modified":1594687607921},{"_id":"themes/vue/source/images/vant.png","hash":"2eba29b5e1203db67d00b6e13dc481b5d4859369","modified":1594687607921},{"_id":"themes/vue/source/images/vuemastery.png","hash":"a783b81f0d9ded6e8d46991cc8d18ff878e17656","modified":1594687607922},{"_id":"themes/vue/source/images/vuetify.png","hash":"66254951f82e0639fb588b362f72b80839d9f411","modified":1594687607923},{"_id":"themes/vue/source/images/vuejobs.png","hash":"149231804a4686f1ec890f7d984207ea83cf8190","modified":1594687607922},{"_id":"themes/vue/source/images/webdock.png","hash":"c32ce7cafbc31378c592226dac6ab8e0a8d9b124","modified":1594687607937},{"_id":"themes/vue/source/images/wilderminds.png","hash":"a9e87eda70ad75a6148e1a980cb4e4ddb085e3ca","modified":1594687607938},{"_id":"themes/vue/source/images/vueschool.png","hash":"a4ae5d18c97b8cb5a5d8fcd4c80a6230bf2fc3d9","modified":1594687607923},{"_id":"themes/vue/source/images/watchcartoononline.png","hash":"caacc07c694704a981e6555afe1d94015ceb0505","modified":1594687607936},{"_id":"themes/vue/source/images/y8.png","hash":"9b584ce4cc6a0724d1dd01ce694411e54f790425","modified":1594687607952},{"_id":"themes/vue/source/images/x_team.png","hash":"c2d996ec0a802ce39d695266fbc142dd7dad45c0","modified":1594687607951},{"_id":"themes/vue/source/images/xinguan.png","hash":"26c387e6ed56c3b8ac9ae89bc6ed0df00a1c092e","modified":1594687607952},{"_id":"themes/vue/source/images/youku.png","hash":"5a34edc5e3cb1fee6fe31d8920853e849eedc282","modified":1594687607953},{"_id":"src/doc/cookbook/bubble.md","hash":"1b7d9f184404eaddb930bd8d5c0d17d917f95209","modified":1594966759219},{"_id":"src/doc/cookbook/css.md","hash":"d91ccf67239dc7d03f81cbdac857cd1123e84559","modified":1594967095408},{"_id":"src/doc/cookbook/icon.md","hash":"866d77e11c9b9ad96dd9d120bb78c6715e59f4c1","modified":1594967125313},{"_id":"src/doc/cookbook/nvue安卓margin负数问题.md","hash":"60b8c8a6bd7d8777a47754fa3c320d1a40bfdb9c","modified":1594966759268},{"_id":"src/doc/cookbook/index.md","hash":"59572615181ff1656428a855ad3eacfa48c37ee2","modified":1594947617877},{"_id":"src/doc/cookbook/provide-inject.md","hash":"137e76c2c64e1b705b83f10c382e4083833577c5","modified":1594966759262},{"_id":"src/doc/cookbook/radius.md","hash":"5ec6ab77f07ea145f08e3c63d3561d5537fa015e","modified":1594966759255},{"_id":"src/doc/cookbook/scroll.md","hash":"016780dc49bdcf92f7952988d556554df12455d3","modified":1594967044420},{"_id":"src/doc/cookbook/sort.md","hash":"2bf670e797efc12deb3aaa34c29e1be696794008","modified":1594966892491},{"_id":"src/doc/cookbook/string.md","hash":"b8e88e359c39a96f3141f59a83dc18cf489b1812","modified":1594966832880},{"_id":"src/doc/cookbook/textarea.md","hash":"1d00630e34899a0698c69e0f2f60231504c425b8","modified":1594967010779},{"_id":"src/doc/cookbook/uni后缀.md","hash":"99ac212a07227a6ae8b2d61b9f3a190004f2507a","modified":1594966759191},{"_id":"src/doc/cookbook/windowScreen.md","hash":"5810d5ee9b42b43c2b9839c4801d0867899d08da","modified":1594966759305},{"_id":"src/doc/cookbook/v3.md","hash":"65d0c5b1048bf05efbd1ba1610c57ebc08edbc1d","modified":1594966912145},{"_id":"src/doc/cookbook/全局css的问题.md","hash":"39a98c4c8b9ab3546c15a0eb7bc538eac81e8ff8","modified":1594966759258},{"_id":"src/doc/cookbook/全局变量.md","hash":"7a295b265e82adc01be78f03005db408fa94edba","modified":1594966759281},{"_id":"src/doc/cookbook/小程序created注意.md","hash":"b8adfb6168eeb776272637dca65e554cfea2238e","modified":1594966759282},{"_id":"src/doc/cookbook/组件自适应高度的问题.md","hash":"dfa527e8ab667814c88b9413ab8aa226165b7493","modified":1594966759260},{"_id":"src/doc/search/index.md","hash":"7f76b8a040366f4d8e4b23d06d5e021fc45ce5c2","modified":1594947568977},{"_id":"src/doc/guide/design.md","hash":"fe927e2edd7caa4ee0e9ab2ed6e0ec052450ca32","modified":1594987681261},{"_id":"src/doc/guide/faq.md","hash":"6d0310add33f4370f5e7de5c8014cc1c0ec24baa","modified":1594965740652},{"_id":"src/doc/guide/global.md","hash":"38095def0c36f48d662a78b3cf54b52bf77e13b6","modified":1595337370005},{"_id":"src/doc/guide/index.md","hash":"d5ddce0b75ee675931446473e893aa947b6065ea","modified":1595386705608},{"_id":"src/doc/guide/history.md","hash":"cc15cc375656530077a1944ded31ca79822721d0","modified":1594965665767},{"_id":"src/doc/guide/mixins.md","hash":"6013a3eb7585e6b092e74d912705f4305c424de7","modified":1594965992333},{"_id":"src/doc/guide/myp-button.md","hash":"0b529ac56cc8a351dde9676efa0edb5abbc8c924","modified":1595340692641},{"_id":"src/doc/guide/myp-check.md","hash":"e23d739cf83a7f8be4f8172edbb46452e829ad71","modified":1595340992995},{"_id":"src/doc/guide/myp-cell.md","hash":"6a13d8e8a6b258234e79b028415fadfed25f52f8","modified":1595340709735},{"_id":"src/doc/guide/myp-flex.md","hash":"b8d8efc19fa0c7a9caed03567de8bf2a18e4448e","modified":1595340682862},{"_id":"src/doc/guide/myp-grid.md","hash":"f08ab661ce7b25d58ba092956544e17c670b873d","modified":1595341735472},{"_id":"src/doc/guide/myp-icon.md","hash":"59263b4b3321db09d73ae00bdb73e5712590f4de","modified":1595341691173},{"_id":"src/doc/guide/myp-input-grow.md","hash":"46e2b255bf7d18efe9249730ca280f97967ecc8e","modified":1595341160917},{"_id":"src/doc/guide/myp-input.md","hash":"b3c099f0a67005c5082d0928d4c984f48d0f2d88","modified":1595341102929},{"_id":"src/doc/guide/myp-input-one.md","hash":"305b89d52633a0a8a21c566dba9697602aff93a0","modified":1595341143359},{"_id":"src/doc/guide/myp-list-simple.md","hash":"848f5b5c2090e22c57e7e1047866dff1a35d51c0","modified":1595340719227},{"_id":"src/doc/guide/myp-loading.md","hash":"7f75ba942f15be53115e0523690f68db099b1fda","modified":1595342068636},{"_id":"src/doc/guide/myp-navbar.md","hash":"61e97d626ddbf50d29cab3cc88c1934db4f8b4c2","modified":1595340696819},{"_id":"src/doc/guide/myp-pagination.md","hash":"2bafa5b86bb34d1d01a32d04e5f07c729136eacf","modified":1595340729066},{"_id":"src/doc/guide/myp-picker.md","hash":"af590cca27b27196e584d5eb2972244ad93e781b","modified":1595341229659},{"_id":"src/doc/guide/myp-popover.md","hash":"7e0c65c10928fc04ed2ac825f64a01458a26fc53","modified":1595340734980},{"_id":"src/doc/guide/myp-popup.md","hash":"f494665ba836b99669fcce98c784f49256ebc560","modified":1595339640543},{"_id":"src/doc/guide/myp-refresher.md","hash":"6081bf4999c9c164d4df2702fc7b96a0d06c889f","modified":1595339590136},{"_id":"src/doc/guide/myp-popup-always.md","hash":"0140ef3ec23ab196c0c5ff4f51e8c7a685f907b6","modified":1595340741432},{"_id":"src/doc/guide/myp-search.md","hash":"aee6de6eee068cb68f9d962299614e0d2cface2b","modified":1595341176298},{"_id":"src/doc/guide/myp-segment.md","hash":"9ece834313df14b6cf7b7547412212ed8794beaf","modified":1595340754282},{"_id":"src/doc/guide/myp-space.md","hash":"e97ae2a0e50470574ccd2a21a3d7b0c9d0dba198","modified":1595340759964},{"_id":"src/doc/guide/myp-stepper.md","hash":"5ad1a0c921ffe72858eb6da17d40e432f703f630","modified":1595341323365},{"_id":"src/doc/guide/myp-switch.md","hash":"e0b63b41892f24f315489fdd11704f5c1add5abe","modified":1595341402847},{"_id":"src/doc/guide/myp-tabs-h.md","hash":"ba01d48ae5af0d9708faab31f0e230519cdc1f1f","modified":1595340773639},{"_id":"src/doc/guide/myp-tabbar.md","hash":"d45cdc8a6011272b0feeebcb85eb254d2a3d09e7","modified":1595340766173},{"_id":"src/doc/guide/myp-tabs-v.md","hash":"9c8685f22bb42e2aa5f00967f9983c73882b094d","modified":1595340779388},{"_id":"src/doc/guide/myp-tag.md","hash":"0ed485e2205eec5a7452c7bb2018994688f42316","modified":1595341794678},{"_id":"src/doc/guide/myp-wing.md","hash":"1bbfee33f2dbc766daf6fc293fe01f88e0f49726","modified":1595340785048},{"_id":"src/doc/guide/myp-toast.md","hash":"9165c13c0e6860c95c5e7f897eec9e667afe200f","modified":1595342004526},{"_id":"src/doc/guide/share.md","hash":"14981df276c6ca7d4de69e8a280feec28a4817c8","modified":1594966350719},{"_id":"src/doc/guide/routing.md","hash":"f761176934e7b2687530aad93eb4b4cdf5a240ac","modified":1594966055415},{"_id":"src/doc/guide/theme.md","hash":"11f692a9744922f1121062d04984cffbbd0e8ef5","modified":1594983915123},{"_id":"src/doc/guide/team.md","hash":"56e3d53d467c5dd8d7dc10dbfa6d3c447167ae4a","modified":1594965632394},{"_id":"src/doc/guide/why.md","hash":"c7e3cecced13757197ee9cbe3d035bfc4cf2c925","modified":1595335825099},{"_id":"src/doc/tool/component.md","hash":"960c965548273980f4aab6f6ce9a44c5b067539d","modified":1594964201642},{"_id":"src/doc/tool/icon.md","hash":"003d86626a32af912014264c4b67a238a5ec52ef","modified":1594964163240},{"_id":"src/doc/tool/props.md","hash":"6e7d5fb6284ac0b287bbb5c9af0f1677bdfcc23a","modified":1594964189077},{"_id":"themes/vue/source/js/vue.min.js","hash":"28bb1c91e37b53f4ebb48ce482dccb240003e078","modified":1594687607959},{"_id":"themes/vue/source/images/accelebrate.png","hash":"c20a58507563546c91813caa2d7751420a1d6cf3","modified":1594687607866},{"_id":"themes/vue/source/images/pay_ali_68.png","hash":"0cb7c530a1960298973c3ccf7e458dce78c441b8","modified":1594952345475},{"_id":"themes/vue/source/images/pay_wx.png","hash":"11cc33e33a431d6c6e62a0faa789d7d4bf09f3d0","modified":1594950278849},{"_id":"themes/vue/source/images/pay_wx_68.png","hash":"fe720d506376a64d6fc36ddab0f27b4a27c08d98","modified":1594952117625},{"_id":"themes/vue/source/images/usave.png","hash":"d9de7e9a012a636cdb323a62faa62d05fca33141","modified":1594687607921},{"_id":"themes/vue/source/images/webucator.png","hash":"940bdf955efcea9471ebcc586d371fa839496c09","modified":1594687607937},{"_id":"src/images/doc/button.png","hash":"9ced39ada9842200a79849251ff9f6580f37e59a","modified":1594983626796},{"_id":"themes/vue/source/images/yakaz.png","hash":"8287ea4beca210e44cde508247c09b930e48d01a","modified":1594687607952},{"_id":"src/images/memory-leak-example.png","hash":"7c2df66d99f06df266d294aa7c923fe5e8af7657","modified":1594687607799},{"_id":"src/doc/style-guide/index.md","hash":"362b3d981bf4d60dc1df0ae84b67239be294a68b","modified":1594908117659},{"_id":"src/images/oxford-comma.jpg","hash":"8c315f549b52fe61222d237ea8375a5b64a4737c","modified":1594687607801},{"_id":"themes/vue/source/fonts/Dosis/OFL.txt","hash":"1c7ff35d5e3c52d3df9dde38e2dd4d863e8b81fb","modified":1594687607858},{"_id":"themes/vue/source/fonts/Roboto_Mono/LICENSE.txt","hash":"47b573e3824cd5e02a1a3ae99e2735b49e0256e4","modified":1594687607858},{"_id":"themes/vue/source/fonts/Source_Sans_Pro/OFL.txt","hash":"2f3d8677bb9852e9c41e392aacd78fcf090d9925","modified":1594687607860},{"_id":"themes/vue/source/images/icons/android-icon-144x144.png","hash":"49a38f2187ebb43a2b332791fe45bddd01afbc9d","modified":1594687607878},{"_id":"themes/vue/source/images/icons/android-icon-192x192.png","hash":"b35d14364fce39e54f3896ddee44f970b7487b2c","modified":1594687607878},{"_id":"themes/vue/source/images/icons/android-icon-36x36.png","hash":"ea99e8a2db010e40c71fd254d3709c5fd551610d","modified":1594687607879},{"_id":"themes/vue/source/images/icons/android-icon-48x48.png","hash":"05c04b9833c99ddcab596fe99250a88a3e6df583","modified":1594687607879},{"_id":"themes/vue/source/images/icons/android-icon-72x72.png","hash":"66a36856e9d0af7902abcf9f24401f68d429d0d6","modified":1594687607879},{"_id":"themes/vue/source/images/icons/android-icon-96x96.png","hash":"7192dfc87e31d5ff5490f0be38a0a3c85584f6ac","modified":1594687607879},{"_id":"themes/vue/source/images/icons/apple-icon-114x114.png","hash":"07fce47fddaae024a74f027c3a8c98b385096060","modified":1594687607879},{"_id":"themes/vue/source/images/icons/apple-icon-120x120.png","hash":"0c55163aeba24ccf0508e49cd4ee08ba9c9757a6","modified":1594687607880},{"_id":"themes/vue/source/images/icons/apple-icon-144x144.png","hash":"49a38f2187ebb43a2b332791fe45bddd01afbc9d","modified":1594687607880},{"_id":"themes/vue/source/images/icons/apple-icon-152x152.png","hash":"52f7579762a3dc955a9ad67a6918a049e2720164","modified":1594687607880},{"_id":"themes/vue/source/images/icons/apple-icon-180x180.png","hash":"5e828e492672efd0d9e6ac2b5ff46ae45ff34ab9","modified":1594687607880},{"_id":"themes/vue/source/images/icons/apple-icon-57x57.png","hash":"cf8ac1abcb1c53cb9b201ef082ba29a9591844d6","modified":1594687607880},{"_id":"themes/vue/source/images/icons/apple-icon-60x60.png","hash":"c1905c7bf23fe3f08dcecc45b1638e6a2da60f42","modified":1594687607881},{"_id":"themes/vue/source/images/icons/apple-icon-72x72.png","hash":"66a36856e9d0af7902abcf9f24401f68d429d0d6","modified":1594687607881},{"_id":"themes/vue/source/images/icons/apple-icon-76x76.png","hash":"c7ad68677d2647033a60911731cf82db37784cf3","modified":1594687607881},{"_id":"themes/vue/source/images/icons/apple-icon-precomposed.png","hash":"d07baf1d7200a145c15bb2b7abc9c1c864e0cdf9","modified":1594687607881},{"_id":"themes/vue/source/images/icons/apple-icon.png","hash":"d07baf1d7200a145c15bb2b7abc9c1c864e0cdf9","modified":1594687607881},{"_id":"themes/vue/source/images/bacancy_technology.png","hash":"920b3e48d4b18d454ecaeffd4e2895ceff06d1ec","modified":1594687607868},{"_id":"themes/vue/source/images/icons/favicon-16x16.png","hash":"03f5391b57618b4b868ad3addec3375ec03db088","modified":1594687607883},{"_id":"themes/vue/source/images/icons/favicon-32x32.png","hash":"fd0ea145dddf84c510317b7320b2c53efd850260","modified":1594687607884},{"_id":"themes/vue/source/images/icons/favicon.ico","hash":"3c5aa0ae13d561379ea8ce15f4d7e02163ef3273","modified":1594687607884},{"_id":"themes/vue/source/images/icons/favicon-96x96.png","hash":"7192dfc87e31d5ff5490f0be38a0a3c85584f6ac","modified":1594687607884},{"_id":"themes/vue/source/images/icons/ms-icon-150x150.png","hash":"52c635f52bb7b91382a2f8d61f64a4ff25ae11aa","modified":1594687607885},{"_id":"themes/vue/source/images/icons/ms-icon-144x144.png","hash":"49a38f2187ebb43a2b332791fe45bddd01afbc9d","modified":1594687607884},{"_id":"themes/vue/source/images/icons/ms-icon-70x70.png","hash":"8b326124c52e9b2e6c2826232a7627cdadbd3c0b","modified":1594687607885},{"_id":"themes/vue/source/images/icons/ms-icon-310x310.png","hash":"58f800960bae4c97a0d14bdd42f98db20c2e2bc8","modified":1594687607885},{"_id":"themes/vue/source/images/storyblok.png","hash":"733685fbd16245c42a9a0b2e36010c86a9549dcd","modified":1594687607909},{"_id":"src/doc/api/index.md","hash":"36db9b715071a0cdb760708f892a07dc528c3fc1","modified":1594907921504},{"_id":"themes/vue/source/images/writers_per_hour.jpg","hash":"e4d91e160e2a34c4f2180fb0ec4e3f014f08edd1","modified":1594687607951},{"_id":"themes/vue/source/fonts/Roboto_Mono/RobotoMono-Regular.ttf","hash":"69a65c2b797d2fa124b4c709097e761b7857a035","modified":1594687607860},{"_id":"themes/vue/source/fonts/Dosis/Dosis-Medium.ttf","hash":"46067c93a46fbb4d0b38f9ce7fe0e2c5e4d8c047","modified":1594687607858},{"_id":"themes/vue/source/fonts/Source_Sans_Pro/SourceSansPro-Regular.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1594687607863},{"_id":"themes/vue/source/fonts/Source_Sans_Pro/SourceSansPro-Semibold.ttf","hash":"f08e28d10c1bfe92543416e30b59620942859696","modified":1594687607865},{"_id":"themes/vue/source/js/vue.js","hash":"e7bebefc32cb9c0d8261e764e8f24c1cd41c217f","modified":1594687607956},{"_id":"themes/vue/source/images/special-sponsor-spot.png","hash":"f635521496f2f8a4c35c67160b088c1756b7d948","modified":1594687607905},{"_id":"themes/vue/source/images/icons/bacancy_technology.png","hash":"900c58a849862758c7062030f5a3aa09fd785a21","modified":1594687607883},{"_id":"themes/vue/source/fonts/Source_Sans_Pro/SourceSansPro-Light.ttf","hash":"bae12c1d7c8d38f88ac5566ea3b3a97c9f5ac446","modified":1594687607862},{"_id":"src/images/devtools-timetravel.gif","hash":"43ddab8e7869a513c2058d2892b54d0c556ef5e2","modified":1594687607794},{"_id":"themes/vue/source/images/pay_ali.jpeg","hash":"a4548567e705f353fec5fb98f13a1d667d270309","modified":1594950278834},{"_id":"src/images/breakpoint_set.png","hash":"db3c2527261d19c83424b69d789fca4a85dbec07","modified":1594687607781},{"_id":"src/images/config_add.png","hash":"ef17eaeb40ca00f9c66d813c569c1b54160db1a9","modified":1594687607787},{"_id":"src/images/breakpoint_hit.png","hash":"56c93842cb88a37df7dd327507c5c44f94459e72","modified":1594687607777}],"Category":[],"Data":[],"Page":[{"index":true,"_content":"","source":"index.md","raw":"index: true\n---\n","date":"2020-07-16T09:39:50.575Z","updated":"2020-07-14T00:46:47.803Z","path":"index.html","title":"","comments":1,"layout":"page","_id":"ckcwngnhr00009lxkgvk0rky8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"贡献者","type":"about","order":0,"_content":"\n## Guide 翻译贡献\n\n### Essentials  基础\n\n序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者\n----- | ------------- | --- | --- | --- | --- | ---\n1 |  installation.md | 安装 | [dingyiming](https://github.com/dingyiming)  | [ATLgo](https://github.com/ATLgo) [70data](https://github.com/70data)\n2 |  index.md |  介绍 | [hijiangtao](https://github.com/hijiangtao) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)\n3 |  instance.md | 实例 | [dingyiming](https://github.com/dingyiming) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)\n4 |  syntax.md  | 模板语法 | [daix6](https://github.com/daix6) | [70data](https://github.com/70data)\n5 |  computed.md | 计算属 性 | [dingyiming](https://github.com/dingyiming) [70data](https://github.com/70data) | [70data](https://github.com/70data)\n6 |  class-and-style.md | Class 与 Style 绑定 | [595074187](https://github.com/595074187) | [70data](https://github.com/70data)\n7 |  conditional.md  | 条件渲染 | [dingyiming](https://github.com/dingyiming) | [hgcoder](https://github.com/hgcoder)\n8 |  list.md |  列表渲染 | [tingtien](https://github.com/tingtien) | [hgcoder](https://github.com/hgcoder)\n9 |  events.md | 事件处理器 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)\n10 |  forms.md  | 表单控件绑定 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)\n11 |  components.md |  组件 | [ezreally](https://github.com/ezreally) | [cuiyongjian](https://github.com/cuiyongjian)\n\n### Advanced  进阶\n\n序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者\n----- | ------------- | --- | --- | --- | ---\n12 |  transitions.md | 过渡: 进入, 离开, 和 列表 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf) [StoneQI](https://github.com/StoneQI)\n13 |  transitioning-state.md | 过渡状态 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)\n14 |  render-function.md |  Render 函数 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)\n15 |  reactivity.md |  深入响应式原理 | [veaba](https://github.com/veaba) | [yangzj1992](https://github.com/yangzj1992)\n16 |  custom-directive.md |  自定义指令 | [hurrytospring](https://github.com/hurrytospring) | [yangzj1992](https://github.com/yangzj1992)\n17 |  mixins.md |  混合 | [hurrytospring](https://github.com/hurrytospring) | [bhnddowinf](https://github.com/bhnddowinf)\n18 |  plugins.md |  插件 | [hgcoder](https://github.com/hgcoder) | [hgcoder](https://github.com/hgcoder)\n19 |  single-file-components.md |  单文件组件 | [ATLgo](https://github.com/ATLgo) | [zhouzihanntu](https://github.com/zhouzihanntu)\n20 |  routing.md | 路由 | [dingyiming](https://github.com/dingyiming) | [mlyknown](https://github.com/mlyknown)\n21 |  state-management.md |  状态管理 | [dear-lizhihua](https://github.com/dear-lizhihua) | [mlyknown](https://github.com/mlyknown)\n22 |  unit-testing.md | 单元测试 | [70data](https://github.com/70data) | [mlyknown](https://github.com/mlyknown)\n23 |  ssr.md |  服务端渲染 | [dingyiming](https://github.com/dingyiming) | [yongbolv](https://github.com/yongbolv)\n\n### Migration  迁移\n\n序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者\n----- |  ------------- | --- | --- | --- | ---\n24 |  migration.md | 1.x迁移 | [hurrytospring](https://github.com/hurrytospring) | [yongbolv](https://github.com/yongbolv)\n27 |  migration-vue-router.md | vue-router 0.7.x 迁移 | [forzajuve10](https://github.com/forzajuve10) | [yizhixiaolongxia](https://github.com/yizhixiaolongxia)\n\n### Meta  更多\n\n序号 | 对应文档文件名 | 中文标题 |  翻译贡献者 | 校对主要贡献者\n----- | ------------- | --- | --- | --- | ---\n25 |  comparison.md |   对比其他框架 | [yongbolv](https://github.com/yongbolv) | [yangzj1992](https://github.com/yangzj1992)\n26 |  join.md |  加入 Vue.js 社区 | [daix6](https://github.com/daix6) | [zhouzihanntu](https://github.com/zhouzihanntu)\n\n## API翻译贡献\n\n序号 | 对应小节名称 | 中文标题 | 翻译贡献者 | 校对主要贡献者\n----- |  ------------- | --- | --- | --- | --- | ---\n1 |  Global Config | 全局配置 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)\n2 |  Global API | 全局 API | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)\n3 |  Options / Data | 选项 / 数据 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)\n4 |  Options / DOM | 选项 / DOM | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)\n5 |  Options / Lifecycle Hooks | 选项 / 生命周期钩子 | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)\n6 |  Options / Assets | 选项 / 资源 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)\n7 |  Options / Misc | 选项 / 杂项 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)\n8 |  Instance Properties | 实例属性 | [coolzjy](https://github.com/coolzjy) | [bhnddowinf](https://github.com/bhnddowinf)\n9 |  Instance Methods / Data | 实例方法 / 数据 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)\n10 |  Instance Methods / Events | 实例方法 / 事件 | [mlyknown](https://github.com/mlyknown) | [bhnddowinf](https://github.com/bhnddowinf)\n11 |   Instance Methods / Lifecycle | 实例方法 / 生命周期 |  [mlyknown](https://github.com/mlyknown)| [bhnddowinf](https://github.com/bhnddowinf)\n12 |  Directives | 指令| [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)\n13 |  Special Attributes | 特殊元素 | [70data](https://github.com/70data) | [bhnddowinf](https://github.com/bhnddowinf)\n14 |  Built-In Components | 内置的组件  | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)\n15 |  VNode Interface | VNode 接口  | [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)\n16 |  Server-Side Rendering | 服务端渲染| [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)\n\n## 示例翻译\n\n翻译贡献者 ： [lindazhang102](https://github.com/lindazhang102)\n\n## 感谢所有参与翻译的朋友们！\n","source":"about/index.md","raw":"---\ntitle: 贡献者\ntype: about\norder: 0\n---\n\n## Guide 翻译贡献\n\n### Essentials  基础\n\n序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者\n----- | ------------- | --- | --- | --- | --- | ---\n1 |  installation.md | 安装 | [dingyiming](https://github.com/dingyiming)  | [ATLgo](https://github.com/ATLgo) [70data](https://github.com/70data)\n2 |  index.md |  介绍 | [hijiangtao](https://github.com/hijiangtao) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)\n3 |  instance.md | 实例 | [dingyiming](https://github.com/dingyiming) | [70data](https://github.com/70data) [ATLgo](https://github.com/ATLgo)\n4 |  syntax.md  | 模板语法 | [daix6](https://github.com/daix6) | [70data](https://github.com/70data)\n5 |  computed.md | 计算属 性 | [dingyiming](https://github.com/dingyiming) [70data](https://github.com/70data) | [70data](https://github.com/70data)\n6 |  class-and-style.md | Class 与 Style 绑定 | [595074187](https://github.com/595074187) | [70data](https://github.com/70data)\n7 |  conditional.md  | 条件渲染 | [dingyiming](https://github.com/dingyiming) | [hgcoder](https://github.com/hgcoder)\n8 |  list.md |  列表渲染 | [tingtien](https://github.com/tingtien) | [hgcoder](https://github.com/hgcoder)\n9 |  events.md | 事件处理器 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)\n10 |  forms.md  | 表单控件绑定 | [dingyiming](https://github.com/dingyiming) | [yangzj1992](https://github.com/yangzj1992)\n11 |  components.md |  组件 | [ezreally](https://github.com/ezreally) | [cuiyongjian](https://github.com/cuiyongjian)\n\n### Advanced  进阶\n\n序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者\n----- | ------------- | --- | --- | --- | ---\n12 |  transitions.md | 过渡: 进入, 离开, 和 列表 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf) [StoneQI](https://github.com/StoneQI)\n13 |  transitioning-state.md | 过渡状态 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)\n14 |  render-function.md |  Render 函数 | [awe](https://github.com/hilongjw) | [bhnddowinf](https://github.com/bhnddowinf)\n15 |  reactivity.md |  深入响应式原理 | [veaba](https://github.com/veaba) | [yangzj1992](https://github.com/yangzj1992)\n16 |  custom-directive.md |  自定义指令 | [hurrytospring](https://github.com/hurrytospring) | [yangzj1992](https://github.com/yangzj1992)\n17 |  mixins.md |  混合 | [hurrytospring](https://github.com/hurrytospring) | [bhnddowinf](https://github.com/bhnddowinf)\n18 |  plugins.md |  插件 | [hgcoder](https://github.com/hgcoder) | [hgcoder](https://github.com/hgcoder)\n19 |  single-file-components.md |  单文件组件 | [ATLgo](https://github.com/ATLgo) | [zhouzihanntu](https://github.com/zhouzihanntu)\n20 |  routing.md | 路由 | [dingyiming](https://github.com/dingyiming) | [mlyknown](https://github.com/mlyknown)\n21 |  state-management.md |  状态管理 | [dear-lizhihua](https://github.com/dear-lizhihua) | [mlyknown](https://github.com/mlyknown)\n22 |  unit-testing.md | 单元测试 | [70data](https://github.com/70data) | [mlyknown](https://github.com/mlyknown)\n23 |  ssr.md |  服务端渲染 | [dingyiming](https://github.com/dingyiming) | [yongbolv](https://github.com/yongbolv)\n\n### Migration  迁移\n\n序号 | 对应文档文件名 | 中文标题 | 翻译贡献者 | 校对主要贡献者\n----- |  ------------- | --- | --- | --- | ---\n24 |  migration.md | 1.x迁移 | [hurrytospring](https://github.com/hurrytospring) | [yongbolv](https://github.com/yongbolv)\n27 |  migration-vue-router.md | vue-router 0.7.x 迁移 | [forzajuve10](https://github.com/forzajuve10) | [yizhixiaolongxia](https://github.com/yizhixiaolongxia)\n\n### Meta  更多\n\n序号 | 对应文档文件名 | 中文标题 |  翻译贡献者 | 校对主要贡献者\n----- | ------------- | --- | --- | --- | ---\n25 |  comparison.md |   对比其他框架 | [yongbolv](https://github.com/yongbolv) | [yangzj1992](https://github.com/yangzj1992)\n26 |  join.md |  加入 Vue.js 社区 | [daix6](https://github.com/daix6) | [zhouzihanntu](https://github.com/zhouzihanntu)\n\n## API翻译贡献\n\n序号 | 对应小节名称 | 中文标题 | 翻译贡献者 | 校对主要贡献者\n----- |  ------------- | --- | --- | --- | --- | ---\n1 |  Global Config | 全局配置 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)\n2 |  Global API | 全局 API | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)\n3 |  Options / Data | 选项 / 数据 | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)\n4 |  Options / DOM | 选项 / DOM | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)\n5 |  Options / Lifecycle Hooks | 选项 / 生命周期钩子 | [ATLgo](https://github.com/ATLgo) | [bhnddowinf](https://github.com/bhnddowinf)\n6 |  Options / Assets | 选项 / 资源 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)\n7 |  Options / Misc | 选项 / 杂项 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)\n8 |  Instance Properties | 实例属性 | [coolzjy](https://github.com/coolzjy) | [bhnddowinf](https://github.com/bhnddowinf)\n9 |  Instance Methods / Data | 实例方法 / 数据 | [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)\n10 |  Instance Methods / Events | 实例方法 / 事件 | [mlyknown](https://github.com/mlyknown) | [bhnddowinf](https://github.com/bhnddowinf)\n11 |   Instance Methods / Lifecycle | 实例方法 / 生命周期 |  [mlyknown](https://github.com/mlyknown)| [bhnddowinf](https://github.com/bhnddowinf)\n12 |  Directives | 指令| [dingyiming](https://github.com/dingyiming) | [bhnddowinf](https://github.com/bhnddowinf)\n13 |  Special Attributes | 特殊元素 | [70data](https://github.com/70data) | [bhnddowinf](https://github.com/bhnddowinf)\n14 |  Built-In Components | 内置的组件  | [dear-lizhihua](https://github.com/dear-lizhihua) | [bhnddowinf](https://github.com/bhnddowinf)\n15 |  VNode Interface | VNode 接口  | [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)\n16 |  Server-Side Rendering | 服务端渲染| [70data](https://github.com/70data) | [dear-lizhihua](https://github.com/dear-lizhihua)\n\n## 示例翻译\n\n翻译贡献者 ： [lindazhang102](https://github.com/lindazhang102)\n\n## 感谢所有参与翻译的朋友们！\n","date":"2020-07-16T09:39:50.153Z","updated":"2020-07-14T00:46:47.770Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckcwngnip00029lxkk9t9pc7b","content":"<h2 id=\"Guide-翻译贡献\"><a href=\"#Guide-翻译贡献\" class=\"headerlink\" title=\"Guide 翻译贡献\"></a>Guide 翻译贡献</h2><h3 id=\"Essentials-基础\"><a href=\"#Essentials-基础\" class=\"headerlink\" title=\"Essentials  基础\"></a>Essentials  基础</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>对应文档文件名</th>\n<th>中文标题</th>\n<th>翻译贡献者</th>\n<th>校对主要贡献者</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>installation.md</td>\n<td>安装</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a> <a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n</tr>\n<tr>\n<td>2</td>\n<td>index.md</td>\n<td>介绍</td>\n<td><a href=\"https://github.com/hijiangtao\" target=\"_blank\" rel=\"noopener\">hijiangtao</a></td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a> <a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a></td>\n</tr>\n<tr>\n<td>3</td>\n<td>instance.md</td>\n<td>实例</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a> <a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a></td>\n</tr>\n<tr>\n<td>4</td>\n<td>syntax.md</td>\n<td>模板语法</td>\n<td><a href=\"https://github.com/daix6\" target=\"_blank\" rel=\"noopener\">daix6</a></td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n</tr>\n<tr>\n<td>5</td>\n<td>computed.md</td>\n<td>计算属 性</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a> <a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n</tr>\n<tr>\n<td>6</td>\n<td>class-and-style.md</td>\n<td>Class 与 Style 绑定</td>\n<td><a href=\"https://github.com/595074187\" target=\"_blank\" rel=\"noopener\">595074187</a></td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n</tr>\n<tr>\n<td>7</td>\n<td>conditional.md</td>\n<td>条件渲染</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/hgcoder\" target=\"_blank\" rel=\"noopener\">hgcoder</a></td>\n</tr>\n<tr>\n<td>8</td>\n<td>list.md</td>\n<td>列表渲染</td>\n<td><a href=\"https://github.com/tingtien\" target=\"_blank\" rel=\"noopener\">tingtien</a></td>\n<td><a href=\"https://github.com/hgcoder\" target=\"_blank\" rel=\"noopener\">hgcoder</a></td>\n</tr>\n<tr>\n<td>9</td>\n<td>events.md</td>\n<td>事件处理器</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/yangzj1992\" target=\"_blank\" rel=\"noopener\">yangzj1992</a></td>\n</tr>\n<tr>\n<td>10</td>\n<td>forms.md</td>\n<td>表单控件绑定</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/yangzj1992\" target=\"_blank\" rel=\"noopener\">yangzj1992</a></td>\n</tr>\n<tr>\n<td>11</td>\n<td>components.md</td>\n<td>组件</td>\n<td><a href=\"https://github.com/ezreally\" target=\"_blank\" rel=\"noopener\">ezreally</a></td>\n<td><a href=\"https://github.com/cuiyongjian\" target=\"_blank\" rel=\"noopener\">cuiyongjian</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Advanced-进阶\"><a href=\"#Advanced-进阶\" class=\"headerlink\" title=\"Advanced  进阶\"></a>Advanced  进阶</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>对应文档文件名</th>\n<th>中文标题</th>\n<th>翻译贡献者</th>\n<th>校对主要贡献者</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>12</td>\n<td>transitions.md</td>\n<td>过渡: 进入, 离开, 和 列表</td>\n<td><a href=\"https://github.com/hilongjw\" target=\"_blank\" rel=\"noopener\">awe</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a> <a href=\"https://github.com/StoneQI\" target=\"_blank\" rel=\"noopener\">StoneQI</a></td>\n</tr>\n<tr>\n<td>13</td>\n<td>transitioning-state.md</td>\n<td>过渡状态</td>\n<td><a href=\"https://github.com/hilongjw\" target=\"_blank\" rel=\"noopener\">awe</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>14</td>\n<td>render-function.md</td>\n<td>Render 函数</td>\n<td><a href=\"https://github.com/hilongjw\" target=\"_blank\" rel=\"noopener\">awe</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>15</td>\n<td>reactivity.md</td>\n<td>深入响应式原理</td>\n<td><a href=\"https://github.com/veaba\" target=\"_blank\" rel=\"noopener\">veaba</a></td>\n<td><a href=\"https://github.com/yangzj1992\" target=\"_blank\" rel=\"noopener\">yangzj1992</a></td>\n</tr>\n<tr>\n<td>16</td>\n<td>custom-directive.md</td>\n<td>自定义指令</td>\n<td><a href=\"https://github.com/hurrytospring\" target=\"_blank\" rel=\"noopener\">hurrytospring</a></td>\n<td><a href=\"https://github.com/yangzj1992\" target=\"_blank\" rel=\"noopener\">yangzj1992</a></td>\n</tr>\n<tr>\n<td>17</td>\n<td>mixins.md</td>\n<td>混合</td>\n<td><a href=\"https://github.com/hurrytospring\" target=\"_blank\" rel=\"noopener\">hurrytospring</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>18</td>\n<td>plugins.md</td>\n<td>插件</td>\n<td><a href=\"https://github.com/hgcoder\" target=\"_blank\" rel=\"noopener\">hgcoder</a></td>\n<td><a href=\"https://github.com/hgcoder\" target=\"_blank\" rel=\"noopener\">hgcoder</a></td>\n</tr>\n<tr>\n<td>19</td>\n<td>single-file-components.md</td>\n<td>单文件组件</td>\n<td><a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a></td>\n<td><a href=\"https://github.com/zhouzihanntu\" target=\"_blank\" rel=\"noopener\">zhouzihanntu</a></td>\n</tr>\n<tr>\n<td>20</td>\n<td>routing.md</td>\n<td>路由</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/mlyknown\" target=\"_blank\" rel=\"noopener\">mlyknown</a></td>\n</tr>\n<tr>\n<td>21</td>\n<td>state-management.md</td>\n<td>状态管理</td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n<td><a href=\"https://github.com/mlyknown\" target=\"_blank\" rel=\"noopener\">mlyknown</a></td>\n</tr>\n<tr>\n<td>22</td>\n<td>unit-testing.md</td>\n<td>单元测试</td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n<td><a href=\"https://github.com/mlyknown\" target=\"_blank\" rel=\"noopener\">mlyknown</a></td>\n</tr>\n<tr>\n<td>23</td>\n<td>ssr.md</td>\n<td>服务端渲染</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/yongbolv\" target=\"_blank\" rel=\"noopener\">yongbolv</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Migration-迁移\"><a href=\"#Migration-迁移\" class=\"headerlink\" title=\"Migration  迁移\"></a>Migration  迁移</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>对应文档文件名</th>\n<th>中文标题</th>\n<th>翻译贡献者</th>\n<th>校对主要贡献者</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>24</td>\n<td>migration.md</td>\n<td>1.x迁移</td>\n<td><a href=\"https://github.com/hurrytospring\" target=\"_blank\" rel=\"noopener\">hurrytospring</a></td>\n<td><a href=\"https://github.com/yongbolv\" target=\"_blank\" rel=\"noopener\">yongbolv</a></td>\n</tr>\n<tr>\n<td>27</td>\n<td>migration-vue-router.md</td>\n<td>vue-router 0.7.x 迁移</td>\n<td><a href=\"https://github.com/forzajuve10\" target=\"_blank\" rel=\"noopener\">forzajuve10</a></td>\n<td><a href=\"https://github.com/yizhixiaolongxia\" target=\"_blank\" rel=\"noopener\">yizhixiaolongxia</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Meta-更多\"><a href=\"#Meta-更多\" class=\"headerlink\" title=\"Meta  更多\"></a>Meta  更多</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>对应文档文件名</th>\n<th>中文标题</th>\n<th>翻译贡献者</th>\n<th>校对主要贡献者</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>25</td>\n<td>comparison.md</td>\n<td>对比其他框架</td>\n<td><a href=\"https://github.com/yongbolv\" target=\"_blank\" rel=\"noopener\">yongbolv</a></td>\n<td><a href=\"https://github.com/yangzj1992\" target=\"_blank\" rel=\"noopener\">yangzj1992</a></td>\n</tr>\n<tr>\n<td>26</td>\n<td>join.md</td>\n<td>加入 Vue.js 社区</td>\n<td><a href=\"https://github.com/daix6\" target=\"_blank\" rel=\"noopener\">daix6</a></td>\n<td><a href=\"https://github.com/zhouzihanntu\" target=\"_blank\" rel=\"noopener\">zhouzihanntu</a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"API翻译贡献\"><a href=\"#API翻译贡献\" class=\"headerlink\" title=\"API翻译贡献\"></a>API翻译贡献</h2><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>对应小节名称</th>\n<th>中文标题</th>\n<th>翻译贡献者</th>\n<th>校对主要贡献者</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Global Config</td>\n<td>全局配置</td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Global API</td>\n<td>全局 API</td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Options / Data</td>\n<td>选项 / 数据</td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>4</td>\n<td>Options / DOM</td>\n<td>选项 / DOM</td>\n<td><a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Options / Lifecycle Hooks</td>\n<td>选项 / 生命周期钩子</td>\n<td><a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Options / Assets</td>\n<td>选项 / 资源</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>7</td>\n<td>Options / Misc</td>\n<td>选项 / 杂项</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Instance Properties</td>\n<td>实例属性</td>\n<td><a href=\"https://github.com/coolzjy\" target=\"_blank\" rel=\"noopener\">coolzjy</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>9</td>\n<td>Instance Methods / Data</td>\n<td>实例方法 / 数据</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>10</td>\n<td>Instance Methods / Events</td>\n<td>实例方法 / 事件</td>\n<td><a href=\"https://github.com/mlyknown\" target=\"_blank\" rel=\"noopener\">mlyknown</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>11</td>\n<td>Instance Methods / Lifecycle</td>\n<td>实例方法 / 生命周期</td>\n<td><a href=\"https://github.com/mlyknown\" target=\"_blank\" rel=\"noopener\">mlyknown</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>12</td>\n<td>Directives</td>\n<td>指令</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>13</td>\n<td>Special Attributes</td>\n<td>特殊元素</td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>14</td>\n<td>Built-In Components</td>\n<td>内置的组件</td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>15</td>\n<td>VNode Interface</td>\n<td>VNode 接口</td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n</tr>\n<tr>\n<td>16</td>\n<td>Server-Side Rendering</td>\n<td>服务端渲染</td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"示例翻译\"><a href=\"#示例翻译\" class=\"headerlink\" title=\"示例翻译\"></a>示例翻译</h2><p>翻译贡献者 ： <a href=\"https://github.com/lindazhang102\" target=\"_blank\" rel=\"noopener\">lindazhang102</a></p>\n<h2 id=\"感谢所有参与翻译的朋友们！\"><a href=\"#感谢所有参与翻译的朋友们！\" class=\"headerlink\" title=\"感谢所有参与翻译的朋友们！\"></a>感谢所有参与翻译的朋友们！</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Guide-翻译贡献\"><a href=\"#Guide-翻译贡献\" class=\"headerlink\" title=\"Guide 翻译贡献\"></a>Guide 翻译贡献</h2><h3 id=\"Essentials-基础\"><a href=\"#Essentials-基础\" class=\"headerlink\" title=\"Essentials  基础\"></a>Essentials  基础</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>对应文档文件名</th>\n<th>中文标题</th>\n<th>翻译贡献者</th>\n<th>校对主要贡献者</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>installation.md</td>\n<td>安装</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a> <a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n</tr>\n<tr>\n<td>2</td>\n<td>index.md</td>\n<td>介绍</td>\n<td><a href=\"https://github.com/hijiangtao\" target=\"_blank\" rel=\"noopener\">hijiangtao</a></td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a> <a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a></td>\n</tr>\n<tr>\n<td>3</td>\n<td>instance.md</td>\n<td>实例</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a> <a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a></td>\n</tr>\n<tr>\n<td>4</td>\n<td>syntax.md</td>\n<td>模板语法</td>\n<td><a href=\"https://github.com/daix6\" target=\"_blank\" rel=\"noopener\">daix6</a></td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n</tr>\n<tr>\n<td>5</td>\n<td>computed.md</td>\n<td>计算属 性</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a> <a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n</tr>\n<tr>\n<td>6</td>\n<td>class-and-style.md</td>\n<td>Class 与 Style 绑定</td>\n<td><a href=\"https://github.com/595074187\" target=\"_blank\" rel=\"noopener\">595074187</a></td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n</tr>\n<tr>\n<td>7</td>\n<td>conditional.md</td>\n<td>条件渲染</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/hgcoder\" target=\"_blank\" rel=\"noopener\">hgcoder</a></td>\n</tr>\n<tr>\n<td>8</td>\n<td>list.md</td>\n<td>列表渲染</td>\n<td><a href=\"https://github.com/tingtien\" target=\"_blank\" rel=\"noopener\">tingtien</a></td>\n<td><a href=\"https://github.com/hgcoder\" target=\"_blank\" rel=\"noopener\">hgcoder</a></td>\n</tr>\n<tr>\n<td>9</td>\n<td>events.md</td>\n<td>事件处理器</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/yangzj1992\" target=\"_blank\" rel=\"noopener\">yangzj1992</a></td>\n</tr>\n<tr>\n<td>10</td>\n<td>forms.md</td>\n<td>表单控件绑定</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/yangzj1992\" target=\"_blank\" rel=\"noopener\">yangzj1992</a></td>\n</tr>\n<tr>\n<td>11</td>\n<td>components.md</td>\n<td>组件</td>\n<td><a href=\"https://github.com/ezreally\" target=\"_blank\" rel=\"noopener\">ezreally</a></td>\n<td><a href=\"https://github.com/cuiyongjian\" target=\"_blank\" rel=\"noopener\">cuiyongjian</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Advanced-进阶\"><a href=\"#Advanced-进阶\" class=\"headerlink\" title=\"Advanced  进阶\"></a>Advanced  进阶</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>对应文档文件名</th>\n<th>中文标题</th>\n<th>翻译贡献者</th>\n<th>校对主要贡献者</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>12</td>\n<td>transitions.md</td>\n<td>过渡: 进入, 离开, 和 列表</td>\n<td><a href=\"https://github.com/hilongjw\" target=\"_blank\" rel=\"noopener\">awe</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a> <a href=\"https://github.com/StoneQI\" target=\"_blank\" rel=\"noopener\">StoneQI</a></td>\n</tr>\n<tr>\n<td>13</td>\n<td>transitioning-state.md</td>\n<td>过渡状态</td>\n<td><a href=\"https://github.com/hilongjw\" target=\"_blank\" rel=\"noopener\">awe</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>14</td>\n<td>render-function.md</td>\n<td>Render 函数</td>\n<td><a href=\"https://github.com/hilongjw\" target=\"_blank\" rel=\"noopener\">awe</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>15</td>\n<td>reactivity.md</td>\n<td>深入响应式原理</td>\n<td><a href=\"https://github.com/veaba\" target=\"_blank\" rel=\"noopener\">veaba</a></td>\n<td><a href=\"https://github.com/yangzj1992\" target=\"_blank\" rel=\"noopener\">yangzj1992</a></td>\n</tr>\n<tr>\n<td>16</td>\n<td>custom-directive.md</td>\n<td>自定义指令</td>\n<td><a href=\"https://github.com/hurrytospring\" target=\"_blank\" rel=\"noopener\">hurrytospring</a></td>\n<td><a href=\"https://github.com/yangzj1992\" target=\"_blank\" rel=\"noopener\">yangzj1992</a></td>\n</tr>\n<tr>\n<td>17</td>\n<td>mixins.md</td>\n<td>混合</td>\n<td><a href=\"https://github.com/hurrytospring\" target=\"_blank\" rel=\"noopener\">hurrytospring</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>18</td>\n<td>plugins.md</td>\n<td>插件</td>\n<td><a href=\"https://github.com/hgcoder\" target=\"_blank\" rel=\"noopener\">hgcoder</a></td>\n<td><a href=\"https://github.com/hgcoder\" target=\"_blank\" rel=\"noopener\">hgcoder</a></td>\n</tr>\n<tr>\n<td>19</td>\n<td>single-file-components.md</td>\n<td>单文件组件</td>\n<td><a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a></td>\n<td><a href=\"https://github.com/zhouzihanntu\" target=\"_blank\" rel=\"noopener\">zhouzihanntu</a></td>\n</tr>\n<tr>\n<td>20</td>\n<td>routing.md</td>\n<td>路由</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/mlyknown\" target=\"_blank\" rel=\"noopener\">mlyknown</a></td>\n</tr>\n<tr>\n<td>21</td>\n<td>state-management.md</td>\n<td>状态管理</td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n<td><a href=\"https://github.com/mlyknown\" target=\"_blank\" rel=\"noopener\">mlyknown</a></td>\n</tr>\n<tr>\n<td>22</td>\n<td>unit-testing.md</td>\n<td>单元测试</td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n<td><a href=\"https://github.com/mlyknown\" target=\"_blank\" rel=\"noopener\">mlyknown</a></td>\n</tr>\n<tr>\n<td>23</td>\n<td>ssr.md</td>\n<td>服务端渲染</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/yongbolv\" target=\"_blank\" rel=\"noopener\">yongbolv</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Migration-迁移\"><a href=\"#Migration-迁移\" class=\"headerlink\" title=\"Migration  迁移\"></a>Migration  迁移</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>对应文档文件名</th>\n<th>中文标题</th>\n<th>翻译贡献者</th>\n<th>校对主要贡献者</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>24</td>\n<td>migration.md</td>\n<td>1.x迁移</td>\n<td><a href=\"https://github.com/hurrytospring\" target=\"_blank\" rel=\"noopener\">hurrytospring</a></td>\n<td><a href=\"https://github.com/yongbolv\" target=\"_blank\" rel=\"noopener\">yongbolv</a></td>\n</tr>\n<tr>\n<td>27</td>\n<td>migration-vue-router.md</td>\n<td>vue-router 0.7.x 迁移</td>\n<td><a href=\"https://github.com/forzajuve10\" target=\"_blank\" rel=\"noopener\">forzajuve10</a></td>\n<td><a href=\"https://github.com/yizhixiaolongxia\" target=\"_blank\" rel=\"noopener\">yizhixiaolongxia</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Meta-更多\"><a href=\"#Meta-更多\" class=\"headerlink\" title=\"Meta  更多\"></a>Meta  更多</h3><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>对应文档文件名</th>\n<th>中文标题</th>\n<th>翻译贡献者</th>\n<th>校对主要贡献者</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>25</td>\n<td>comparison.md</td>\n<td>对比其他框架</td>\n<td><a href=\"https://github.com/yongbolv\" target=\"_blank\" rel=\"noopener\">yongbolv</a></td>\n<td><a href=\"https://github.com/yangzj1992\" target=\"_blank\" rel=\"noopener\">yangzj1992</a></td>\n</tr>\n<tr>\n<td>26</td>\n<td>join.md</td>\n<td>加入 Vue.js 社区</td>\n<td><a href=\"https://github.com/daix6\" target=\"_blank\" rel=\"noopener\">daix6</a></td>\n<td><a href=\"https://github.com/zhouzihanntu\" target=\"_blank\" rel=\"noopener\">zhouzihanntu</a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"API翻译贡献\"><a href=\"#API翻译贡献\" class=\"headerlink\" title=\"API翻译贡献\"></a>API翻译贡献</h2><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>对应小节名称</th>\n<th>中文标题</th>\n<th>翻译贡献者</th>\n<th>校对主要贡献者</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Global Config</td>\n<td>全局配置</td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Global API</td>\n<td>全局 API</td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Options / Data</td>\n<td>选项 / 数据</td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>4</td>\n<td>Options / DOM</td>\n<td>选项 / DOM</td>\n<td><a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Options / Lifecycle Hooks</td>\n<td>选项 / 生命周期钩子</td>\n<td><a href=\"https://github.com/ATLgo\" target=\"_blank\" rel=\"noopener\">ATLgo</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Options / Assets</td>\n<td>选项 / 资源</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>7</td>\n<td>Options / Misc</td>\n<td>选项 / 杂项</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Instance Properties</td>\n<td>实例属性</td>\n<td><a href=\"https://github.com/coolzjy\" target=\"_blank\" rel=\"noopener\">coolzjy</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>9</td>\n<td>Instance Methods / Data</td>\n<td>实例方法 / 数据</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>10</td>\n<td>Instance Methods / Events</td>\n<td>实例方法 / 事件</td>\n<td><a href=\"https://github.com/mlyknown\" target=\"_blank\" rel=\"noopener\">mlyknown</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>11</td>\n<td>Instance Methods / Lifecycle</td>\n<td>实例方法 / 生命周期</td>\n<td><a href=\"https://github.com/mlyknown\" target=\"_blank\" rel=\"noopener\">mlyknown</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>12</td>\n<td>Directives</td>\n<td>指令</td>\n<td><a href=\"https://github.com/dingyiming\" target=\"_blank\" rel=\"noopener\">dingyiming</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>13</td>\n<td>Special Attributes</td>\n<td>特殊元素</td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>14</td>\n<td>Built-In Components</td>\n<td>内置的组件</td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n<td><a href=\"https://github.com/bhnddowinf\" target=\"_blank\" rel=\"noopener\">bhnddowinf</a></td>\n</tr>\n<tr>\n<td>15</td>\n<td>VNode Interface</td>\n<td>VNode 接口</td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n</tr>\n<tr>\n<td>16</td>\n<td>Server-Side Rendering</td>\n<td>服务端渲染</td>\n<td><a href=\"https://github.com/70data\" target=\"_blank\" rel=\"noopener\">70data</a></td>\n<td><a href=\"https://github.com/dear-lizhihua\" target=\"_blank\" rel=\"noopener\">dear-lizhihua</a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"示例翻译\"><a href=\"#示例翻译\" class=\"headerlink\" title=\"示例翻译\"></a>示例翻译</h2><p>翻译贡献者 ： <a href=\"https://github.com/lindazhang102\" target=\"_blank\" rel=\"noopener\">lindazhang102</a></p>\n<h2 id=\"感谢所有参与翻译的朋友们！\"><a href=\"#感谢所有参与翻译的朋友们！\" class=\"headerlink\" title=\"感谢所有参与翻译的朋友们！\"></a>感谢所有参与翻译的朋友们！</h2>"},{"_content":"# Code Of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, political party, or sexual identity and orientation. Note, however, that religion, political party, or other ideological affiliation provide no exemptions for the behavior we outline as unacceptable in this Code of Conduct.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n- Using welcoming and inclusive language\n- Being respectful of differing viewpoints and experiences\n- Gracefully accepting constructive criticism\n- Focusing on what is best for the community\n- Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n- The use of sexualized language or imagery and unwelcome sexual attention or advances\n- Trolling, insulting/derogatory comments, and personal or political attacks\n- Public or private harassment\n- Publishing others' private information, such as a physical or electronic address, without explicit permission\n- Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at community@vuejs.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n","source":"coc/index.md","raw":"# Code Of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, political party, or sexual identity and orientation. Note, however, that religion, political party, or other ideological affiliation provide no exemptions for the behavior we outline as unacceptable in this Code of Conduct.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n- Using welcoming and inclusive language\n- Being respectful of differing viewpoints and experiences\n- Gracefully accepting constructive criticism\n- Focusing on what is best for the community\n- Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n- The use of sexualized language or imagery and unwelcome sexual attention or advances\n- Trolling, insulting/derogatory comments, and personal or political attacks\n- Public or private harassment\n- Publishing others' private information, such as a physical or electronic address, without explicit permission\n- Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at community@vuejs.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n","date":"2020-07-16T09:39:50.583Z","updated":"2020-07-14T00:46:47.771Z","path":"coc/index.html","title":"","comments":1,"layout":"page","_id":"ckcwngniq00039lxkiuxq88n4","content":"<h1 id=\"Code-Of-Conduct\"><a href=\"#Code-Of-Conduct\" class=\"headerlink\" title=\"Code Of Conduct\"></a>Code Of Conduct</h1><h2 id=\"Our-Pledge\"><a href=\"#Our-Pledge\" class=\"headerlink\" title=\"Our Pledge\"></a>Our Pledge</h2><p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, political party, or sexual identity and orientation. Note, however, that religion, political party, or other ideological affiliation provide no exemptions for the behavior we outline as unacceptable in this Code of Conduct.</p>\n<h2 id=\"Our-Standards\"><a href=\"#Our-Standards\" class=\"headerlink\" title=\"Our Standards\"></a>Our Standards</h2><p>Examples of behavior that contributes to creating a positive environment include:</p>\n<ul>\n<li>Using welcoming and inclusive language</li>\n<li>Being respectful of differing viewpoints and experiences</li>\n<li>Gracefully accepting constructive criticism</li>\n<li>Focusing on what is best for the community</li>\n<li>Showing empathy towards other community members</li>\n</ul>\n<p>Examples of unacceptable behavior by participants include:</p>\n<ul>\n<li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li>\n<li>Trolling, insulting/derogatory comments, and personal or political attacks</li>\n<li>Public or private harassment</li>\n<li>Publishing others’ private information, such as a physical or electronic address, without explicit permission</li>\n<li>Other conduct which could reasonably be considered inappropriate in a professional setting</li>\n</ul>\n<h2 id=\"Our-Responsibilities\"><a href=\"#Our-Responsibilities\" class=\"headerlink\" title=\"Our Responsibilities\"></a>Our Responsibilities</h2><p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p>\n<p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>\n<h2 id=\"Scope\"><a href=\"#Scope\" class=\"headerlink\" title=\"Scope\"></a>Scope</h2><p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>\n<h2 id=\"Enforcement\"><a href=\"#Enforcement\" class=\"headerlink\" title=\"Enforcement\"></a>Enforcement</h2><p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at <a href=\"mailto:community@vuejs.org\" target=\"_blank\" rel=\"noopener\">community@vuejs.org</a>. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p>\n<p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project’s leadership.</p>\n<h2 id=\"Attribution\"><a href=\"#Attribution\" class=\"headerlink\" title=\"Attribution\"></a>Attribution</h2><p>This Code of Conduct is adapted from the <a href=\"https://www.contributor-covenant.org\" target=\"_blank\" rel=\"noopener\">Contributor Covenant</a>, version 1.4, available at <a href=\"https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\" target=\"_blank\" rel=\"noopener\">https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Code-Of-Conduct\"><a href=\"#Code-Of-Conduct\" class=\"headerlink\" title=\"Code Of Conduct\"></a>Code Of Conduct</h1><h2 id=\"Our-Pledge\"><a href=\"#Our-Pledge\" class=\"headerlink\" title=\"Our Pledge\"></a>Our Pledge</h2><p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, political party, or sexual identity and orientation. Note, however, that religion, political party, or other ideological affiliation provide no exemptions for the behavior we outline as unacceptable in this Code of Conduct.</p>\n<h2 id=\"Our-Standards\"><a href=\"#Our-Standards\" class=\"headerlink\" title=\"Our Standards\"></a>Our Standards</h2><p>Examples of behavior that contributes to creating a positive environment include:</p>\n<ul>\n<li>Using welcoming and inclusive language</li>\n<li>Being respectful of differing viewpoints and experiences</li>\n<li>Gracefully accepting constructive criticism</li>\n<li>Focusing on what is best for the community</li>\n<li>Showing empathy towards other community members</li>\n</ul>\n<p>Examples of unacceptable behavior by participants include:</p>\n<ul>\n<li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li>\n<li>Trolling, insulting/derogatory comments, and personal or political attacks</li>\n<li>Public or private harassment</li>\n<li>Publishing others’ private information, such as a physical or electronic address, without explicit permission</li>\n<li>Other conduct which could reasonably be considered inappropriate in a professional setting</li>\n</ul>\n<h2 id=\"Our-Responsibilities\"><a href=\"#Our-Responsibilities\" class=\"headerlink\" title=\"Our Responsibilities\"></a>Our Responsibilities</h2><p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p>\n<p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>\n<h2 id=\"Scope\"><a href=\"#Scope\" class=\"headerlink\" title=\"Scope\"></a>Scope</h2><p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>\n<h2 id=\"Enforcement\"><a href=\"#Enforcement\" class=\"headerlink\" title=\"Enforcement\"></a>Enforcement</h2><p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at <a href=\"mailto:community@vuejs.org\" target=\"_blank\" rel=\"noopener\">community@vuejs.org</a>. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p>\n<p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project’s leadership.</p>\n<h2 id=\"Attribution\"><a href=\"#Attribution\" class=\"headerlink\" title=\"Attribution\"></a>Attribution</h2><p>This Code of Conduct is adapted from the <a href=\"https://www.contributor-covenant.org\" target=\"_blank\" rel=\"noopener\">Contributor Covenant</a>, version 1.4, available at <a href=\"https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\" target=\"_blank\" rel=\"noopener\">https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</a></p>\n"},{"type":"menu","_content":"","source":"menu/index.md","raw":"---\ntype: menu\n---\n","date":"2020-07-16T09:39:50.577Z","updated":"2020-07-14T00:46:47.804Z","path":"menu/index.html","title":"","comments":1,"layout":"page","_id":"ckcwngnir00049lxkyzavla6m","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Themes","type":"resources","order":804,"_content":"{% raw %}\n<div id=\"themes\">\n  <section v-for=\"partner in partners\" :key=\"partner.name\" class=\"partner-wrapper\">\n    <partner-component :partner=\"partner\"></partner-component>\n  </section>\n\n  <p>\n    Want to feature your themes here?\n    <a href=\"mailto:evan@vuejs.org?subject=Theme+affiliation\">Contact us</a>!\n  </p>\n</div>\n\n<script type=\"text/template\" id=\"partnerTemplate\">\n  <div>\n    <h2 :id=\"partner.name\">{{partner.name}}</h2>\n    <blockquote class=\"theme-partner-description\" v-html=\"partnerDescription\"></blockquote>\n    <div class=\"themes-grid\">\n      <div v-for=\"product in partner.products\" :key=\"product.url\" class=\"item-preview\">\n        <a class=\"item-preview-img\" :href=\"product.url\" rel=\"sponsored\">\n          <img :src=\"product.image\" :alt=\"`${product.name} - ${product.description}`\" loading=\"lazy\">\n        </a>\n        <div class=\"item-preview-name-container\">\n          <h3 class=\"item-preview-name\" :class=\"{'free': product.price === 0}\">\n            {{product.name}}\n          </h3>\n          <b v-if=\"product.price\" class=\"item-preview-price\">${{product.price}}</b>\n        </div>\n        <div class=\"item-preview-description\">{{product.description}}</div>\n      </div>\n      <div class=\"see-more-container\">\n        <a :href=\"partner.seeMoreUrl\" class=\"button white see-more-link\">See More Themes from {{partner.name}}</a>\n      </div>\n    </div>\n  </div>\n</script>\n\n<script>\nvar mdConverter = new showdown.Converter()\n\nVue.component('partner-component', {\n  template: document.getElementById('partnerTemplate').innerHTML,\n  props: {\n    partner: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    partnerDescription: function () {\n      return mdConverter.makeHtml(this.partner.description)\n    }\n  }\n})\n\nconst app = new Vue({\n  el: '#themes',\n  data: function () {\n    return {\n      partners: themeData\n    }\n  }\n})\n</script>\n{% endraw %}\n","source":"resources/themes.md","raw":"---\ntitle: Themes\ntype: resources\norder: 804\n---\n{% raw %}\n<div id=\"themes\">\n  <section v-for=\"partner in partners\" :key=\"partner.name\" class=\"partner-wrapper\">\n    <partner-component :partner=\"partner\"></partner-component>\n  </section>\n\n  <p>\n    Want to feature your themes here?\n    <a href=\"mailto:evan@vuejs.org?subject=Theme+affiliation\">Contact us</a>!\n  </p>\n</div>\n\n<script type=\"text/template\" id=\"partnerTemplate\">\n  <div>\n    <h2 :id=\"partner.name\">{{partner.name}}</h2>\n    <blockquote class=\"theme-partner-description\" v-html=\"partnerDescription\"></blockquote>\n    <div class=\"themes-grid\">\n      <div v-for=\"product in partner.products\" :key=\"product.url\" class=\"item-preview\">\n        <a class=\"item-preview-img\" :href=\"product.url\" rel=\"sponsored\">\n          <img :src=\"product.image\" :alt=\"`${product.name} - ${product.description}`\" loading=\"lazy\">\n        </a>\n        <div class=\"item-preview-name-container\">\n          <h3 class=\"item-preview-name\" :class=\"{'free': product.price === 0}\">\n            {{product.name}}\n          </h3>\n          <b v-if=\"product.price\" class=\"item-preview-price\">${{product.price}}</b>\n        </div>\n        <div class=\"item-preview-description\">{{product.description}}</div>\n      </div>\n      <div class=\"see-more-container\">\n        <a :href=\"partner.seeMoreUrl\" class=\"button white see-more-link\">See More Themes from {{partner.name}}</a>\n      </div>\n    </div>\n  </div>\n</script>\n\n<script>\nvar mdConverter = new showdown.Converter()\n\nVue.component('partner-component', {\n  template: document.getElementById('partnerTemplate').innerHTML,\n  props: {\n    partner: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    partnerDescription: function () {\n      return mdConverter.makeHtml(this.partner.description)\n    }\n  }\n})\n\nconst app = new Vue({\n  el: '#themes',\n  data: function () {\n    return {\n      partners: themeData\n    }\n  }\n})\n</script>\n{% endraw %}\n","date":"2020-07-16T09:39:50.148Z","updated":"2020-07-14T00:46:47.804Z","path":"resources/themes.html","comments":1,"layout":"page","_id":"ckcwngnis00059lxk0tn88jtp","content":"\n<div id=\"themes\">\n  <section v-for=\"partner in partners\" :key=\"partner.name\" class=\"partner-wrapper\">\n    <partner-component :partner=\"partner\"></partner-component>\n  </section>\n\n  <p>\n    Want to feature your themes here?\n    <a href=\"mailto:evan@vuejs.org?subject=Theme+affiliation\" target=\"_blank\" rel=\"noopener\">Contact us</a>!\n  </p>\n</div>\n\n<script type=\"text/template\" id=\"partnerTemplate\">\n  <div>\n    <h2 :id=\"partner.name\">{{partner.name}}</h2>\n    <blockquote class=\"theme-partner-description\" v-html=\"partnerDescription\"></blockquote>\n    <div class=\"themes-grid\">\n      <div v-for=\"product in partner.products\" :key=\"product.url\" class=\"item-preview\">\n        <a class=\"item-preview-img\" :href=\"product.url\" rel=\"sponsored\">\n          <img :src=\"product.image\" :alt=\"`${product.name} - ${product.description}`\" loading=\"lazy\">\n        </a>\n        <div class=\"item-preview-name-container\">\n          <h3 class=\"item-preview-name\" :class=\"{'free': product.price === 0}\">\n            {{product.name}}\n          </h3>\n          <b v-if=\"product.price\" class=\"item-preview-price\">${{product.price}}</b>\n        </div>\n        <div class=\"item-preview-description\">{{product.description}}</div>\n      </div>\n      <div class=\"see-more-container\">\n        <a :href=\"partner.seeMoreUrl\" class=\"button white see-more-link\">See More Themes from {{partner.name}}</a>\n      </div>\n    </div>\n  </div>\n</script>\n\n<script>\nvar mdConverter = new showdown.Converter()\n\nVue.component('partner-component', {\n  template: document.getElementById('partnerTemplate').innerHTML,\n  props: {\n    partner: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    partnerDescription: function () {\n      return mdConverter.makeHtml(this.partner.description)\n    }\n  }\n})\n\nconst app = new Vue({\n  el: '#themes',\n  data: function () {\n    return {\n      partners: themeData\n    }\n  }\n})\n</script>\n\n","site":{"data":{}},"excerpt":"","more":"\n<div id=\"themes\">\n  <section v-for=\"partner in partners\" :key=\"partner.name\" class=\"partner-wrapper\">\n    <partner-component :partner=\"partner\"></partner-component>\n  </section>\n\n  <p>\n    Want to feature your themes here?\n    <a href=\"mailto:evan@vuejs.org?subject=Theme+affiliation\" target=\"_blank\" rel=\"noopener\">Contact us</a>!\n  </p>\n</div>\n\n<script type=\"text/template\" id=\"partnerTemplate\">\n  <div>\n    <h2 :id=\"partner.name\">{{partner.name}}</h2>\n    <blockquote class=\"theme-partner-description\" v-html=\"partnerDescription\"></blockquote>\n    <div class=\"themes-grid\">\n      <div v-for=\"product in partner.products\" :key=\"product.url\" class=\"item-preview\">\n        <a class=\"item-preview-img\" :href=\"product.url\" rel=\"sponsored\">\n          <img :src=\"product.image\" :alt=\"`${product.name} - ${product.description}`\" loading=\"lazy\">\n        </a>\n        <div class=\"item-preview-name-container\">\n          <h3 class=\"item-preview-name\" :class=\"{'free': product.price === 0}\">\n            {{product.name}}\n          </h3>\n          <b v-if=\"product.price\" class=\"item-preview-price\">${{product.price}}</b>\n        </div>\n        <div class=\"item-preview-description\">{{product.description}}</div>\n      </div>\n      <div class=\"see-more-container\">\n        <a :href=\"partner.seeMoreUrl\" class=\"button white see-more-link\">See More Themes from {{partner.name}}</a>\n      </div>\n    </div>\n  </div>\n</script>\n\n<script>\nvar mdConverter = new showdown.Converter()\n\nVue.component('partner-component', {\n  template: document.getElementById('partnerTemplate').innerHTML,\n  props: {\n    partner: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    partnerDescription: function () {\n      return mdConverter.makeHtml(this.partner.description)\n    }\n  }\n})\n\nconst app = new Vue({\n  el: '#themes',\n  data: function () {\n    return {\n      partners: themeData\n    }\n  }\n})\n</script>\n\n"},{"sponsors":true,"type":"sponsors","_content":"","source":"support-mypui/index.md","raw":"---\nsponsors: true\ntype: sponsors\n---\n","date":"2020-07-16T09:39:50.579Z","updated":"2020-07-14T00:46:47.804Z","path":"support-mypui/index.html","title":"","comments":1,"layout":"page","_id":"ckcwngnit00069lxkbm9cvcmf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Performance Comparisons","_content":"\n## TodoMVC Benchmark\n\n> *Last Updated: 2014-10-12*\n\nLooking for the TodoMVC Benchmark? It's been removed because after discussion with some other framework authors we have agreed that:\n\n1. The original intention of these benchmarks were for comparing Browser performance rather than that of frameworks. The \"synchronously trigger an action xxx times\" test routine doesn't reflect meaningful real world user actions.\n\n2. Due to internal implementation differences, frameworks that uses async rendering (e.g. Vue, Om, Mercury) gains the advantage by skipping part of the calculations that happened in the same event loop. The real world user experience doesn't demonstrate such dramatic difference.\n\n3. Overall this benchmark suite gave rise to more controversy than constructive insights, so it's been removed and I'd be happy to replace it with a more meaningful way to measure front-end performance.\n","source":"perf/index.md","raw":"---\ntitle: Performance Comparisons\n---\n\n## TodoMVC Benchmark\n\n> *Last Updated: 2014-10-12*\n\nLooking for the TodoMVC Benchmark? It's been removed because after discussion with some other framework authors we have agreed that:\n\n1. The original intention of these benchmarks were for comparing Browser performance rather than that of frameworks. The \"synchronously trigger an action xxx times\" test routine doesn't reflect meaningful real world user actions.\n\n2. Due to internal implementation differences, frameworks that uses async rendering (e.g. Vue, Om, Mercury) gains the advantage by skipping part of the calculations that happened in the same event loop. The real world user experience doesn't demonstrate such dramatic difference.\n\n3. Overall this benchmark suite gave rise to more controversy than constructive insights, so it's been removed and I'd be happy to replace it with a more meaningful way to measure front-end performance.\n","date":"2020-07-16T09:39:50.580Z","updated":"2020-07-14T00:46:47.804Z","path":"perf/index.html","comments":1,"layout":"page","_id":"ckcwngniu00079lxk7ibpt10z","content":"<h2 id=\"TodoMVC-Benchmark\"><a href=\"#TodoMVC-Benchmark\" class=\"headerlink\" title=\"TodoMVC Benchmark\"></a>TodoMVC Benchmark</h2><blockquote>\n<p><em>Last Updated: 2014-10-12</em></p>\n</blockquote>\n<p>Looking for the TodoMVC Benchmark? It’s been removed because after discussion with some other framework authors we have agreed that:</p>\n<ol>\n<li><p>The original intention of these benchmarks were for comparing Browser performance rather than that of frameworks. The “synchronously trigger an action xxx times” test routine doesn’t reflect meaningful real world user actions.</p>\n</li>\n<li><p>Due to internal implementation differences, frameworks that uses async rendering (e.g. Vue, Om, Mercury) gains the advantage by skipping part of the calculations that happened in the same event loop. The real world user experience doesn’t demonstrate such dramatic difference.</p>\n</li>\n<li><p>Overall this benchmark suite gave rise to more controversy than constructive insights, so it’s been removed and I’d be happy to replace it with a more meaningful way to measure front-end performance.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"TodoMVC-Benchmark\"><a href=\"#TodoMVC-Benchmark\" class=\"headerlink\" title=\"TodoMVC Benchmark\"></a>TodoMVC Benchmark</h2><blockquote>\n<p><em>Last Updated: 2014-10-12</em></p>\n</blockquote>\n<p>Looking for the TodoMVC Benchmark? It’s been removed because after discussion with some other framework authors we have agreed that:</p>\n<ol>\n<li><p>The original intention of these benchmarks were for comparing Browser performance rather than that of frameworks. The “synchronously trigger an action xxx times” test routine doesn’t reflect meaningful real world user actions.</p>\n</li>\n<li><p>Due to internal implementation differences, frameworks that uses async rendering (e.g. Vue, Om, Mercury) gains the advantage by skipping part of the calculations that happened in the same event loop. The real world user experience doesn’t demonstrate such dramatic difference.</p>\n</li>\n<li><p>Overall this benchmark suite gave rise to more controversy than constructive insights, so it’s been removed and I’d be happy to replace it with a more meaningful way to measure front-end performance.</p>\n</li>\n</ol>\n"},{"type":"partners","partners":true,"title":"Vue Partners","proficiencies_urls":{"VueJs":"https://vuejs.org","Laravel":"https://laravel.com","Node":"https://nodejs.org"},"partners_list":[{"name":"Vehikl","logo":"vehikl.png","description":"Vehikl is a software consultancy specialising in PHP and JavaScript. We build best-in-class web applications written with popular frameworks such as Laravel, Express, NestJS, Vue, and React. Think of us as an extension of your team.","proficiencies":["VueJs","Laravel","Node","Team Augmentation"],"location":"Ontario, Canada","languages":["English"],"url_text":"www.vehikl.com","url_link":"www.vehikl.com?utm_source=vue_partners_page","hire_url":"www.vehikl.com/contact/?utm_source=vue_partners_page","email":"go+partner@vehikl.com","social_links":[{"name":"Github","class":"github","url":"https://github.com/vehikl"},{"name":"Twitter","class":"twitter","url":"https://twitter.com/vehikl"},{"name":"Instagram","class":"instagram","url":"https://www.instagram.com/vehiklteam/"}]},{"name":"Modus Create","logo":"https://res.cloudinary.com/modus-labs/image/upload/v1533109874/modus/logo-vertical-black.svg","description":"Modus Create is a disruptive consulting firm that helps companies transform for success in the digital future.\nClients work with Modus to effect transformational change through a unique collaborative engagement model that focuses on strategy, product design/build, user experience, company culture, and process change to accelerate their response to digital disruption.\nModus is uniquely expert at executing within the new reality of global talent sourcing and globally distributed teams. Modus culture is based on recruiting only top talent regardless of their location. Modus delivers time zone-aligned, highly productive, English-speaking teams, accessibility, and a totally collaborative environment regardless of individual location. ","proficiencies":[{"name":"Vue.js","url":"https://moduscreate.com/partners/vue/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"AWS","url":"https://moduscreate.com/partners/aws/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Atlassian","url":"https://moduscreate.com/partners/atlassian/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Ionic","url":"https://moduscreate.com/partners/ionic/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Product Management","url":"https://moduscreate.com/what-we-do/product-management/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Customer Experience","url":"https://moduscreate.com/what-we-do/customer-experience/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Agile Transformation","url":"https://moduscreate.com/what-we-do/agile-transformation/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Cloud Migration","url":"https://moduscreate.com/what-we-do/cloud-migration/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"}],"location":"Reston, VA, USA / Los Angeles, CA, USA / Cluj, Romania / San José, Costa Rica","languages":["English","Global"],"url_text":"moduscreate.com","url_link":"moduscreate.com/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage","hire_url":"moduscreate.com/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage","email":"contact@moduscreate.com","social_links":[{"name":"Github","class":"github","url":"https://github.com/ModusCreateOrg"},{"name":"Twitter","class":"twitter","url":"https://twitter.com/ModusCreate"},{"name":"LinkedIn","class":"linkedin","url":"https://www.linkedin.com/company/modus-create-inc"},{"name":"YouTube","class":"youtube","url":"https://www.youtube.com/moduscreate"}]},{"name":"Monterail","logo":"Monterail.png","description":"Monterail is a full-service software development company with 110+ experts on board delivering meaningful software for start-ups, SMBs and enterprises. We are organizers of the first official Vue-related conference in the world and authors of the State of Vue.js report (2017&2019). Our experts delivered 30 Vue.js-based projects so far.","proficiencies":[{"name":"VueJs","url":"https://hi.monterail.co/2NqPUa6"},{"name":"Ruby on Rails","url":"https://hi.monterail.co/31RvfBm"},{"name":"Javascript","url":"https://hi.monterail.co/34cWQhR"},{"name":"Python","url":"https://hi.monterail.co/2MXHLeb"},{"name":"Services","url":"https://www.monterail.com/services?utm_medium=referral&utm_source=partner-list&utm_campaign=vue.js"},{"name":"Projects","url":"https://www.monterail.com/projects?utm_medium=referral&utm_source=partner-list&utm_campaign=vue.js"}],"location":"Wrocław, Poland","languages":["English","Polish"],"url_text":"www.monterail.com","url_link":"www.monterail.com/services/vue-development?utm_campaign=Vue.js&utm_source=partner-list","hire_url":"www.monterail.com/contact","email":"hello@monterail.com","social_links":[{"name":"Github","class":"github","url":"https://github.com/monterail"},{"name":"Linkedin","class":"linkedin","url":"https://www.linkedin.com/company/monterail"},{"name":"Facebook","class":"facebook","url":"https://www.facebook.com/monterail/"},{"name":"Twitter","class":"twitter","url":"https://twitter.com/monterail"},{"name":"Instagram","class":"instagram","url":"https://www.instagram.com/monterail/"}]},{"name":"Rangle","logo":"https://res.cloudinary.com/rangle/image/upload/q_auto,f_auto/vuejs.org/rangle_black_lockup_n6q48z.png","description":"Rangle is a global digital consultancy that helps ambitious organizations outperform the competition in the most demanding markets. We work closely with our clients as one team to imagine, design, and deliver human-centered digital experiences that create lasting results and real business value. Anchored in innovation and lean startup best-practices, our unique delivery and partnership model is purposed-built to this task.","proficiencies":[{"name":"Building Products","url":"https://rangle.io/#build-a-product/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners"},{"name":"Improving Experiences","url":"https://rangle.io/#improve-an-experience/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners"},{"name":"Training & Coaching","url":"https://rangle.io/#level-up-your-team/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners"},{"name":"Agile Transformation","url":"https://rangle.io/#adopt-agile-delivery/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners"},{"name":"Business Transformation","url":"https://rangle.io/#transform-your-business/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners"}],"location":"Toronto, ON, CA　Atlanta, GA, USA　Amsterdam, Netherlands　Tokyo, Japan","languages":["English","French","Dutch"],"url_text":"rangle.io","url_link":"rangle.io/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners","hire_url":"rangle.io/contact-us/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners","email":"info@rangle.io","social_links":[{"name":"GitHub","class":"github","url":"https://github.com/rangle"},{"name":"LinkedIn","class":"linkedin","url":"https://www.linkedin.com/company/rangle/"},{"name":"Twitter","class":"twitter","url":"https://twitter.com/rangleio"},{"name":"Instagram","class":"instagram","url":"https://www.instagram.com/rangleio/?hl=en"}]}],"_content":"","source":"resources/partners.md","raw":"---\ntype: partners\npartners: true\ntitle: Vue Partners\nproficiencies_urls:\n  VueJs: https://vuejs.org\n  Laravel: https://laravel.com\n  Node: https://nodejs.org\npartners_list:\n    -\n        name: Vehikl\n        logo: vehikl.png\n        description:\n            Vehikl is a software consultancy specialising in PHP and JavaScript. We build best-in-class web applications written with popular frameworks such as Laravel, Express, NestJS, Vue, and React. Think of us as an extension of your team.\n        proficiencies:\n            - VueJs\n            - Laravel\n            - Node\n            - Team Augmentation\n        location: Ontario, Canada\n        languages:\n            - English\n        url_text: www.vehikl.com\n        url_link: www.vehikl.com?utm_source=vue_partners_page\n        hire_url: www.vehikl.com/contact/?utm_source=vue_partners_page\n        email: go+partner@vehikl.com\n        social_links:\n            -\n                name: Github\n                class: github\n                url: 'https://github.com/vehikl'\n            -\n                name: Twitter\n                class: twitter\n                url: 'https://twitter.com/vehikl'\n            -\n                name: Instagram\n                class: instagram\n                url: 'https://www.instagram.com/vehiklteam/'\n\n    -\n        name: Modus Create\n        logo: https://res.cloudinary.com/modus-labs/image/upload/v1533109874/modus/logo-vertical-black.svg\n        description:\n            \"Modus Create is a disruptive consulting firm that helps companies transform for success in the digital future.\n\n            Clients work with Modus to effect transformational change through a unique collaborative engagement model that focuses on strategy, product design/build, user experience, company culture, and process change to accelerate their response to digital disruption.\n\n            Modus is uniquely expert at executing within the new reality of global talent sourcing and globally distributed teams. Modus culture is based on recruiting only top talent regardless of their location. Modus delivers time zone-aligned, highly productive, English-speaking teams, accessibility, and a totally collaborative environment regardless of individual location.\n\"\n        proficiencies:\n            - name: Vue.js\n              url: https://moduscreate.com/partners/vue/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: AWS\n              url: https://moduscreate.com/partners/aws/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Atlassian\n              url: https://moduscreate.com/partners/atlassian/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Ionic\n              url: https://moduscreate.com/partners/ionic/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Product Management\n              url: https://moduscreate.com/what-we-do/product-management/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Customer Experience\n              url: https://moduscreate.com/what-we-do/customer-experience/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Agile Transformation\n              url: https://moduscreate.com/what-we-do/agile-transformation/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Cloud Migration\n              url: https://moduscreate.com/what-we-do/cloud-migration/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n        location: Reston, VA, USA / Los Angeles, CA, USA / Cluj, Romania / San José, Costa Rica\n        languages:\n            - English\n            - Global\n        url_text: moduscreate.com\n        url_link: moduscreate.com/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n        hire_url: moduscreate.com/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n        email: contact@moduscreate.com\n        social_links:\n            -\n                name: Github\n                class: github\n                url: 'https://github.com/ModusCreateOrg'\n            -\n                name: Twitter\n                class: twitter\n                url: 'https://twitter.com/ModusCreate'\n            -\n                name: LinkedIn\n                class: linkedin\n                url: 'https://www.linkedin.com/company/modus-create-inc'\n            -\n                name: YouTube\n                class: youtube\n                url: 'https://www.youtube.com/moduscreate'\n    -\n        name: Monterail\n        logo: Monterail.png\n        description:\n            \"Monterail is a full-service software development company with 110+ experts on board delivering meaningful software for start-ups, SMBs and enterprises. We are organizers of the first official Vue-related conference in the world and authors of the State of Vue.js report (2017&2019). Our experts delivered 30 Vue.js-based projects so far.\"\n        proficiencies:\n            - name: VueJs\n              url: https://hi.monterail.co/2NqPUa6\n            - name: Ruby on Rails\n              url: https://hi.monterail.co/31RvfBm\n            - name: Javascript\n              url: https://hi.monterail.co/34cWQhR\n            - name: Python\n              url: https://hi.monterail.co/2MXHLeb\n            - name: Services\n              url:  https://www.monterail.com/services?utm_medium=referral&utm_source=partner-list&utm_campaign=vue.js\n            - name: Projects\n              url:  https://www.monterail.com/projects?utm_medium=referral&utm_source=partner-list&utm_campaign=vue.js\n        location: Wrocław, Poland\n        languages:\n            - English\n            - Polish\n        url_text: www.monterail.com\n        url_link: www.monterail.com/services/vue-development?utm_campaign=Vue.js&utm_source=partner-list\n        hire_url: www.monterail.com/contact\n        email: hello@monterail.com\n        social_links:\n            -\n                name: Github\n                class: github\n                url: 'https://github.com/monterail'\n            -\n                name: Linkedin\n                class: linkedin\n                url: 'https://www.linkedin.com/company/monterail'\n            -\n                name: Facebook\n                class: facebook\n                url: 'https://www.facebook.com/monterail/'\n            -\n                name: Twitter\n                class: twitter\n                url: 'https://twitter.com/monterail'\n            -\n                name: Instagram\n                class: instagram\n                url: 'https://www.instagram.com/monterail/'\n    -\n        name: Rangle\n        logo: https://res.cloudinary.com/rangle/image/upload/q_auto,f_auto/vuejs.org/rangle_black_lockup_n6q48z.png\n        description:\n            \"Rangle is a global digital consultancy that helps ambitious organizations outperform the competition in the most demanding markets. We work closely with our clients as one team to imagine, design, and deliver human-centered digital experiences that create lasting results and real business value. Anchored in innovation and lean startup best-practices, our unique delivery and partnership model is purposed-built to this task.\"\n        proficiencies:\n            - name: Building Products\n              url: https://rangle.io/#build-a-product/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n            - name: Improving Experiences\n              url: https://rangle.io/#improve-an-experience/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n            - name: Training & Coaching\n              url: https://rangle.io/#level-up-your-team/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n            - name: Agile Transformation\n              url: https://rangle.io/#adopt-agile-delivery/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n            - name: Business Transformation\n              url: https://rangle.io/#transform-your-business/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n        location: Toronto, ON, CA　Atlanta, GA, USA　Amsterdam, Netherlands　Tokyo, Japan\n        languages:\n            - English\n            - French\n            - Dutch\n        url_text: rangle.io\n        url_link: rangle.io/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n        hire_url: rangle.io/contact-us/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n        email: info@rangle.io\n        social_links:\n            -\n                name: GitHub\n                class: github\n                url: 'https://github.com/rangle'\n            -\n                name: LinkedIn\n                class: linkedin\n                url: 'https://www.linkedin.com/company/rangle/'\n            -\n                name: Twitter\n                class: twitter\n                url: 'https://twitter.com/rangleio'\n            -\n                name: Instagram\n                class: instagram\n                url: 'https://www.instagram.com/rangleio/?hl=en'\n---\n","date":"2020-07-16T09:39:50.150Z","updated":"2020-07-14T00:46:47.804Z","path":"resources/partners.html","comments":1,"layout":"page","_id":"ckcwngnjc00089lxkyuglasi8","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"`bubble`为`true`，只是非自定义组件下的`bubble`有效，里面包含了自定义组件的话，事件在自定义组件上，依然会被该自定义的组件拦截。\n\nAndroid端app必须设置`bubble`才能在该元素以及他包含的元素里面进行事件响应，否则会被最上层的组件拦截，默认是无法穿透的。\n\n不过iOS和mp/h5默认是穿透的。\n\n如果需要拦截，可以使用 `@tap.stop.prevent=\"xxx\"` 形式。\n\n```js\nxxx(e) {\n\te.stopPropagation && e.stopPropagation()\n}\n```\n","source":"doc/cookbook/bubble.md","raw":"`bubble`为`true`，只是非自定义组件下的`bubble`有效，里面包含了自定义组件的话，事件在自定义组件上，依然会被该自定义的组件拦截。\n\nAndroid端app必须设置`bubble`才能在该元素以及他包含的元素里面进行事件响应，否则会被最上层的组件拦截，默认是无法穿透的。\n\n不过iOS和mp/h5默认是穿透的。\n\n如果需要拦截，可以使用 `@tap.stop.prevent=\"xxx\"` 形式。\n\n```js\nxxx(e) {\n\te.stopPropagation && e.stopPropagation()\n}\n```\n","date":"2020-07-17T06:19:19.219Z","updated":"2020-07-17T06:19:19.219Z","path":"doc/cookbook/bubble.html","title":"","comments":1,"layout":"page","_id":"ckcwngnje00099lxkl4f89g7e","content":"<p><code>bubble</code>为<code>true</code>，只是非自定义组件下的<code>bubble</code>有效，里面包含了自定义组件的话，事件在自定义组件上，依然会被该自定义的组件拦截。</p>\n<p>Android端app必须设置<code>bubble</code>才能在该元素以及他包含的元素里面进行事件响应，否则会被最上层的组件拦截，默认是无法穿透的。</p>\n<p>不过iOS和mp/h5默认是穿透的。</p>\n<p>如果需要拦截，可以使用 <a href=\"mailto:`@tap.stop.prevent\" target=\"_blank\" rel=\"noopener\">`@tap.stop.prevent</a>=”xxx”` 形式。</p>\n<pre><code class=\"hljs js\">xxx(e) &#123;\n\te.stopPropagation &amp;&amp; e.stopPropagation()\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><code>bubble</code>为<code>true</code>，只是非自定义组件下的<code>bubble</code>有效，里面包含了自定义组件的话，事件在自定义组件上，依然会被该自定义的组件拦截。</p>\n<p>Android端app必须设置<code>bubble</code>才能在该元素以及他包含的元素里面进行事件响应，否则会被最上层的组件拦截，默认是无法穿透的。</p>\n<p>不过iOS和mp/h5默认是穿透的。</p>\n<p>如果需要拦截，可以使用 <a href=\"mailto:`@tap.stop.prevent\" target=\"_blank\" rel=\"noopener\">`@tap.stop.prevent</a>=”xxx”` 形式。</p>\n<pre><code class=\"hljs js\">xxx(e) &#123;\n\te.stopPropagation &amp;&amp; e.stopPropagation()\n&#125;</code></pre>\n"},{"title":"css注意与问题","type":"cookbook","order":6,"_content":"\n`text-overflow`实际上是作用在`text`标签的，我们需要为`text`标签设置宽度，以及把该属性设置在`text`标签上面，而不是在他的父组件上面.\n\n单行省略：\n\n```css\n.ellipsis {\n\twidth: 100rpx;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\twhite-space: nowrap; /* no-app-nvue */\n\tlines: 1; /* app-nvue */\n}\n```\n\n多行省略：\n\napp-nvue\n\n```css\n.ellipsis {\n\twidth: 100rpx;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tlines: 2; /* app-nvue */\n}\n```\n\nno-app-nvue\n\n```css\n.ellipsis {\n\twidth: 100rpx;\n\tdisplay: -webkit-box;\n\t-webkit-box-orient: vertical;\n\t-webkit-line-clamp: 2;\n\toverflow: hidden;\n}\n```\n","source":"doc/cookbook/css.md","raw":"---\ntitle: css注意与问题\ntype: cookbook\norder: 6\n---\n\n`text-overflow`实际上是作用在`text`标签的，我们需要为`text`标签设置宽度，以及把该属性设置在`text`标签上面，而不是在他的父组件上面.\n\n单行省略：\n\n```css\n.ellipsis {\n\twidth: 100rpx;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\twhite-space: nowrap; /* no-app-nvue */\n\tlines: 1; /* app-nvue */\n}\n```\n\n多行省略：\n\napp-nvue\n\n```css\n.ellipsis {\n\twidth: 100rpx;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tlines: 2; /* app-nvue */\n}\n```\n\nno-app-nvue\n\n```css\n.ellipsis {\n\twidth: 100rpx;\n\tdisplay: -webkit-box;\n\t-webkit-box-orient: vertical;\n\t-webkit-line-clamp: 2;\n\toverflow: hidden;\n}\n```\n","date":"2020-07-17T06:24:55.408Z","updated":"2020-07-17T06:24:55.408Z","path":"doc/cookbook/css.html","comments":1,"layout":"page","_id":"ckcwngnjf000a9lxkz1qitec4","content":"<p><code>text-overflow</code>实际上是作用在<code>text</code>标签的，我们需要为<code>text</code>标签设置宽度，以及把该属性设置在<code>text</code>标签上面，而不是在他的父组件上面.</p>\n<p>单行省略：</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.ellipsis</span> &#123;\n\t<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100</span>rpx;\n\t<span class=\"hljs-attribute\">overflow</span>: hidden;\n\t<span class=\"hljs-attribute\">text-overflow</span>: ellipsis;\n\t<span class=\"hljs-attribute\">white-space</span>: nowrap; <span class=\"hljs-comment\">/* no-app-nvue */</span>\n\t<span class=\"hljs-attribute\">lines</span>: <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">/* app-nvue */</span>\n&#125;</code></pre>\n<p>多行省略：</p>\n<p>app-nvue</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.ellipsis</span> &#123;\n\t<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100</span>rpx;\n\t<span class=\"hljs-attribute\">overflow</span>: hidden;\n\t<span class=\"hljs-attribute\">text-overflow</span>: ellipsis;\n\t<span class=\"hljs-attribute\">lines</span>: <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">/* app-nvue */</span>\n&#125;</code></pre>\n<p>no-app-nvue</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.ellipsis</span> &#123;\n\t<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100</span>rpx;\n\t<span class=\"hljs-attribute\">display</span>: -webkit-box;\n\t<span class=\"hljs-attribute\">-webkit-box-orient</span>: vertical;\n\t<span class=\"hljs-attribute\">-webkit-line-clamp</span>: <span class=\"hljs-number\">2</span>;\n\t<span class=\"hljs-attribute\">overflow</span>: hidden;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><code>text-overflow</code>实际上是作用在<code>text</code>标签的，我们需要为<code>text</code>标签设置宽度，以及把该属性设置在<code>text</code>标签上面，而不是在他的父组件上面.</p>\n<p>单行省略：</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.ellipsis</span> &#123;\n\t<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100</span>rpx;\n\t<span class=\"hljs-attribute\">overflow</span>: hidden;\n\t<span class=\"hljs-attribute\">text-overflow</span>: ellipsis;\n\t<span class=\"hljs-attribute\">white-space</span>: nowrap; <span class=\"hljs-comment\">/* no-app-nvue */</span>\n\t<span class=\"hljs-attribute\">lines</span>: <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">/* app-nvue */</span>\n&#125;</code></pre>\n<p>多行省略：</p>\n<p>app-nvue</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.ellipsis</span> &#123;\n\t<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100</span>rpx;\n\t<span class=\"hljs-attribute\">overflow</span>: hidden;\n\t<span class=\"hljs-attribute\">text-overflow</span>: ellipsis;\n\t<span class=\"hljs-attribute\">lines</span>: <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">/* app-nvue */</span>\n&#125;</code></pre>\n<p>no-app-nvue</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.ellipsis</span> &#123;\n\t<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100</span>rpx;\n\t<span class=\"hljs-attribute\">display</span>: -webkit-box;\n\t<span class=\"hljs-attribute\">-webkit-box-orient</span>: vertical;\n\t<span class=\"hljs-attribute\">-webkit-line-clamp</span>: <span class=\"hljs-number\">2</span>;\n\t<span class=\"hljs-attribute\">overflow</span>: hidden;\n&#125;</code></pre>\n"},{"title":"自定义icon","type":"cookbook","order":7,"_content":"\n# 总结\n- 设置一个独特的 fontFamily；\n- 更改icons数据之后，如果icons出不来，删除基座重新编译；\n- 直接写到页面用`&#xe6b1;`，使用变量的时候用`\\ue6b1`；\n\n比如：`'link': \"&#xe6b1;\"` 要变成 `'link': \"\\ue6b1\"`\n\n直接写到页面用`&#xe6b1;`，使用变量的时候用`\\ue6b1`\n\n# 注意\n如果icons的 base64 数据 有变化，或者更换了fontFamily的名字，需要 删除 基座，重新编译 才能有效。\n","source":"doc/cookbook/icon.md","raw":"---\ntitle: 自定义icon\ntype: cookbook\norder: 7\n---\n\n# 总结\n- 设置一个独特的 fontFamily；\n- 更改icons数据之后，如果icons出不来，删除基座重新编译；\n- 直接写到页面用`&#xe6b1;`，使用变量的时候用`\\ue6b1`；\n\n比如：`'link': \"&#xe6b1;\"` 要变成 `'link': \"\\ue6b1\"`\n\n直接写到页面用`&#xe6b1;`，使用变量的时候用`\\ue6b1`\n\n# 注意\n如果icons的 base64 数据 有变化，或者更换了fontFamily的名字，需要 删除 基座，重新编译 才能有效。\n","date":"2020-07-17T06:25:25.313Z","updated":"2020-07-17T06:25:25.313Z","path":"doc/cookbook/icon.html","comments":1,"layout":"page","_id":"ckcwngnjf000b9lxk93m01zsa","content":"<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>设置一个独特的 fontFamily；</li>\n<li>更改icons数据之后，如果icons出不来，删除基座重新编译；</li>\n<li>直接写到页面用<code>&amp;#xe6b1;</code>，使用变量的时候用<code>\\ue6b1</code>；</li>\n</ul>\n<p>比如：<code>&#39;link&#39;: &quot;&amp;#xe6b1;&quot;</code> 要变成 <code>&#39;link&#39;: &quot;\\ue6b1&quot;</code></p>\n<p>直接写到页面用<code>&amp;#xe6b1;</code>，使用变量的时候用<code>\\ue6b1</code></p>\n<h1 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h1><p>如果icons的 base64 数据 有变化，或者更换了fontFamily的名字，需要 删除 基座，重新编译 才能有效。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>设置一个独特的 fontFamily；</li>\n<li>更改icons数据之后，如果icons出不来，删除基座重新编译；</li>\n<li>直接写到页面用<code>&amp;#xe6b1;</code>，使用变量的时候用<code>\\ue6b1</code>；</li>\n</ul>\n<p>比如：<code>&#39;link&#39;: &quot;&amp;#xe6b1;&quot;</code> 要变成 <code>&#39;link&#39;: &quot;\\ue6b1&quot;</code></p>\n<p>直接写到页面用<code>&amp;#xe6b1;</code>，使用变量的时候用<code>\\ue6b1</code></p>\n<h1 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h1><p>如果icons的 base64 数据 有变化，或者更换了fontFamily的名字，需要 删除 基座，重新编译 才能有效。</p>\n"},{"_content":"有时候我们的一些布局，需要用到 `margin-top: -10px;` margin为负数的情况。\n\n不过在nvue页面中，margin为负数可能导致内容被上面的内容遮挡住。\n","source":"doc/cookbook/nvue安卓margin负数问题.md","raw":"有时候我们的一些布局，需要用到 `margin-top: -10px;` margin为负数的情况。\n\n不过在nvue页面中，margin为负数可能导致内容被上面的内容遮挡住。\n","date":"2020-07-17T06:19:19.268Z","updated":"2020-07-17T06:19:19.268Z","path":"doc/cookbook/nvue安卓margin负数问题.html","title":"","comments":1,"layout":"page","_id":"ckcwngnjg000c9lxk6ef9r4bw","content":"<p>有时候我们的一些布局，需要用到 <code>margin-top: -10px;</code> margin为负数的情况。</p>\n<p>不过在nvue页面中，margin为负数可能导致内容被上面的内容遮挡住。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>有时候我们的一些布局，需要用到 <code>margin-top: -10px;</code> margin为负数的情况。</p>\n<p>不过在nvue页面中，margin为负数可能导致内容被上面的内容遮挡住。</p>\n"},{"title":"介绍","type":"cookbook","order":0,"_content":"\n## Cookbook vs 指南\n\n这份 cookbook 和指南的不同之处在哪里？存在的意义是什么？\n\n* **更专注**：在指南里，我们实际上是在讲一个故事。每个章节都以之前章节的知识进行构建和假设。而在 cookbook 里，每个案例都有各自的代表性。也就是说每个案例都专注于 Vue 的某个特定方面，而不是一个概览。\n\n* **更有深度**：为了避免指南写得太长，我们试着只包含了尽可能简单的示例来帮助你理解每个功能，然后就奔下一个话题了。在 cookbook 里，我们以更生动的形式包含了更复杂的示例并结合特性。每个案例都可以尽可能的翔实，以彻底探索这个领域。\n\n* **传授 JavaScript**：在指南里，我们假设你至少具有 ES5 JavaScript 的中级水平。例如，我们不会解释 `Array.prototype.filter` 在计算属性中是如何过滤一个列表的。然而在 cookbook 里，我们将对一些必要的 JavaScript 特性 (包括 ES6/2015+) 进行探索和解释，以帮助我们构建更好的 Vue 应用。\n\n* **探索生态系统**：对于高级特性，我们会假设你已经对生态系统有一定了解。例如，如果你想在 webpack 中使用单文件组件，我们不会解释如何在 webpack 中配置 Vue 以外的部分。在 cookbook 里，我们有空间去更深度探索这些生态系统中的库——至少能到对 Vue 开发者普遍使用的程度。\n\n<p class=\"tip\">除了这些不同，请注意这份 cookbook 仍*不是*入门教程。其大部分内容都假设你已经理解 HTML、CSS、JavaScript、npm/yarn 等基本概念。</p>\n\n## 参与 Cookbook 贡献\n\n### 我们的目标\n\nCookbook 为开发者提供了一些示例，涵盖常见的或有趣的用例，并逐步解释更复杂的细节。我们的目标是超越一个简单的示例介绍，展现更广泛适用的概念及其注意事项。\n\n如果你有兴趣参与贡献，请将您的想法填入 issue 并加上 **cookbook idea** 的标签作为起步，这样我们就可以帮助并引导您完成一个 pull request。在你的想法被认同之后，请尽可能遵循以下模板。有些小节是必须的，有些是可选的。我们强烈建议您遵循其顺序，但这也不是必须的。通常情况下案例应该：\n\n> * 解决一个具体的普遍性问题\n> * 从尽可能简单的示例开始\n> * 一次只介绍一个复杂的点\n> * 链接到其它文档，而不是在这里重新解释概念\n> * 把问题描述清楚，而不是假设大家对这个问题很熟悉\n> * 解释过程，而不是只告诉你最终结果\n> * 解释策略的利弊，包括它不适用于什么场景\n> * 会提及相关的替代方案，但会放到一个单独的案例中细讲\n\n我们需要您遵照下面的模板。当然我们也理解有的时候为了使内容更清晰或顺畅你是有必要做一些调整的。另外不论怎样，所有的案例都应该从某些点上讨论选择使用这个模式的细微差别，且我们倾向于它们以替代方案章节的形式出现。\n\n### 基本的示例\n\n*必须的*\n\n1. 用一两句话来说明问题。\n2. 用一两句话解释最简单的可能的解决方案。\n3. 显示一小段代码示例。\n4. 用一句话解释它完成了什么。\n\n### 关于其价值的细节\n\n*必须的*\n\n1. 解决人们在看例子时可能遇到的常见问题。(最好以块引用格式呈现)\n2. 显示常见错误的例子，以及如何避免它们。\n3. 用非常简单的代码示例展示好模式和坏模式。\n4. 讨论这个模式令人信服的理由。参考链接不是必需的，但鼓励提供。\n\n### 实际的例子\n\n*必须的*\n\n通过以下方式演示能够为常见或有趣的用例提供支持的代码：\n\n1. 通过几个简单的设置例子，或者\n2. 嵌入一个 CodePen / JSFiddle 的例子\n\n如果你选择稍后再提供，那么你仍应该表述它是什么和做什么。\n\n### 额外的上下文\n\n*可选的*\n\n为这个模式写点东西，描述在这个模式下，它会应用到什么地方，为什么它能正常工作；以及在此基础上运行一些代码、提供一些延伸阅读材料，都是非常有帮助的。\n\n### 何时避免这个模式\n\n*可选的*\n\n本节不是必需的，但强烈建议。你没有必要写一些特别简单易懂的事项，比如根据状态的改变开关 class，但是对于 mixin 这样的更高阶的模式来说是非常重要的。大多数高阶的问题的答案都是[“要看情况！”](https://codepen.io/rachsmith/pen/YweZbG)，该部分就包含了这一点。在此，我们要诚实地看待模式何时有用，何时应该避免，什么时候更有意义。\n\n### 替代方案\n\n*可选的，除非这部分内容在之前已经提供过了*\n\n如果你已经在上一节提供了避免使用的条件，那么这一节是必须的。探索其它方法非常重要，这样人们在遇到某些反模式的情形时不至于无所适从。这样做是因为考虑到 web 是一个不同人有着不同代码结构解决不同问题的大舞台。这个应用是大是小？它们要把 Vue 集成到一个现成的项目中还是从零起步构建新项目？它们的用户只是想达成一个目标还是多个？有很多异步数据吗？所有的这些担忧都会影响实现替代品。一篇好的 cookbook 会为开发者提供这些相关信息。\n\n## 致谢\n\n文档贡献是需要很多时间的，如果您花时间提交这部分的文档，我们将感激不尽。\n","source":"doc/cookbook/index.md","raw":"---\ntitle: 介绍\ntype: cookbook\norder: 0\n---\n\n## Cookbook vs 指南\n\n这份 cookbook 和指南的不同之处在哪里？存在的意义是什么？\n\n* **更专注**：在指南里，我们实际上是在讲一个故事。每个章节都以之前章节的知识进行构建和假设。而在 cookbook 里，每个案例都有各自的代表性。也就是说每个案例都专注于 Vue 的某个特定方面，而不是一个概览。\n\n* **更有深度**：为了避免指南写得太长，我们试着只包含了尽可能简单的示例来帮助你理解每个功能，然后就奔下一个话题了。在 cookbook 里，我们以更生动的形式包含了更复杂的示例并结合特性。每个案例都可以尽可能的翔实，以彻底探索这个领域。\n\n* **传授 JavaScript**：在指南里，我们假设你至少具有 ES5 JavaScript 的中级水平。例如，我们不会解释 `Array.prototype.filter` 在计算属性中是如何过滤一个列表的。然而在 cookbook 里，我们将对一些必要的 JavaScript 特性 (包括 ES6/2015+) 进行探索和解释，以帮助我们构建更好的 Vue 应用。\n\n* **探索生态系统**：对于高级特性，我们会假设你已经对生态系统有一定了解。例如，如果你想在 webpack 中使用单文件组件，我们不会解释如何在 webpack 中配置 Vue 以外的部分。在 cookbook 里，我们有空间去更深度探索这些生态系统中的库——至少能到对 Vue 开发者普遍使用的程度。\n\n<p class=\"tip\">除了这些不同，请注意这份 cookbook 仍*不是*入门教程。其大部分内容都假设你已经理解 HTML、CSS、JavaScript、npm/yarn 等基本概念。</p>\n\n## 参与 Cookbook 贡献\n\n### 我们的目标\n\nCookbook 为开发者提供了一些示例，涵盖常见的或有趣的用例，并逐步解释更复杂的细节。我们的目标是超越一个简单的示例介绍，展现更广泛适用的概念及其注意事项。\n\n如果你有兴趣参与贡献，请将您的想法填入 issue 并加上 **cookbook idea** 的标签作为起步，这样我们就可以帮助并引导您完成一个 pull request。在你的想法被认同之后，请尽可能遵循以下模板。有些小节是必须的，有些是可选的。我们强烈建议您遵循其顺序，但这也不是必须的。通常情况下案例应该：\n\n> * 解决一个具体的普遍性问题\n> * 从尽可能简单的示例开始\n> * 一次只介绍一个复杂的点\n> * 链接到其它文档，而不是在这里重新解释概念\n> * 把问题描述清楚，而不是假设大家对这个问题很熟悉\n> * 解释过程，而不是只告诉你最终结果\n> * 解释策略的利弊，包括它不适用于什么场景\n> * 会提及相关的替代方案，但会放到一个单独的案例中细讲\n\n我们需要您遵照下面的模板。当然我们也理解有的时候为了使内容更清晰或顺畅你是有必要做一些调整的。另外不论怎样，所有的案例都应该从某些点上讨论选择使用这个模式的细微差别，且我们倾向于它们以替代方案章节的形式出现。\n\n### 基本的示例\n\n*必须的*\n\n1. 用一两句话来说明问题。\n2. 用一两句话解释最简单的可能的解决方案。\n3. 显示一小段代码示例。\n4. 用一句话解释它完成了什么。\n\n### 关于其价值的细节\n\n*必须的*\n\n1. 解决人们在看例子时可能遇到的常见问题。(最好以块引用格式呈现)\n2. 显示常见错误的例子，以及如何避免它们。\n3. 用非常简单的代码示例展示好模式和坏模式。\n4. 讨论这个模式令人信服的理由。参考链接不是必需的，但鼓励提供。\n\n### 实际的例子\n\n*必须的*\n\n通过以下方式演示能够为常见或有趣的用例提供支持的代码：\n\n1. 通过几个简单的设置例子，或者\n2. 嵌入一个 CodePen / JSFiddle 的例子\n\n如果你选择稍后再提供，那么你仍应该表述它是什么和做什么。\n\n### 额外的上下文\n\n*可选的*\n\n为这个模式写点东西，描述在这个模式下，它会应用到什么地方，为什么它能正常工作；以及在此基础上运行一些代码、提供一些延伸阅读材料，都是非常有帮助的。\n\n### 何时避免这个模式\n\n*可选的*\n\n本节不是必需的，但强烈建议。你没有必要写一些特别简单易懂的事项，比如根据状态的改变开关 class，但是对于 mixin 这样的更高阶的模式来说是非常重要的。大多数高阶的问题的答案都是[“要看情况！”](https://codepen.io/rachsmith/pen/YweZbG)，该部分就包含了这一点。在此，我们要诚实地看待模式何时有用，何时应该避免，什么时候更有意义。\n\n### 替代方案\n\n*可选的，除非这部分内容在之前已经提供过了*\n\n如果你已经在上一节提供了避免使用的条件，那么这一节是必须的。探索其它方法非常重要，这样人们在遇到某些反模式的情形时不至于无所适从。这样做是因为考虑到 web 是一个不同人有着不同代码结构解决不同问题的大舞台。这个应用是大是小？它们要把 Vue 集成到一个现成的项目中还是从零起步构建新项目？它们的用户只是想达成一个目标还是多个？有很多异步数据吗？所有的这些担忧都会影响实现替代品。一篇好的 cookbook 会为开发者提供这些相关信息。\n\n## 致谢\n\n文档贡献是需要很多时间的，如果您花时间提交这部分的文档，我们将感激不尽。\n","date":"2020-07-17T01:00:17.878Z","updated":"2020-07-17T01:00:17.877Z","path":"doc/cookbook/index.html","comments":1,"layout":"page","_id":"ckcwngnjg000d9lxk3g8nw0cf","content":"<h2 id=\"Cookbook-vs-指南\"><a href=\"#Cookbook-vs-指南\" class=\"headerlink\" title=\"Cookbook vs 指南\"></a>Cookbook vs 指南</h2><p>这份 cookbook 和指南的不同之处在哪里？存在的意义是什么？</p>\n<ul>\n<li><p><strong>更专注</strong>：在指南里，我们实际上是在讲一个故事。每个章节都以之前章节的知识进行构建和假设。而在 cookbook 里，每个案例都有各自的代表性。也就是说每个案例都专注于 Vue 的某个特定方面，而不是一个概览。</p>\n</li>\n<li><p><strong>更有深度</strong>：为了避免指南写得太长，我们试着只包含了尽可能简单的示例来帮助你理解每个功能，然后就奔下一个话题了。在 cookbook 里，我们以更生动的形式包含了更复杂的示例并结合特性。每个案例都可以尽可能的翔实，以彻底探索这个领域。</p>\n</li>\n<li><p><strong>传授 JavaScript</strong>：在指南里，我们假设你至少具有 ES5 JavaScript 的中级水平。例如，我们不会解释 <code>Array.prototype.filter</code> 在计算属性中是如何过滤一个列表的。然而在 cookbook 里，我们将对一些必要的 JavaScript 特性 (包括 ES6/2015+) 进行探索和解释，以帮助我们构建更好的 Vue 应用。</p>\n</li>\n<li><p><strong>探索生态系统</strong>：对于高级特性，我们会假设你已经对生态系统有一定了解。例如，如果你想在 webpack 中使用单文件组件，我们不会解释如何在 webpack 中配置 Vue 以外的部分。在 cookbook 里，我们有空间去更深度探索这些生态系统中的库——至少能到对 Vue 开发者普遍使用的程度。</p>\n</li>\n</ul>\n<p class=\"tip\">除了这些不同，请注意这份 cookbook 仍<em>不是</em>入门教程。其大部分内容都假设你已经理解 HTML、CSS、JavaScript、npm/yarn 等基本概念。</p>\n\n<h2 id=\"参与-Cookbook-贡献\"><a href=\"#参与-Cookbook-贡献\" class=\"headerlink\" title=\"参与 Cookbook 贡献\"></a>参与 Cookbook 贡献</h2><h3 id=\"我们的目标\"><a href=\"#我们的目标\" class=\"headerlink\" title=\"我们的目标\"></a>我们的目标</h3><p>Cookbook 为开发者提供了一些示例，涵盖常见的或有趣的用例，并逐步解释更复杂的细节。我们的目标是超越一个简单的示例介绍，展现更广泛适用的概念及其注意事项。</p>\n<p>如果你有兴趣参与贡献，请将您的想法填入 issue 并加上 <strong>cookbook idea</strong> 的标签作为起步，这样我们就可以帮助并引导您完成一个 pull request。在你的想法被认同之后，请尽可能遵循以下模板。有些小节是必须的，有些是可选的。我们强烈建议您遵循其顺序，但这也不是必须的。通常情况下案例应该：</p>\n<blockquote>\n<ul>\n<li>解决一个具体的普遍性问题</li>\n<li>从尽可能简单的示例开始</li>\n<li>一次只介绍一个复杂的点</li>\n<li>链接到其它文档，而不是在这里重新解释概念</li>\n<li>把问题描述清楚，而不是假设大家对这个问题很熟悉</li>\n<li>解释过程，而不是只告诉你最终结果</li>\n<li>解释策略的利弊，包括它不适用于什么场景</li>\n<li>会提及相关的替代方案，但会放到一个单独的案例中细讲</li>\n</ul>\n</blockquote>\n<p>我们需要您遵照下面的模板。当然我们也理解有的时候为了使内容更清晰或顺畅你是有必要做一些调整的。另外不论怎样，所有的案例都应该从某些点上讨论选择使用这个模式的细微差别，且我们倾向于它们以替代方案章节的形式出现。</p>\n<h3 id=\"基本的示例\"><a href=\"#基本的示例\" class=\"headerlink\" title=\"基本的示例\"></a>基本的示例</h3><p><em>必须的</em></p>\n<ol>\n<li>用一两句话来说明问题。</li>\n<li>用一两句话解释最简单的可能的解决方案。</li>\n<li>显示一小段代码示例。</li>\n<li>用一句话解释它完成了什么。</li>\n</ol>\n<h3 id=\"关于其价值的细节\"><a href=\"#关于其价值的细节\" class=\"headerlink\" title=\"关于其价值的细节\"></a>关于其价值的细节</h3><p><em>必须的</em></p>\n<ol>\n<li>解决人们在看例子时可能遇到的常见问题。(最好以块引用格式呈现)</li>\n<li>显示常见错误的例子，以及如何避免它们。</li>\n<li>用非常简单的代码示例展示好模式和坏模式。</li>\n<li>讨论这个模式令人信服的理由。参考链接不是必需的，但鼓励提供。</li>\n</ol>\n<h3 id=\"实际的例子\"><a href=\"#实际的例子\" class=\"headerlink\" title=\"实际的例子\"></a>实际的例子</h3><p><em>必须的</em></p>\n<p>通过以下方式演示能够为常见或有趣的用例提供支持的代码：</p>\n<ol>\n<li>通过几个简单的设置例子，或者</li>\n<li>嵌入一个 CodePen / JSFiddle 的例子</li>\n</ol>\n<p>如果你选择稍后再提供，那么你仍应该表述它是什么和做什么。</p>\n<h3 id=\"额外的上下文\"><a href=\"#额外的上下文\" class=\"headerlink\" title=\"额外的上下文\"></a>额外的上下文</h3><p><em>可选的</em></p>\n<p>为这个模式写点东西，描述在这个模式下，它会应用到什么地方，为什么它能正常工作；以及在此基础上运行一些代码、提供一些延伸阅读材料，都是非常有帮助的。</p>\n<h3 id=\"何时避免这个模式\"><a href=\"#何时避免这个模式\" class=\"headerlink\" title=\"何时避免这个模式\"></a>何时避免这个模式</h3><p><em>可选的</em></p>\n<p>本节不是必需的，但强烈建议。你没有必要写一些特别简单易懂的事项，比如根据状态的改变开关 class，但是对于 mixin 这样的更高阶的模式来说是非常重要的。大多数高阶的问题的答案都是<a href=\"https://codepen.io/rachsmith/pen/YweZbG\" target=\"_blank\" rel=\"noopener\">“要看情况！”</a>，该部分就包含了这一点。在此，我们要诚实地看待模式何时有用，何时应该避免，什么时候更有意义。</p>\n<h3 id=\"替代方案\"><a href=\"#替代方案\" class=\"headerlink\" title=\"替代方案\"></a>替代方案</h3><p><em>可选的，除非这部分内容在之前已经提供过了</em></p>\n<p>如果你已经在上一节提供了避免使用的条件，那么这一节是必须的。探索其它方法非常重要，这样人们在遇到某些反模式的情形时不至于无所适从。这样做是因为考虑到 web 是一个不同人有着不同代码结构解决不同问题的大舞台。这个应用是大是小？它们要把 Vue 集成到一个现成的项目中还是从零起步构建新项目？它们的用户只是想达成一个目标还是多个？有很多异步数据吗？所有的这些担忧都会影响实现替代品。一篇好的 cookbook 会为开发者提供这些相关信息。</p>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>文档贡献是需要很多时间的，如果您花时间提交这部分的文档，我们将感激不尽。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Cookbook-vs-指南\"><a href=\"#Cookbook-vs-指南\" class=\"headerlink\" title=\"Cookbook vs 指南\"></a>Cookbook vs 指南</h2><p>这份 cookbook 和指南的不同之处在哪里？存在的意义是什么？</p>\n<ul>\n<li><p><strong>更专注</strong>：在指南里，我们实际上是在讲一个故事。每个章节都以之前章节的知识进行构建和假设。而在 cookbook 里，每个案例都有各自的代表性。也就是说每个案例都专注于 Vue 的某个特定方面，而不是一个概览。</p>\n</li>\n<li><p><strong>更有深度</strong>：为了避免指南写得太长，我们试着只包含了尽可能简单的示例来帮助你理解每个功能，然后就奔下一个话题了。在 cookbook 里，我们以更生动的形式包含了更复杂的示例并结合特性。每个案例都可以尽可能的翔实，以彻底探索这个领域。</p>\n</li>\n<li><p><strong>传授 JavaScript</strong>：在指南里，我们假设你至少具有 ES5 JavaScript 的中级水平。例如，我们不会解释 <code>Array.prototype.filter</code> 在计算属性中是如何过滤一个列表的。然而在 cookbook 里，我们将对一些必要的 JavaScript 特性 (包括 ES6/2015+) 进行探索和解释，以帮助我们构建更好的 Vue 应用。</p>\n</li>\n<li><p><strong>探索生态系统</strong>：对于高级特性，我们会假设你已经对生态系统有一定了解。例如，如果你想在 webpack 中使用单文件组件，我们不会解释如何在 webpack 中配置 Vue 以外的部分。在 cookbook 里，我们有空间去更深度探索这些生态系统中的库——至少能到对 Vue 开发者普遍使用的程度。</p>\n</li>\n</ul>\n<p class=\"tip\">除了这些不同，请注意这份 cookbook 仍<em>不是</em>入门教程。其大部分内容都假设你已经理解 HTML、CSS、JavaScript、npm/yarn 等基本概念。</p>\n\n<h2 id=\"参与-Cookbook-贡献\"><a href=\"#参与-Cookbook-贡献\" class=\"headerlink\" title=\"参与 Cookbook 贡献\"></a>参与 Cookbook 贡献</h2><h3 id=\"我们的目标\"><a href=\"#我们的目标\" class=\"headerlink\" title=\"我们的目标\"></a>我们的目标</h3><p>Cookbook 为开发者提供了一些示例，涵盖常见的或有趣的用例，并逐步解释更复杂的细节。我们的目标是超越一个简单的示例介绍，展现更广泛适用的概念及其注意事项。</p>\n<p>如果你有兴趣参与贡献，请将您的想法填入 issue 并加上 <strong>cookbook idea</strong> 的标签作为起步，这样我们就可以帮助并引导您完成一个 pull request。在你的想法被认同之后，请尽可能遵循以下模板。有些小节是必须的，有些是可选的。我们强烈建议您遵循其顺序，但这也不是必须的。通常情况下案例应该：</p>\n<blockquote>\n<ul>\n<li>解决一个具体的普遍性问题</li>\n<li>从尽可能简单的示例开始</li>\n<li>一次只介绍一个复杂的点</li>\n<li>链接到其它文档，而不是在这里重新解释概念</li>\n<li>把问题描述清楚，而不是假设大家对这个问题很熟悉</li>\n<li>解释过程，而不是只告诉你最终结果</li>\n<li>解释策略的利弊，包括它不适用于什么场景</li>\n<li>会提及相关的替代方案，但会放到一个单独的案例中细讲</li>\n</ul>\n</blockquote>\n<p>我们需要您遵照下面的模板。当然我们也理解有的时候为了使内容更清晰或顺畅你是有必要做一些调整的。另外不论怎样，所有的案例都应该从某些点上讨论选择使用这个模式的细微差别，且我们倾向于它们以替代方案章节的形式出现。</p>\n<h3 id=\"基本的示例\"><a href=\"#基本的示例\" class=\"headerlink\" title=\"基本的示例\"></a>基本的示例</h3><p><em>必须的</em></p>\n<ol>\n<li>用一两句话来说明问题。</li>\n<li>用一两句话解释最简单的可能的解决方案。</li>\n<li>显示一小段代码示例。</li>\n<li>用一句话解释它完成了什么。</li>\n</ol>\n<h3 id=\"关于其价值的细节\"><a href=\"#关于其价值的细节\" class=\"headerlink\" title=\"关于其价值的细节\"></a>关于其价值的细节</h3><p><em>必须的</em></p>\n<ol>\n<li>解决人们在看例子时可能遇到的常见问题。(最好以块引用格式呈现)</li>\n<li>显示常见错误的例子，以及如何避免它们。</li>\n<li>用非常简单的代码示例展示好模式和坏模式。</li>\n<li>讨论这个模式令人信服的理由。参考链接不是必需的，但鼓励提供。</li>\n</ol>\n<h3 id=\"实际的例子\"><a href=\"#实际的例子\" class=\"headerlink\" title=\"实际的例子\"></a>实际的例子</h3><p><em>必须的</em></p>\n<p>通过以下方式演示能够为常见或有趣的用例提供支持的代码：</p>\n<ol>\n<li>通过几个简单的设置例子，或者</li>\n<li>嵌入一个 CodePen / JSFiddle 的例子</li>\n</ol>\n<p>如果你选择稍后再提供，那么你仍应该表述它是什么和做什么。</p>\n<h3 id=\"额外的上下文\"><a href=\"#额外的上下文\" class=\"headerlink\" title=\"额外的上下文\"></a>额外的上下文</h3><p><em>可选的</em></p>\n<p>为这个模式写点东西，描述在这个模式下，它会应用到什么地方，为什么它能正常工作；以及在此基础上运行一些代码、提供一些延伸阅读材料，都是非常有帮助的。</p>\n<h3 id=\"何时避免这个模式\"><a href=\"#何时避免这个模式\" class=\"headerlink\" title=\"何时避免这个模式\"></a>何时避免这个模式</h3><p><em>可选的</em></p>\n<p>本节不是必需的，但强烈建议。你没有必要写一些特别简单易懂的事项，比如根据状态的改变开关 class，但是对于 mixin 这样的更高阶的模式来说是非常重要的。大多数高阶的问题的答案都是<a href=\"https://codepen.io/rachsmith/pen/YweZbG\" target=\"_blank\" rel=\"noopener\">“要看情况！”</a>，该部分就包含了这一点。在此，我们要诚实地看待模式何时有用，何时应该避免，什么时候更有意义。</p>\n<h3 id=\"替代方案\"><a href=\"#替代方案\" class=\"headerlink\" title=\"替代方案\"></a>替代方案</h3><p><em>可选的，除非这部分内容在之前已经提供过了</em></p>\n<p>如果你已经在上一节提供了避免使用的条件，那么这一节是必须的。探索其它方法非常重要，这样人们在遇到某些反模式的情形时不至于无所适从。这样做是因为考虑到 web 是一个不同人有着不同代码结构解决不同问题的大舞台。这个应用是大是小？它们要把 Vue 集成到一个现成的项目中还是从零起步构建新项目？它们的用户只是想达成一个目标还是多个？有很多异步数据吗？所有的这些担忧都会影响实现替代品。一篇好的 cookbook 会为开发者提供这些相关信息。</p>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>文档贡献是需要很多时间的，如果您花时间提交这部分的文档，我们将感激不尽。</p>\n"},{"_content":"头条小程序下iOS真机，provide/inject可能失败，尤其是注入this的时候，可能偶尔成功，偶尔失败。\n\n注入时机有问题，不能保证一定成功。\n\n","source":"doc/cookbook/provide-inject.md","raw":"头条小程序下iOS真机，provide/inject可能失败，尤其是注入this的时候，可能偶尔成功，偶尔失败。\n\n注入时机有问题，不能保证一定成功。\n\n","date":"2020-07-17T06:19:19.263Z","updated":"2020-07-17T06:19:19.262Z","path":"doc/cookbook/provide-inject.html","title":"","comments":1,"layout":"page","_id":"ckcwngnjh000e9lxky3f7ouls","content":"<p>头条小程序下iOS真机，provide/inject可能失败，尤其是注入this的时候，可能偶尔成功，偶尔失败。</p>\n<p>注入时机有问题，不能保证一定成功。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>头条小程序下iOS真机，provide/inject可能失败，尤其是注入this的时候，可能偶尔成功，偶尔失败。</p>\n<p>注入时机有问题，不能保证一定成功。</p>\n"},{"_content":"如果外层设置 radius，然后overflow为hidden，在安卓端里面的内容并没有被覆盖掉。\n\n测试： 图片。图片还需要自己设置border-radius。\n\n","source":"doc/cookbook/radius.md","raw":"如果外层设置 radius，然后overflow为hidden，在安卓端里面的内容并没有被覆盖掉。\n\n测试： 图片。图片还需要自己设置border-radius。\n\n","date":"2020-07-17T06:19:19.255Z","updated":"2020-07-17T06:19:19.255Z","path":"doc/cookbook/radius.html","title":"","comments":1,"layout":"page","_id":"ckcwngnji000f9lxkrhayl9e2","content":"<p>如果外层设置 radius，然后overflow为hidden，在安卓端里面的内容并没有被覆盖掉。</p>\n<p>测试： 图片。图片还需要自己设置border-radius。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果外层设置 radius，然后overflow为hidden，在安卓端里面的内容并没有被覆盖掉。</p>\n<p>测试： 图片。图片还需要自己设置border-radius。</p>\n"},{"title":"scroll的问题","type":"cookbook","order":5,"_content":"\n`scroll-view`在`scroll-x`的时候，`app-nvue`需要在`scroll`上面设置`flex-direction:row;`.\n\nmp/h5/android端内容需要在被包裹一层才能滚动。\n\nAndroid端不能设置`scroll-y`（`false`也不可以），否则无法横向滚动\n","source":"doc/cookbook/scroll.md","raw":"---\ntitle: scroll的问题\ntype: cookbook\norder: 5\n---\n\n`scroll-view`在`scroll-x`的时候，`app-nvue`需要在`scroll`上面设置`flex-direction:row;`.\n\nmp/h5/android端内容需要在被包裹一层才能滚动。\n\nAndroid端不能设置`scroll-y`（`false`也不可以），否则无法横向滚动\n","date":"2020-07-17T06:24:04.420Z","updated":"2020-07-17T06:24:04.420Z","path":"doc/cookbook/scroll.html","comments":1,"layout":"page","_id":"ckcwngnjj000g9lxk420xz6v4","content":"<p><code>scroll-view</code>在<code>scroll-x</code>的时候，<code>app-nvue</code>需要在<code>scroll</code>上面设置<code>flex-direction:row;</code>.</p>\n<p>mp/h5/android端内容需要在被包裹一层才能滚动。</p>\n<p>Android端不能设置<code>scroll-y</code>（<code>false</code>也不可以），否则无法横向滚动</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>scroll-view</code>在<code>scroll-x</code>的时候，<code>app-nvue</code>需要在<code>scroll</code>上面设置<code>flex-direction:row;</code>.</p>\n<p>mp/h5/android端内容需要在被包裹一层才能滚动。</p>\n<p>Android端不能设置<code>scroll-y</code>（<code>false</code>也不可以），否则无法横向滚动</p>\n"},{"title":"js中sort排序","type":"cookbook","order":2,"_content":"\njs arr 的sort方法，是原地排序。\n\n排序规则需要定义:\n\n```js\nconst a = [1, 4, 2, 10, 8]\n\na.sort((a, b) => {\n\t// 从小到大。 不能使用 return a < b 之类的\n\treturn a - b\n})\n\na.sort((a, b) => {\n\t// 从大到小。 不能使用 return a > b 之类的\n\treturn b - a\n})\n\n```\n","source":"doc/cookbook/sort.md","raw":"---\ntitle: js中sort排序\ntype: cookbook\norder: 2\n---\n\njs arr 的sort方法，是原地排序。\n\n排序规则需要定义:\n\n```js\nconst a = [1, 4, 2, 10, 8]\n\na.sort((a, b) => {\n\t// 从小到大。 不能使用 return a < b 之类的\n\treturn a - b\n})\n\na.sort((a, b) => {\n\t// 从大到小。 不能使用 return a > b 之类的\n\treturn b - a\n})\n\n```\n","date":"2020-07-17T06:21:32.491Z","updated":"2020-07-17T06:21:32.491Z","path":"doc/cookbook/sort.html","comments":1,"layout":"page","_id":"ckcwngnjj000h9lxkxlzskes6","content":"<p>js arr 的sort方法，是原地排序。</p>\n<p>排序规则需要定义:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">8</span>]\n\na.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> &#123;\n\t<span class=\"hljs-comment\">// 从小到大。 不能使用 return a &lt; b 之类的</span>\n\t<span class=\"hljs-keyword\">return</span> a - b\n&#125;)\n\na.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> &#123;\n\t<span class=\"hljs-comment\">// 从大到小。 不能使用 return a &gt; b 之类的</span>\n\t<span class=\"hljs-keyword\">return</span> b - a\n&#125;)</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>js arr 的sort方法，是原地排序。</p>\n<p>排序规则需要定义:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">8</span>]\n\na.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> &#123;\n\t<span class=\"hljs-comment\">// 从小到大。 不能使用 return a &lt; b 之类的</span>\n\t<span class=\"hljs-keyword\">return</span> a - b\n&#125;)\n\na.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> &#123;\n\t<span class=\"hljs-comment\">// 从大到小。 不能使用 return a &gt; b 之类的</span>\n\t<span class=\"hljs-keyword\">return</span> b - a\n&#125;)</code></pre>\n"},{"title":"空字符串的判定","type":"cookbook","order":1,"_content":"\n// 需要注意，如果我们在外部设置 `text=\"\"`，mp中会显示true，我们应该设置`:text=\"null\"`。或者 `:text=\"blankStr\" blankStr = ''`.\n\n// 如果在props内部，`default: \"\"` 会显示空\n\n当然副职null的情况，我们需要自己判断下显示 `text || ''`\n","source":"doc/cookbook/string.md","raw":"---\ntitle: 空字符串的判定\ntype: cookbook\norder: 1\n---\n\n// 需要注意，如果我们在外部设置 `text=\"\"`，mp中会显示true，我们应该设置`:text=\"null\"`。或者 `:text=\"blankStr\" blankStr = ''`.\n\n// 如果在props内部，`default: \"\"` 会显示空\n\n当然副职null的情况，我们需要自己判断下显示 `text || ''`\n","date":"2020-07-17T06:20:32.880Z","updated":"2020-07-17T06:20:32.880Z","path":"doc/cookbook/string.html","comments":1,"layout":"page","_id":"ckcwngnjk000i9lxk0lqnxpy0","content":"<p>// 需要注意，如果我们在外部设置 <code>text=&quot;&quot;</code>，mp中会显示true，我们应该设置<code>:text=&quot;null&quot;</code>。或者 <code>:text=&quot;blankStr&quot; blankStr = &#39;&#39;</code>.</p>\n<p>// 如果在props内部，<code>default: &quot;&quot;</code> 会显示空</p>\n<p>当然副职null的情况，我们需要自己判断下显示 <code>text || &#39;&#39;</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>// 需要注意，如果我们在外部设置 <code>text=&quot;&quot;</code>，mp中会显示true，我们应该设置<code>:text=&quot;null&quot;</code>。或者 <code>:text=&quot;blankStr&quot; blankStr = &#39;&#39;</code>.</p>\n<p>// 如果在props内部，<code>default: &quot;&quot;</code> 会显示空</p>\n<p>当然副职null的情况，我们需要自己判断下显示 <code>text || &#39;&#39;</code></p>\n"},{"title":"textarea总结","type":"cookbook","order":4,"_content":"\n- textarea在auto-height开启之后，小程序和h5上面无法设置min-height，没有初始化高度，在app（至少iOS）上面min-height有效；\n- auto-height开启之后，textarea是无法滚动的，哪怕打开之后再关闭，也是无法滚动的，所以不支持动态的auto-height（我们可以尝试先设置高度，等高度到一定的时候设置auto-height，不知道这样是否有效。不足高度的时候使用固定高度，高度足够的时候使用自动高度）；\n- linechange事件可以监听，用于设置高度，不过目前app-nvue端以及头条小程序端不支持linechahnge；\n\n> 以下为nvue页面实现方式，vue页面直接参考小程序端实现方式\n\n# 实现自动高度以及最低高度限制\n\n- app端设置min-height，以及开启auto-height；\n- 支持line-change的小程序端（头条不支持），根据行数来设置高度；\n- 不支持line-change的小程序端（头条），可以考虑动态开启auto-height，当文本高度不足时，使用height，关闭auto-height，当高度足够时，使用auto-height，当然，这需要监听文字输入与改变，且有待实验；\n- 设置高度，然后利用一个额外的text来监测高度变化，不断给text-area设置合适高度；\n\n# 实现自动高度以及最大高度或者行数限制\n\n- 支持line-change的，使用line-change决定高度；\n- 不支持line-change的无法实现自动高度，因为auto-height关闭之后无法滚动，从而不能实现最大高度限制，建议考虑下面方法；\n- 不支持line-change的可以借助于额外的text元素来实现合适高度的决策；\n\n# 实现最低高度，自动高度，以及最大高度限制\n\n- 支持line-change的，使用line-change决定高度；\n- 不支持line-change的可以借助于额外的text元素来实现合适高度的决策；\n\n# 总结\n\n尚待实验和测试\n","source":"doc/cookbook/textarea.md","raw":"---\ntitle: textarea总结\ntype: cookbook\norder: 4\n---\n\n- textarea在auto-height开启之后，小程序和h5上面无法设置min-height，没有初始化高度，在app（至少iOS）上面min-height有效；\n- auto-height开启之后，textarea是无法滚动的，哪怕打开之后再关闭，也是无法滚动的，所以不支持动态的auto-height（我们可以尝试先设置高度，等高度到一定的时候设置auto-height，不知道这样是否有效。不足高度的时候使用固定高度，高度足够的时候使用自动高度）；\n- linechange事件可以监听，用于设置高度，不过目前app-nvue端以及头条小程序端不支持linechahnge；\n\n> 以下为nvue页面实现方式，vue页面直接参考小程序端实现方式\n\n# 实现自动高度以及最低高度限制\n\n- app端设置min-height，以及开启auto-height；\n- 支持line-change的小程序端（头条不支持），根据行数来设置高度；\n- 不支持line-change的小程序端（头条），可以考虑动态开启auto-height，当文本高度不足时，使用height，关闭auto-height，当高度足够时，使用auto-height，当然，这需要监听文字输入与改变，且有待实验；\n- 设置高度，然后利用一个额外的text来监测高度变化，不断给text-area设置合适高度；\n\n# 实现自动高度以及最大高度或者行数限制\n\n- 支持line-change的，使用line-change决定高度；\n- 不支持line-change的无法实现自动高度，因为auto-height关闭之后无法滚动，从而不能实现最大高度限制，建议考虑下面方法；\n- 不支持line-change的可以借助于额外的text元素来实现合适高度的决策；\n\n# 实现最低高度，自动高度，以及最大高度限制\n\n- 支持line-change的，使用line-change决定高度；\n- 不支持line-change的可以借助于额外的text元素来实现合适高度的决策；\n\n# 总结\n\n尚待实验和测试\n","date":"2020-07-17T06:23:30.779Z","updated":"2020-07-17T06:23:30.779Z","path":"doc/cookbook/textarea.html","comments":1,"layout":"page","_id":"ckcwngnjk000j9lxkyqveg4uw","content":"<ul>\n<li>textarea在auto-height开启之后，小程序和h5上面无法设置min-height，没有初始化高度，在app（至少iOS）上面min-height有效；</li>\n<li>auto-height开启之后，textarea是无法滚动的，哪怕打开之后再关闭，也是无法滚动的，所以不支持动态的auto-height（我们可以尝试先设置高度，等高度到一定的时候设置auto-height，不知道这样是否有效。不足高度的时候使用固定高度，高度足够的时候使用自动高度）；</li>\n<li>linechange事件可以监听，用于设置高度，不过目前app-nvue端以及头条小程序端不支持linechahnge；</li>\n</ul>\n<blockquote>\n<p>以下为nvue页面实现方式，vue页面直接参考小程序端实现方式</p>\n</blockquote>\n<h1 id=\"实现自动高度以及最低高度限制\"><a href=\"#实现自动高度以及最低高度限制\" class=\"headerlink\" title=\"实现自动高度以及最低高度限制\"></a>实现自动高度以及最低高度限制</h1><ul>\n<li>app端设置min-height，以及开启auto-height；</li>\n<li>支持line-change的小程序端（头条不支持），根据行数来设置高度；</li>\n<li>不支持line-change的小程序端（头条），可以考虑动态开启auto-height，当文本高度不足时，使用height，关闭auto-height，当高度足够时，使用auto-height，当然，这需要监听文字输入与改变，且有待实验；</li>\n<li>设置高度，然后利用一个额外的text来监测高度变化，不断给text-area设置合适高度；</li>\n</ul>\n<h1 id=\"实现自动高度以及最大高度或者行数限制\"><a href=\"#实现自动高度以及最大高度或者行数限制\" class=\"headerlink\" title=\"实现自动高度以及最大高度或者行数限制\"></a>实现自动高度以及最大高度或者行数限制</h1><ul>\n<li>支持line-change的，使用line-change决定高度；</li>\n<li>不支持line-change的无法实现自动高度，因为auto-height关闭之后无法滚动，从而不能实现最大高度限制，建议考虑下面方法；</li>\n<li>不支持line-change的可以借助于额外的text元素来实现合适高度的决策；</li>\n</ul>\n<h1 id=\"实现最低高度，自动高度，以及最大高度限制\"><a href=\"#实现最低高度，自动高度，以及最大高度限制\" class=\"headerlink\" title=\"实现最低高度，自动高度，以及最大高度限制\"></a>实现最低高度，自动高度，以及最大高度限制</h1><ul>\n<li>支持line-change的，使用line-change决定高度；</li>\n<li>不支持line-change的可以借助于额外的text元素来实现合适高度的决策；</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>尚待实验和测试</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>textarea在auto-height开启之后，小程序和h5上面无法设置min-height，没有初始化高度，在app（至少iOS）上面min-height有效；</li>\n<li>auto-height开启之后，textarea是无法滚动的，哪怕打开之后再关闭，也是无法滚动的，所以不支持动态的auto-height（我们可以尝试先设置高度，等高度到一定的时候设置auto-height，不知道这样是否有效。不足高度的时候使用固定高度，高度足够的时候使用自动高度）；</li>\n<li>linechange事件可以监听，用于设置高度，不过目前app-nvue端以及头条小程序端不支持linechahnge；</li>\n</ul>\n<blockquote>\n<p>以下为nvue页面实现方式，vue页面直接参考小程序端实现方式</p>\n</blockquote>\n<h1 id=\"实现自动高度以及最低高度限制\"><a href=\"#实现自动高度以及最低高度限制\" class=\"headerlink\" title=\"实现自动高度以及最低高度限制\"></a>实现自动高度以及最低高度限制</h1><ul>\n<li>app端设置min-height，以及开启auto-height；</li>\n<li>支持line-change的小程序端（头条不支持），根据行数来设置高度；</li>\n<li>不支持line-change的小程序端（头条），可以考虑动态开启auto-height，当文本高度不足时，使用height，关闭auto-height，当高度足够时，使用auto-height，当然，这需要监听文字输入与改变，且有待实验；</li>\n<li>设置高度，然后利用一个额外的text来监测高度变化，不断给text-area设置合适高度；</li>\n</ul>\n<h1 id=\"实现自动高度以及最大高度或者行数限制\"><a href=\"#实现自动高度以及最大高度或者行数限制\" class=\"headerlink\" title=\"实现自动高度以及最大高度或者行数限制\"></a>实现自动高度以及最大高度或者行数限制</h1><ul>\n<li>支持line-change的，使用line-change决定高度；</li>\n<li>不支持line-change的无法实现自动高度，因为auto-height关闭之后无法滚动，从而不能实现最大高度限制，建议考虑下面方法；</li>\n<li>不支持line-change的可以借助于额外的text元素来实现合适高度的决策；</li>\n</ul>\n<h1 id=\"实现最低高度，自动高度，以及最大高度限制\"><a href=\"#实现最低高度，自动高度，以及最大高度限制\" class=\"headerlink\" title=\"实现最低高度，自动高度，以及最大高度限制\"></a>实现最低高度，自动高度，以及最大高度限制</h1><ul>\n<li>支持line-change的，使用line-change决定高度；</li>\n<li>不支持line-change的可以借助于额外的text元素来实现合适高度的决策；</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>尚待实验和测试</p>\n"},{"_content":"写一个vue格式的组件，在里面做好条件编译。\n\n- nvue页面引入这个vue格式的组件，编译到app端则会使用app端对应的条件；\n- nvue页面引入这个vue格式的组件，编译到非app端则会对应其他相应的编译条件。\n\n组件的后缀不重要，是nvue还是vue最终是由页面决定的， APP-NVUE和APP-PLUS-NVUE是一样的.\n\nnvue页面引入组件，组件可以是vue后缀的，编译到app端会是相应的nvue规范\n","source":"doc/cookbook/uni后缀.md","raw":"写一个vue格式的组件，在里面做好条件编译。\n\n- nvue页面引入这个vue格式的组件，编译到app端则会使用app端对应的条件；\n- nvue页面引入这个vue格式的组件，编译到非app端则会对应其他相应的编译条件。\n\n组件的后缀不重要，是nvue还是vue最终是由页面决定的， APP-NVUE和APP-PLUS-NVUE是一样的.\n\nnvue页面引入组件，组件可以是vue后缀的，编译到app端会是相应的nvue规范\n","date":"2020-07-17T06:19:19.192Z","updated":"2020-07-17T06:19:19.191Z","path":"doc/cookbook/uni后缀.html","title":"","comments":1,"layout":"page","_id":"ckcwngnjl000k9lxkckkddvms","content":"<p>写一个vue格式的组件，在里面做好条件编译。</p>\n<ul>\n<li>nvue页面引入这个vue格式的组件，编译到app端则会使用app端对应的条件；</li>\n<li>nvue页面引入这个vue格式的组件，编译到非app端则会对应其他相应的编译条件。</li>\n</ul>\n<p>组件的后缀不重要，是nvue还是vue最终是由页面决定的， APP-NVUE和APP-PLUS-NVUE是一样的.</p>\n<p>nvue页面引入组件，组件可以是vue后缀的，编译到app端会是相应的nvue规范</p>\n","site":{"data":{}},"excerpt":"","more":"<p>写一个vue格式的组件，在里面做好条件编译。</p>\n<ul>\n<li>nvue页面引入这个vue格式的组件，编译到app端则会使用app端对应的条件；</li>\n<li>nvue页面引入这个vue格式的组件，编译到非app端则会对应其他相应的编译条件。</li>\n</ul>\n<p>组件的后缀不重要，是nvue还是vue最终是由页面决定的， APP-NVUE和APP-PLUS-NVUE是一样的.</p>\n<p>nvue页面引入组件，组件可以是vue后缀的，编译到app端会是相应的nvue规范</p>\n"},{"_content":"在头条小程序里面，window的高度不会包含navbar和statusbar的高度，不管是否设置了navbar。总是会比screenHeight少个64px=44px+20px\n\n在其它地方，windowHeight会随着是否有statusBar和navbar而变化。screenHeight是整个屏幕的高度，总是大于或者等于windowHeight.\n\n我们发现，在关闭了navbar的时候，windowHeight和screenHeight是一样的高度。不过头条小程序依然少64px\n","source":"doc/cookbook/windowScreen.md","raw":"在头条小程序里面，window的高度不会包含navbar和statusbar的高度，不管是否设置了navbar。总是会比screenHeight少个64px=44px+20px\n\n在其它地方，windowHeight会随着是否有statusBar和navbar而变化。screenHeight是整个屏幕的高度，总是大于或者等于windowHeight.\n\n我们发现，在关闭了navbar的时候，windowHeight和screenHeight是一样的高度。不过头条小程序依然少64px\n","date":"2020-07-17T06:19:19.305Z","updated":"2020-07-17T06:19:19.305Z","path":"doc/cookbook/windowScreen.html","title":"","comments":1,"layout":"page","_id":"ckcwngnjl000l9lxkjdbut1et","content":"<p>在头条小程序里面，window的高度不会包含navbar和statusbar的高度，不管是否设置了navbar。总是会比screenHeight少个64px=44px+20px</p>\n<p>在其它地方，windowHeight会随着是否有statusBar和navbar而变化。screenHeight是整个屏幕的高度，总是大于或者等于windowHeight.</p>\n<p>我们发现，在关闭了navbar的时候，windowHeight和screenHeight是一样的高度。不过头条小程序依然少64px</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在头条小程序里面，window的高度不会包含navbar和statusbar的高度，不管是否设置了navbar。总是会比screenHeight少个64px=44px+20px</p>\n<p>在其它地方，windowHeight会随着是否有statusBar和navbar而变化。screenHeight是整个屏幕的高度，总是大于或者等于windowHeight.</p>\n<p>我们发现，在关闭了navbar的时候，windowHeight和screenHeight是一样的高度。不过头条小程序依然少64px</p>\n"},{"title":"v3中getApp","type":"cookbook","order":3,"_content":"\n> `v3`模式加速了首页 `nvue` 的启动速度，当在首页 `nvue` 中访问 `getApp` 不一定可以获取真正的 `App` 对象.\n\n> `nvue` 首页使用 `const app = getApp({allowDefault: true})` , 这样能获取一个 `app` 对象，可以使用这个 `app` 对象操作 `globalData`，但是注意这时候不能获取 `App.vue` 内 `globalData` 设置的初始值.\n\n# 疑问\n- 使用 `allowDefault` 时，是否可以对 `app`中的 `globalData` 进行赋值操作，下一次继续使用 `allowDefault`获取的`app`，能不能提取到赋值之后的`globalData`；\n- `allowDefault`获取到的`app`，它的`globalData`赋值之后是不是会同步到`getApp`的`app`对象；\n\n## 进一步解释\n比如我页面，`getApp()` 还是 `undefined` 的时候，我使用 `getApp({allowDefault: true})` 来 将数据存入它的 `globalData`。然后我在 后面 用 `getApp()` 来直接获取到了 `app` 对象，这个时候 我能从 这个 `app` 对象 获取到 前面使用 `allowDefault` 赋值的 `globalData` 吗？\n\n再直接一点就是： getApp 使用的就是 单例，不管如何调用，`getApp({allowDefault: true})` 和  `getApp()` 实际上就是 同一个 对象。\n\n只不过 `getApp()` 需要依赖 `app.vue` 里面的 状态 来做初始化，而 `getApp({allowDefault: true})` 直接就是 自己初始化，不依赖 `app.vue`. 它们 实际上 就是 同一个 对象。当  `getApp({allowDefault: true})` 已经被调用，生成对象`a`的时候，再调用 `getApp()`, 获得的就是 `对象a`.\n\n# 回复\n\n可以这么理解吧，下面这样的代码应该就是你要实现的效果吧\n\n```js\nonLoad() {\n    const app = getApp({\n        allowDefault: true\n    })\n    app.test = function() {\n        console.log('app.test', 'test')\n    }\n    app.globalData.a = 'a'\n},\nmethods: {\n    onClick() {\n        const app = getApp()\n        console.log('app.globalData.a', app.globalData.a)\n        app.test()\n    }\n}\n```\n\n[v3 getApp](https://github.com/dcloudio/uni-app/issues/1091)\n","source":"doc/cookbook/v3.md","raw":"---\ntitle: v3中getApp\ntype: cookbook\norder: 3\n---\n\n> `v3`模式加速了首页 `nvue` 的启动速度，当在首页 `nvue` 中访问 `getApp` 不一定可以获取真正的 `App` 对象.\n\n> `nvue` 首页使用 `const app = getApp({allowDefault: true})` , 这样能获取一个 `app` 对象，可以使用这个 `app` 对象操作 `globalData`，但是注意这时候不能获取 `App.vue` 内 `globalData` 设置的初始值.\n\n# 疑问\n- 使用 `allowDefault` 时，是否可以对 `app`中的 `globalData` 进行赋值操作，下一次继续使用 `allowDefault`获取的`app`，能不能提取到赋值之后的`globalData`；\n- `allowDefault`获取到的`app`，它的`globalData`赋值之后是不是会同步到`getApp`的`app`对象；\n\n## 进一步解释\n比如我页面，`getApp()` 还是 `undefined` 的时候，我使用 `getApp({allowDefault: true})` 来 将数据存入它的 `globalData`。然后我在 后面 用 `getApp()` 来直接获取到了 `app` 对象，这个时候 我能从 这个 `app` 对象 获取到 前面使用 `allowDefault` 赋值的 `globalData` 吗？\n\n再直接一点就是： getApp 使用的就是 单例，不管如何调用，`getApp({allowDefault: true})` 和  `getApp()` 实际上就是 同一个 对象。\n\n只不过 `getApp()` 需要依赖 `app.vue` 里面的 状态 来做初始化，而 `getApp({allowDefault: true})` 直接就是 自己初始化，不依赖 `app.vue`. 它们 实际上 就是 同一个 对象。当  `getApp({allowDefault: true})` 已经被调用，生成对象`a`的时候，再调用 `getApp()`, 获得的就是 `对象a`.\n\n# 回复\n\n可以这么理解吧，下面这样的代码应该就是你要实现的效果吧\n\n```js\nonLoad() {\n    const app = getApp({\n        allowDefault: true\n    })\n    app.test = function() {\n        console.log('app.test', 'test')\n    }\n    app.globalData.a = 'a'\n},\nmethods: {\n    onClick() {\n        const app = getApp()\n        console.log('app.globalData.a', app.globalData.a)\n        app.test()\n    }\n}\n```\n\n[v3 getApp](https://github.com/dcloudio/uni-app/issues/1091)\n","date":"2020-07-17T06:21:52.145Z","updated":"2020-07-17T06:21:52.145Z","path":"doc/cookbook/v3.html","comments":1,"layout":"page","_id":"ckcwngnjl000m9lxktholu1qr","content":"<blockquote>\n<p><code>v3</code>模式加速了首页 <code>nvue</code> 的启动速度，当在首页 <code>nvue</code> 中访问 <code>getApp</code> 不一定可以获取真正的 <code>App</code> 对象.</p>\n</blockquote>\n<blockquote>\n<p><code>nvue</code> 首页使用 <code>const app = getApp({allowDefault: true})</code> , 这样能获取一个 <code>app</code> 对象，可以使用这个 <code>app</code> 对象操作 <code>globalData</code>，但是注意这时候不能获取 <code>App.vue</code> 内 <code>globalData</code> 设置的初始值.</p>\n</blockquote>\n<h1 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h1><ul>\n<li>使用 <code>allowDefault</code> 时，是否可以对 <code>app</code>中的 <code>globalData</code> 进行赋值操作，下一次继续使用 <code>allowDefault</code>获取的<code>app</code>，能不能提取到赋值之后的<code>globalData</code>；</li>\n<li><code>allowDefault</code>获取到的<code>app</code>，它的<code>globalData</code>赋值之后是不是会同步到<code>getApp</code>的<code>app</code>对象；</li>\n</ul>\n<h2 id=\"进一步解释\"><a href=\"#进一步解释\" class=\"headerlink\" title=\"进一步解释\"></a>进一步解释</h2><p>比如我页面，<code>getApp()</code> 还是 <code>undefined</code> 的时候，我使用 <code>getApp({allowDefault: true})</code> 来 将数据存入它的 <code>globalData</code>。然后我在 后面 用 <code>getApp()</code> 来直接获取到了 <code>app</code> 对象，这个时候 我能从 这个 <code>app</code> 对象 获取到 前面使用 <code>allowDefault</code> 赋值的 <code>globalData</code> 吗？</p>\n<p>再直接一点就是： getApp 使用的就是 单例，不管如何调用，<code>getApp({allowDefault: true})</code> 和  <code>getApp()</code> 实际上就是 同一个 对象。</p>\n<p>只不过 <code>getApp()</code> 需要依赖 <code>app.vue</code> 里面的 状态 来做初始化，而 <code>getApp({allowDefault: true})</code> 直接就是 自己初始化，不依赖 <code>app.vue</code>. 它们 实际上 就是 同一个 对象。当  <code>getApp({allowDefault: true})</code> 已经被调用，生成对象<code>a</code>的时候，再调用 <code>getApp()</code>, 获得的就是 <code>对象a</code>.</p>\n<h1 id=\"回复\"><a href=\"#回复\" class=\"headerlink\" title=\"回复\"></a>回复</h1><p>可以这么理解吧，下面这样的代码应该就是你要实现的效果吧</p>\n<pre><code class=\"hljs js\">onLoad() &#123;\n    <span class=\"hljs-keyword\">const</span> app = getApp(&#123;\n        <span class=\"hljs-attr\">allowDefault</span>: <span class=\"hljs-literal\">true</span>\n    &#125;)\n    app.test = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'app.test'</span>, <span class=\"hljs-string\">'test'</span>)\n    &#125;\n    app.globalData.a = <span class=\"hljs-string\">'a'</span>\n&#125;,\n<span class=\"hljs-attr\">methods</span>: &#123;\n    onClick() &#123;\n        <span class=\"hljs-keyword\">const</span> app = getApp()\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'app.globalData.a'</span>, app.globalData.a)\n        app.test()\n    &#125;\n&#125;</code></pre>\n<p><a href=\"https://github.com/dcloudio/uni-app/issues/1091\" target=\"_blank\" rel=\"noopener\">v3 getApp</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><code>v3</code>模式加速了首页 <code>nvue</code> 的启动速度，当在首页 <code>nvue</code> 中访问 <code>getApp</code> 不一定可以获取真正的 <code>App</code> 对象.</p>\n</blockquote>\n<blockquote>\n<p><code>nvue</code> 首页使用 <code>const app = getApp({allowDefault: true})</code> , 这样能获取一个 <code>app</code> 对象，可以使用这个 <code>app</code> 对象操作 <code>globalData</code>，但是注意这时候不能获取 <code>App.vue</code> 内 <code>globalData</code> 设置的初始值.</p>\n</blockquote>\n<h1 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h1><ul>\n<li>使用 <code>allowDefault</code> 时，是否可以对 <code>app</code>中的 <code>globalData</code> 进行赋值操作，下一次继续使用 <code>allowDefault</code>获取的<code>app</code>，能不能提取到赋值之后的<code>globalData</code>；</li>\n<li><code>allowDefault</code>获取到的<code>app</code>，它的<code>globalData</code>赋值之后是不是会同步到<code>getApp</code>的<code>app</code>对象；</li>\n</ul>\n<h2 id=\"进一步解释\"><a href=\"#进一步解释\" class=\"headerlink\" title=\"进一步解释\"></a>进一步解释</h2><p>比如我页面，<code>getApp()</code> 还是 <code>undefined</code> 的时候，我使用 <code>getApp({allowDefault: true})</code> 来 将数据存入它的 <code>globalData</code>。然后我在 后面 用 <code>getApp()</code> 来直接获取到了 <code>app</code> 对象，这个时候 我能从 这个 <code>app</code> 对象 获取到 前面使用 <code>allowDefault</code> 赋值的 <code>globalData</code> 吗？</p>\n<p>再直接一点就是： getApp 使用的就是 单例，不管如何调用，<code>getApp({allowDefault: true})</code> 和  <code>getApp()</code> 实际上就是 同一个 对象。</p>\n<p>只不过 <code>getApp()</code> 需要依赖 <code>app.vue</code> 里面的 状态 来做初始化，而 <code>getApp({allowDefault: true})</code> 直接就是 自己初始化，不依赖 <code>app.vue</code>. 它们 实际上 就是 同一个 对象。当  <code>getApp({allowDefault: true})</code> 已经被调用，生成对象<code>a</code>的时候，再调用 <code>getApp()</code>, 获得的就是 <code>对象a</code>.</p>\n<h1 id=\"回复\"><a href=\"#回复\" class=\"headerlink\" title=\"回复\"></a>回复</h1><p>可以这么理解吧，下面这样的代码应该就是你要实现的效果吧</p>\n<pre><code class=\"hljs js\">onLoad() &#123;\n    <span class=\"hljs-keyword\">const</span> app = getApp(&#123;\n        <span class=\"hljs-attr\">allowDefault</span>: <span class=\"hljs-literal\">true</span>\n    &#125;)\n    app.test = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'app.test'</span>, <span class=\"hljs-string\">'test'</span>)\n    &#125;\n    app.globalData.a = <span class=\"hljs-string\">'a'</span>\n&#125;,\n<span class=\"hljs-attr\">methods</span>: &#123;\n    onClick() &#123;\n        <span class=\"hljs-keyword\">const</span> app = getApp()\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'app.globalData.a'</span>, app.globalData.a)\n        app.test()\n    &#125;\n&#125;</code></pre>\n<p><a href=\"https://github.com/dcloudio/uni-app/issues/1091\" target=\"_blank\" rel=\"noopener\">v3 getApp</a></p>\n"},{"_content":"nvue下如果存在全局css的话（app.vue里)，在app端只会在page的js文件里面出现一次，但是若是不使用全局文件，而是每次都在组件里面引入的话，页面的js里面会出现多次这些css。\napp端使用全局css，可以大量减少页面js的css量，减少包体积，加快js内查询速度。\n\n对于非app端来说，一定程度上也可以减少代码量。\n非app下，全局和非全局css都是只会出现一次，不过，非全局的情况下，每一个组件里面都会出现这个css。使用全局css文件，可以减少组件下的css量，从而减少包体积。并且页面下也不会再出现这个全局css文件的内容。虽然app端nvue页面是会出现的（因为所有依赖需要的东西都会进入一个js里面）。\n\n另外对于scss/less来说，引入全局scss变量是不起作用的。组件或者页面里面对于变量的使用会报错：不存在该变量。\n\n所以对于变量，依然需要单独引入。变量的引入不会增加css量，所以没有关系。\n\n最佳的办法就是 变量和css分开文件，不要放在一个文件里面。我们在需要用变量的地方引入变量。而其它css都是直接公用。\n\n","source":"doc/cookbook/全局css的问题.md","raw":"nvue下如果存在全局css的话（app.vue里)，在app端只会在page的js文件里面出现一次，但是若是不使用全局文件，而是每次都在组件里面引入的话，页面的js里面会出现多次这些css。\napp端使用全局css，可以大量减少页面js的css量，减少包体积，加快js内查询速度。\n\n对于非app端来说，一定程度上也可以减少代码量。\n非app下，全局和非全局css都是只会出现一次，不过，非全局的情况下，每一个组件里面都会出现这个css。使用全局css文件，可以减少组件下的css量，从而减少包体积。并且页面下也不会再出现这个全局css文件的内容。虽然app端nvue页面是会出现的（因为所有依赖需要的东西都会进入一个js里面）。\n\n另外对于scss/less来说，引入全局scss变量是不起作用的。组件或者页面里面对于变量的使用会报错：不存在该变量。\n\n所以对于变量，依然需要单独引入。变量的引入不会增加css量，所以没有关系。\n\n最佳的办法就是 变量和css分开文件，不要放在一个文件里面。我们在需要用变量的地方引入变量。而其它css都是直接公用。\n\n","date":"2020-07-17T06:19:19.258Z","updated":"2020-07-17T06:19:19.258Z","path":"doc/cookbook/全局css的问题.html","title":"","comments":1,"layout":"page","_id":"ckcwngnjm000n9lxk6y7wdggm","content":"<p>nvue下如果存在全局css的话（app.vue里)，在app端只会在page的js文件里面出现一次，但是若是不使用全局文件，而是每次都在组件里面引入的话，页面的js里面会出现多次这些css。<br>app端使用全局css，可以大量减少页面js的css量，减少包体积，加快js内查询速度。</p>\n<p>对于非app端来说，一定程度上也可以减少代码量。<br>非app下，全局和非全局css都是只会出现一次，不过，非全局的情况下，每一个组件里面都会出现这个css。使用全局css文件，可以减少组件下的css量，从而减少包体积。并且页面下也不会再出现这个全局css文件的内容。虽然app端nvue页面是会出现的（因为所有依赖需要的东西都会进入一个js里面）。</p>\n<p>另外对于scss/less来说，引入全局scss变量是不起作用的。组件或者页面里面对于变量的使用会报错：不存在该变量。</p>\n<p>所以对于变量，依然需要单独引入。变量的引入不会增加css量，所以没有关系。</p>\n<p>最佳的办法就是 变量和css分开文件，不要放在一个文件里面。我们在需要用变量的地方引入变量。而其它css都是直接公用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>nvue下如果存在全局css的话（app.vue里)，在app端只会在page的js文件里面出现一次，但是若是不使用全局文件，而是每次都在组件里面引入的话，页面的js里面会出现多次这些css。<br>app端使用全局css，可以大量减少页面js的css量，减少包体积，加快js内查询速度。</p>\n<p>对于非app端来说，一定程度上也可以减少代码量。<br>非app下，全局和非全局css都是只会出现一次，不过，非全局的情况下，每一个组件里面都会出现这个css。使用全局css文件，可以减少组件下的css量，从而减少包体积。并且页面下也不会再出现这个全局css文件的内容。虽然app端nvue页面是会出现的（因为所有依赖需要的东西都会进入一个js里面）。</p>\n<p>另外对于scss/less来说，引入全局scss变量是不起作用的。组件或者页面里面对于变量的使用会报错：不存在该变量。</p>\n<p>所以对于变量，依然需要单独引入。变量的引入不会增加css量，所以没有关系。</p>\n<p>最佳的办法就是 变量和css分开文件，不要放在一个文件里面。我们在需要用变量的地方引入变量。而其它css都是直接公用。</p>\n"},{"_content":"在使用的过程中，我的全局js 变量在app端总是被重置。在ios和Android上面都有过测试。在mp和H5上可以正常使用。\n\n```\nexport const tokenInfo = {\n\taccess: null,\n\taccessTime: null,\n\trefresh: null,\n\trefreshTime: null\n}\n```\n\n我从storage中获取保存的aceess/refresh等信息，然后放入tokenInfo中，接下来我就利用tokenInfo进行请求测试，接下来的请求中往往第一个请求能够获取到tokenInfo，第二个请求获取tokenInfo的时候每一个item就都是空了。\n\n我有一个 请求库，请求库需要用到这个 tokenInfo，每一次请求都会检测 tokenInfo 是否过期，过期就刷新token，或者终止请求等。\n\n因为vuex中的actions引入了这个请求库，所以我暂时没有把 tokenInfo放入 vuex中，只是 用了 一个全局的js文件来存储。\n\n莫非我要放弃所有的actions，然后把 tokenInfo 放在 vuex中？\n\n而 store 在工具类 js中隔离，无法互通。\n\n# 总结\n- 全局js变量，在nvue中不可用，会被重置；\n- store/vuex在非mixin或者页面的js中不可用，取出来的值都是初始值；\n- 使用getApp共享全局变量；\n\n","source":"doc/cookbook/全局变量.md","raw":"在使用的过程中，我的全局js 变量在app端总是被重置。在ios和Android上面都有过测试。在mp和H5上可以正常使用。\n\n```\nexport const tokenInfo = {\n\taccess: null,\n\taccessTime: null,\n\trefresh: null,\n\trefreshTime: null\n}\n```\n\n我从storage中获取保存的aceess/refresh等信息，然后放入tokenInfo中，接下来我就利用tokenInfo进行请求测试，接下来的请求中往往第一个请求能够获取到tokenInfo，第二个请求获取tokenInfo的时候每一个item就都是空了。\n\n我有一个 请求库，请求库需要用到这个 tokenInfo，每一次请求都会检测 tokenInfo 是否过期，过期就刷新token，或者终止请求等。\n\n因为vuex中的actions引入了这个请求库，所以我暂时没有把 tokenInfo放入 vuex中，只是 用了 一个全局的js文件来存储。\n\n莫非我要放弃所有的actions，然后把 tokenInfo 放在 vuex中？\n\n而 store 在工具类 js中隔离，无法互通。\n\n# 总结\n- 全局js变量，在nvue中不可用，会被重置；\n- store/vuex在非mixin或者页面的js中不可用，取出来的值都是初始值；\n- 使用getApp共享全局变量；\n\n","date":"2020-07-17T06:19:19.281Z","updated":"2020-07-17T06:19:19.281Z","path":"doc/cookbook/全局变量.html","title":"","comments":1,"layout":"page","_id":"ckcwngnjm000o9lxk5y07iw0j","content":"<p>在使用的过程中，我的全局js 变量在app端总是被重置。在ios和Android上面都有过测试。在mp和H5上可以正常使用。</p>\n<pre><code class=\"hljs undefined\">export const tokenInfo = &#123;\n\taccess: null,\n\taccessTime: null,\n\trefresh: null,\n\trefreshTime: null\n&#125;</code></pre>\n<p>我从storage中获取保存的aceess/refresh等信息，然后放入tokenInfo中，接下来我就利用tokenInfo进行请求测试，接下来的请求中往往第一个请求能够获取到tokenInfo，第二个请求获取tokenInfo的时候每一个item就都是空了。</p>\n<p>我有一个 请求库，请求库需要用到这个 tokenInfo，每一次请求都会检测 tokenInfo 是否过期，过期就刷新token，或者终止请求等。</p>\n<p>因为vuex中的actions引入了这个请求库，所以我暂时没有把 tokenInfo放入 vuex中，只是 用了 一个全局的js文件来存储。</p>\n<p>莫非我要放弃所有的actions，然后把 tokenInfo 放在 vuex中？</p>\n<p>而 store 在工具类 js中隔离，无法互通。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>全局js变量，在nvue中不可用，会被重置；</li>\n<li>store/vuex在非mixin或者页面的js中不可用，取出来的值都是初始值；</li>\n<li>使用getApp共享全局变量；</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用的过程中，我的全局js 变量在app端总是被重置。在ios和Android上面都有过测试。在mp和H5上可以正常使用。</p>\n<pre><code class=\"hljs undefined\">export const tokenInfo = &#123;\n\taccess: null,\n\taccessTime: null,\n\trefresh: null,\n\trefreshTime: null\n&#125;</code></pre>\n<p>我从storage中获取保存的aceess/refresh等信息，然后放入tokenInfo中，接下来我就利用tokenInfo进行请求测试，接下来的请求中往往第一个请求能够获取到tokenInfo，第二个请求获取tokenInfo的时候每一个item就都是空了。</p>\n<p>我有一个 请求库，请求库需要用到这个 tokenInfo，每一次请求都会检测 tokenInfo 是否过期，过期就刷新token，或者终止请求等。</p>\n<p>因为vuex中的actions引入了这个请求库，所以我暂时没有把 tokenInfo放入 vuex中，只是 用了 一个全局的js文件来存储。</p>\n<p>莫非我要放弃所有的actions，然后把 tokenInfo 放在 vuex中？</p>\n<p>而 store 在工具类 js中隔离，无法互通。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>全局js变量，在nvue中不可用，会被重置；</li>\n<li>store/vuex在非mixin或者页面的js中不可用，取出来的值都是初始值；</li>\n<li>使用getApp共享全局变量；</li>\n</ul>\n"},{"_content":"```\n<template>\n\t<myp-popup pos=\"left\" :show=\"show\" width=\"636\" :height=\"heightRpx\" :offset=\"114\" @overlayClicked=\"toCancel\">\n\t\t<view :style=\"mypContentHeightStyle\">\n\t\t\t<myp-navbar bgType=\"none\"></myp-navbar>\n\t\t\t<view style=\"height: 12rpx;\"></view>\n\t\t\t<view class=\"ap\">\n\t\t\t\t<view class=\"ap-head\">\n\t\t\t\t\t<text class=\"ap-title\">{{name}}</text>\n\t\t\t\t</view>\n\t\t\t\t<myp-scroll ref=\"myp-list\" bgType=\"inverse\" :extra=\"82\" @inited=\"toInit\" @down=\"toLoadItems\" @up=\"toLoadItems\" boxStyle=\"flex: 1; width: 636rpx;\" width=\"636rpx\">\n\t\t\t\t\t<view class=\"ap-item\">\n\t\t\t\t\t\t<circle-cell-small v-for=\"(s,index) in items\" :key=\"index\" :item=\"s\" @select=\"toSelect\"></circle-cell-small>\n\t\t\t\t\t</view>\n\t\t\t\t</myp-scroll>\n\t\t\t\t<view class=\"ap-close\">\n\t\t\t\t\t<myp-button text=\"关闭\" border=\"none\" radius=\"ll\" textType=\"inverse\" boxStyle=\"width:166rpx;height:62rpx;background-color: #262626;\" @buttonClicked=\"toCancel\"></myp-button>\n\t\t\t\t</view>\n\t\t\t</view>\n\t\t</view>\n\t</myp-popup>\n</template>\n```\n\n我们知道在popup里面的内容受v-if控制，正常来说，每一次打开都会created，但是在微信小程序端，我们发现，v-if控制的内容，也会第一时间created，v-if变化不会引起created，也就是和正常元素一样，只会created一次，其它不会变化。\n\n所以如果我们想利用created来刷新数据的话，那就需要注意，微信小程序端尽管有v-if变化，但是也只是created一次，而且created的时候时机并不是我们想象的那样v-if为true的第一次，而是和正常元素一样created，这个时候他的props不一定是我们需要的。\n\n因为外部的环境并不适合v-if为true的情况。\n\n所以，我们往往在微信小程序端需要watch show。\n\n","source":"doc/cookbook/小程序created注意.md","raw":"```\n<template>\n\t<myp-popup pos=\"left\" :show=\"show\" width=\"636\" :height=\"heightRpx\" :offset=\"114\" @overlayClicked=\"toCancel\">\n\t\t<view :style=\"mypContentHeightStyle\">\n\t\t\t<myp-navbar bgType=\"none\"></myp-navbar>\n\t\t\t<view style=\"height: 12rpx;\"></view>\n\t\t\t<view class=\"ap\">\n\t\t\t\t<view class=\"ap-head\">\n\t\t\t\t\t<text class=\"ap-title\">{{name}}</text>\n\t\t\t\t</view>\n\t\t\t\t<myp-scroll ref=\"myp-list\" bgType=\"inverse\" :extra=\"82\" @inited=\"toInit\" @down=\"toLoadItems\" @up=\"toLoadItems\" boxStyle=\"flex: 1; width: 636rpx;\" width=\"636rpx\">\n\t\t\t\t\t<view class=\"ap-item\">\n\t\t\t\t\t\t<circle-cell-small v-for=\"(s,index) in items\" :key=\"index\" :item=\"s\" @select=\"toSelect\"></circle-cell-small>\n\t\t\t\t\t</view>\n\t\t\t\t</myp-scroll>\n\t\t\t\t<view class=\"ap-close\">\n\t\t\t\t\t<myp-button text=\"关闭\" border=\"none\" radius=\"ll\" textType=\"inverse\" boxStyle=\"width:166rpx;height:62rpx;background-color: #262626;\" @buttonClicked=\"toCancel\"></myp-button>\n\t\t\t\t</view>\n\t\t\t</view>\n\t\t</view>\n\t</myp-popup>\n</template>\n```\n\n我们知道在popup里面的内容受v-if控制，正常来说，每一次打开都会created，但是在微信小程序端，我们发现，v-if控制的内容，也会第一时间created，v-if变化不会引起created，也就是和正常元素一样，只会created一次，其它不会变化。\n\n所以如果我们想利用created来刷新数据的话，那就需要注意，微信小程序端尽管有v-if变化，但是也只是created一次，而且created的时候时机并不是我们想象的那样v-if为true的第一次，而是和正常元素一样created，这个时候他的props不一定是我们需要的。\n\n因为外部的环境并不适合v-if为true的情况。\n\n所以，我们往往在微信小程序端需要watch show。\n\n","date":"2020-07-17T06:19:19.282Z","updated":"2020-07-17T06:19:19.282Z","path":"doc/cookbook/小程序created注意.html","title":"","comments":1,"layout":"page","_id":"ckcwngnjm000p9lxkooe5mhdl","content":"<pre><code class=\"hljs undefined\">&lt;template&gt;\n\t&lt;myp-popup pos=&quot;left&quot; :show=&quot;show&quot; width=&quot;636&quot; :height=&quot;heightRpx&quot; :offset=&quot;114&quot; @overlayClicked=&quot;toCancel&quot;&gt;\n\t\t&lt;view :style=&quot;mypContentHeightStyle&quot;&gt;\n\t\t\t&lt;myp-navbar bgType=&quot;none&quot;&gt;&lt;/myp-navbar&gt;\n\t\t\t&lt;view style=&quot;height: 12rpx;&quot;&gt;&lt;/view&gt;\n\t\t\t&lt;view class=&quot;ap&quot;&gt;\n\t\t\t\t&lt;view class=&quot;ap-head&quot;&gt;\n\t\t\t\t\t&lt;text class=&quot;ap-title&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt;\n\t\t\t\t&lt;/view&gt;\n\t\t\t\t&lt;myp-scroll ref=&quot;myp-list&quot; bgType=&quot;inverse&quot; :extra=&quot;82&quot; @inited=&quot;toInit&quot; @down=&quot;toLoadItems&quot; @up=&quot;toLoadItems&quot; boxStyle=&quot;flex: 1; width: 636rpx;&quot; width=&quot;636rpx&quot;&gt;\n\t\t\t\t\t&lt;view class=&quot;ap-item&quot;&gt;\n\t\t\t\t\t\t&lt;circle-cell-small v-for=&quot;(s,index) in items&quot; :key=&quot;index&quot; :item=&quot;s&quot; @select=&quot;toSelect&quot;&gt;&lt;/circle-cell-small&gt;\n\t\t\t\t\t&lt;/view&gt;\n\t\t\t\t&lt;/myp-scroll&gt;\n\t\t\t\t&lt;view class=&quot;ap-close&quot;&gt;\n\t\t\t\t\t&lt;myp-button text=&quot;关闭&quot; border=&quot;none&quot; radius=&quot;ll&quot; textType=&quot;inverse&quot; boxStyle=&quot;width:166rpx;height:62rpx;background-color: #262626;&quot; @buttonClicked=&quot;toCancel&quot;&gt;&lt;/myp-button&gt;\n\t\t\t\t&lt;/view&gt;\n\t\t\t&lt;/view&gt;\n\t\t&lt;/view&gt;\n\t&lt;/myp-popup&gt;\n&lt;/template&gt;</code></pre>\n<p>我们知道在popup里面的内容受v-if控制，正常来说，每一次打开都会created，但是在微信小程序端，我们发现，v-if控制的内容，也会第一时间created，v-if变化不会引起created，也就是和正常元素一样，只会created一次，其它不会变化。</p>\n<p>所以如果我们想利用created来刷新数据的话，那就需要注意，微信小程序端尽管有v-if变化，但是也只是created一次，而且created的时候时机并不是我们想象的那样v-if为true的第一次，而是和正常元素一样created，这个时候他的props不一定是我们需要的。</p>\n<p>因为外部的环境并不适合v-if为true的情况。</p>\n<p>所以，我们往往在微信小程序端需要watch show。</p>\n","site":{"data":{}},"excerpt":"","more":"<pre><code class=\"hljs undefined\">&lt;template&gt;\n\t&lt;myp-popup pos=&quot;left&quot; :show=&quot;show&quot; width=&quot;636&quot; :height=&quot;heightRpx&quot; :offset=&quot;114&quot; @overlayClicked=&quot;toCancel&quot;&gt;\n\t\t&lt;view :style=&quot;mypContentHeightStyle&quot;&gt;\n\t\t\t&lt;myp-navbar bgType=&quot;none&quot;&gt;&lt;/myp-navbar&gt;\n\t\t\t&lt;view style=&quot;height: 12rpx;&quot;&gt;&lt;/view&gt;\n\t\t\t&lt;view class=&quot;ap&quot;&gt;\n\t\t\t\t&lt;view class=&quot;ap-head&quot;&gt;\n\t\t\t\t\t&lt;text class=&quot;ap-title&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt;\n\t\t\t\t&lt;/view&gt;\n\t\t\t\t&lt;myp-scroll ref=&quot;myp-list&quot; bgType=&quot;inverse&quot; :extra=&quot;82&quot; @inited=&quot;toInit&quot; @down=&quot;toLoadItems&quot; @up=&quot;toLoadItems&quot; boxStyle=&quot;flex: 1; width: 636rpx;&quot; width=&quot;636rpx&quot;&gt;\n\t\t\t\t\t&lt;view class=&quot;ap-item&quot;&gt;\n\t\t\t\t\t\t&lt;circle-cell-small v-for=&quot;(s,index) in items&quot; :key=&quot;index&quot; :item=&quot;s&quot; @select=&quot;toSelect&quot;&gt;&lt;/circle-cell-small&gt;\n\t\t\t\t\t&lt;/view&gt;\n\t\t\t\t&lt;/myp-scroll&gt;\n\t\t\t\t&lt;view class=&quot;ap-close&quot;&gt;\n\t\t\t\t\t&lt;myp-button text=&quot;关闭&quot; border=&quot;none&quot; radius=&quot;ll&quot; textType=&quot;inverse&quot; boxStyle=&quot;width:166rpx;height:62rpx;background-color: #262626;&quot; @buttonClicked=&quot;toCancel&quot;&gt;&lt;/myp-button&gt;\n\t\t\t\t&lt;/view&gt;\n\t\t\t&lt;/view&gt;\n\t\t&lt;/view&gt;\n\t&lt;/myp-popup&gt;\n&lt;/template&gt;</code></pre>\n<p>我们知道在popup里面的内容受v-if控制，正常来说，每一次打开都会created，但是在微信小程序端，我们发现，v-if控制的内容，也会第一时间created，v-if变化不会引起created，也就是和正常元素一样，只会created一次，其它不会变化。</p>\n<p>所以如果我们想利用created来刷新数据的话，那就需要注意，微信小程序端尽管有v-if变化，但是也只是created一次，而且created的时候时机并不是我们想象的那样v-if为true的第一次，而是和正常元素一样created，这个时候他的props不一定是我们需要的。</p>\n<p>因为外部的环境并不适合v-if为true的情况。</p>\n<p>所以，我们往往在微信小程序端需要watch show。</p>\n"},{"_content":"有时候我们发现，我们使用v-for渲染一系列组件的时候，在某些端高度全部是一样的，实际上每个具体的组件的高度是不一样的，会根据实际内容而定。\n\n为什么会出现这种情况？\n\n很有可能是在当前平台高度计算的问题，所以我们可以试着给那个高度计算有问题的地方明确限制宽度。\n\n比如text，多行text的时候，如果高度是不确定的，而出现高度并不适应的情况时，我们检查一下text的宽度是不是真的有规定。\n\n","source":"doc/cookbook/组件自适应高度的问题.md","raw":"有时候我们发现，我们使用v-for渲染一系列组件的时候，在某些端高度全部是一样的，实际上每个具体的组件的高度是不一样的，会根据实际内容而定。\n\n为什么会出现这种情况？\n\n很有可能是在当前平台高度计算的问题，所以我们可以试着给那个高度计算有问题的地方明确限制宽度。\n\n比如text，多行text的时候，如果高度是不确定的，而出现高度并不适应的情况时，我们检查一下text的宽度是不是真的有规定。\n\n","date":"2020-07-17T06:19:19.261Z","updated":"2020-07-17T06:19:19.260Z","path":"doc/cookbook/组件自适应高度的问题.html","title":"","comments":1,"layout":"page","_id":"ckcwngnjn000q9lxk0yayyt59","content":"<p>有时候我们发现，我们使用v-for渲染一系列组件的时候，在某些端高度全部是一样的，实际上每个具体的组件的高度是不一样的，会根据实际内容而定。</p>\n<p>为什么会出现这种情况？</p>\n<p>很有可能是在当前平台高度计算的问题，所以我们可以试着给那个高度计算有问题的地方明确限制宽度。</p>\n<p>比如text，多行text的时候，如果高度是不确定的，而出现高度并不适应的情况时，我们检查一下text的宽度是不是真的有规定。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>有时候我们发现，我们使用v-for渲染一系列组件的时候，在某些端高度全部是一样的，实际上每个具体的组件的高度是不一样的，会根据实际内容而定。</p>\n<p>为什么会出现这种情况？</p>\n<p>很有可能是在当前平台高度计算的问题，所以我们可以试着给那个高度计算有问题的地方明确限制宽度。</p>\n<p>比如text，多行text的时候，如果高度是不确定的，而出现高度并不适应的情况时，我们检查一下text的宽度是不是真的有规定。</p>\n"},{"title":"设计规范","type":"guide","order":7,"_content":"\n","source":"doc/guide/design.md","raw":"---\ntitle: 设计规范\ntype: guide\norder: 7\n---\n\n","date":"2020-07-17T12:08:01.261Z","updated":"2020-07-17T12:08:01.261Z","path":"doc/guide/design.html","comments":1,"layout":"page","_id":"ckcwngnjn000r9lxkwswl2fmk","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"常见问题","type":"guide","order":802,"_content":"","source":"doc/guide/faq.md","raw":"---\ntitle: 常见问题\ntype: guide\norder: 802\n---\n","date":"2020-07-17T06:02:20.652Z","updated":"2020-07-17T06:02:20.652Z","path":"doc/guide/faq.html","comments":1,"layout":"page","_id":"ckcwngnjo000s9lxkrix19hyc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Search Vue.js","type":"search","search":true,"_content":"","source":"doc/search/index.md","raw":"---\ntitle: Search Vue.js\ntype: search\nsearch: true\n---","date":"2020-07-17T00:59:28.977Z","updated":"2020-07-17T00:59:28.977Z","path":"doc/search/index.html","comments":1,"layout":"page","_id":"ckcwngnjo000t9lxkpevhffrf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"全局视野","type":"guide","order":3,"_content":"\n为了让您更加深入的理解mypUI，以及更加高效的使用，我们特意从设计者的角度来解读mypUI。或者您也可以把这篇全局视野当作是我们建议的最佳实践。希望对您有用。祝您使用愉快。\n\n\n","source":"doc/guide/global.md","raw":"---\ntitle: 全局视野\ntype: guide\norder: 3\n---\n\n为了让您更加深入的理解mypUI，以及更加高效的使用，我们特意从设计者的角度来解读mypUI。或者您也可以把这篇全局视野当作是我们建议的最佳实践。希望对您有用。祝您使用愉快。\n\n\n","date":"2020-07-21T13:16:10.005Z","updated":"2020-07-21T13:16:10.005Z","path":"doc/guide/global.html","comments":1,"layout":"page","_id":"ckcwngnjo000u9lxkec7ewvx3","content":"<p>为了让您更加深入的理解mypUI，以及更加高效的使用，我们特意从设计者的角度来解读mypUI。或者您也可以把这篇全局视野当作是我们建议的最佳实践。希望对您有用。祝您使用愉快。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>为了让您更加深入的理解mypUI，以及更加高效的使用，我们特意从设计者的角度来解读mypUI。或者您也可以把这篇全局视野当作是我们建议的最佳实践。希望对您有用。祝您使用愉快。</p>\n"},{"title":"快速上手","type":"guide","order":2,"_content":"\nmypUI 是基于 uniapp 的一套组件库与工具集，可以 **高效且规范** 地开发出 uniapp 支持的各端应用（APP/各家小程序/H5/快应用）。兼容 nvue 页面 和 vue 页面。nvue 页面对应的 app端 依托 weex 编译为原生，具备良好的性能与体验。mypUI 绝对能为您带来 **稳定、高效、规范** 的开发体验。\n\n## 集成mypUI\n\n### 拷贝UI组件\n\n直接将`mypUI`放在您的项目根目录下。\n\n### 复制UI的静态资源\n\n`loadingSrc`等公用静态资源直接使用了示范UI项目中 `/static/ui` 下面的静态文件，没有使用网络图片，所以需要拷贝到自己的项目下（`/static/ui`这个路径还是需要保持一致的）。\n\n静态文件的路径依然保持和示范项目中一致即可也就是依然是 `/static/ui` 路径。\n\n### 使css生效\n\n为了减少包体积，UI内使用了 `全局css` 。您需要在 `app.vue` 里面引入 `mypUI` 中的 `base.scss`。\n\n也就是：\n\n``` html\n<style lang=\"scss\">\n\t@import '@/mypUI/base.scss';\n</style>\n```\n\n因为使用了 `scss变量`，记得设置 `style` 的 `lang=\"scss\"`。\n\n### 配置 `easycom`\n\nUI内部使用了 `easycom` 的组件自动引入，所以您必须在项目中开启 `easycom`。\n\n在 `pages.json` 中添加如下代码：\n\n```js\n\"easycom\": {\n\t\"autoscan\": true,\n\t\"custom\": {\n\t\t\"myp-(.*)\": \"@/mypUI/myp-$1/myp-$1.vue\" // 匹配mypUI内的vue文件\n\t}\n}\n```\n\n> easycom 是什么？请看官方文档 [easycom](https://uniapp.dcloud.io/collocation/pages?id=easycom)\n\n### 定义您的 UI 主题\n\n`mypUI` 下的 `mypui.scss` 是主题 `scss变量` 定义文件。您需要根据您的项目UI的主题色对其进行修改。\n\n如果主题内定义的变量无法满足您的要求，您可以在里面进行添加，并适当在 `base.scss` 里面增加相应的 `class` 即可。\n\n关于主题的具体说明与使用，请查阅 [主题](/doc/guide/theme.html)。\n\n如果您需要用到主题内定义的`scss变量`，一定要记得在使用的地方引入`mypui.scss`，否则编译会报错。\n\n```html\n<style lang=\"scss\">\n\t@import '@/mypUI/mypui.scss';\n</style>\n```\n\n<p class=\"tip\">注意：在 app.vue 里面全局引入 mypui.scss 是不会起作用的。毕竟里面只是定义了一些 scss变量</p>\n\n### 初始化系统变量\n\n我们建议您在 `onLaunch` 里面对系统变量进行初始化（当然，这是可选的，`mypUI` 内部接口会根据需要调用初始化的接口）。\n\n初始化代码如下：\n\n- 先引入并放入mixins；\n\n- 然后调用初始化方法；\n\n```html\n<script>\n\timport systemMixin from '@/mypUI/myp-mixin/systemMixin.js'\n\t\n\texport default {\n\t\tglobalData: {\n\t\t\tcurrentTab: 0\n\t\t},\n\t\tmixins: [systemMixin],\n\t\tonLaunch: function() {\n\t\t\tconsole.log('App Launch')\n\t\t\t// #ifdef APP-NVUE || H5\n\t\t\tthis.mypInitSystemInfo()\n\t\t\t// #endif\n\t\t\t// #ifndef APP-NVUE || H5\n\t\t\tsetTimeout(()=>{\n\t\t\t\tthis.mypInitSystemInfo()\n\t\t\t}, 0)\n\t\t\t// #endif\n\t\t},\n\t\tonShow: function() {\n\t\t\tconsole.log('App Show')\n\t\t},\n\t\tonHide: function() {\n\t\t\tconsole.log('App Hide')\n\t\t}\n\t}\n</script>\n\n<style lang=\"scss\">\n\t@import '@/mypUI/base.scss';\n</style>\n```\n\n### 现在开始愉快的使用吧\n\n自由且无需手动导入 `mypUI` 的使用方式，正式开始。\n\n祝您使用愉快。\n\n<p class=\"tip\">如果在使用的过程中，您发现有任何不如意或者bug存在，敬请联系我们，或者给出您的宝贵意见。当然，您也可以给出您的实现方式。或者给我们提一个 <a href=\"https://github.com/wakaryry/mypUI\">pr</a></p>\n\n## 找到代码与我们\n\n- [mypUI-github](https://github.com/wakaryry/mypUI) 欢迎star\n\n- [mypUI-uniapp插件市场](https://ext.dcloud.net.cn/plugin?id=2190) 需要您的好评\n\n- [mypUI-文档开源](https://github.com/wakaryry/mypui-doc)\n\n- [mypUI-文档地址](https://www.mypui.cn)\n\n- 作者wx：`pptpdf`\n\n- 作者qq：`382006503`\n\n- 欢迎加入wx群和qq群。wx群请加wx，qq群请加qq群号：`306797275`\n\n<p class=\"tip\">强烈建议加入wx与qq群，获取更多mypUI的动态与帮助</p>\n\n## 快速体验\n\n- 安装HBuilderX；\n- 下载或者clone本UI库；\n- 在HBuilderX里面打开或者导入；\n- 运行到自己想要体验的平台即可；\n\n<p class=\"tip\">想了解我们是怎么使用 mypUI 的吗？又如何对 mypUI 有一个更加全面的了解？或者说站在一个代码设计者的角度去了解 mypUI? 纵观全局，对你更加高效的使用mypUI非常有用。建议您一定要看看</p>\n\n<a class=\"button\" href=\"global.html\">全局视角了解mypUI</a>\n\n您可以配合 mypUI 的示范代码 来做更加深入的理解。\n","source":"doc/guide/index.md","raw":"---\ntitle: 快速上手\ntype: guide\norder: 2\n---\n\nmypUI 是基于 uniapp 的一套组件库与工具集，可以 **高效且规范** 地开发出 uniapp 支持的各端应用（APP/各家小程序/H5/快应用）。兼容 nvue 页面 和 vue 页面。nvue 页面对应的 app端 依托 weex 编译为原生，具备良好的性能与体验。mypUI 绝对能为您带来 **稳定、高效、规范** 的开发体验。\n\n## 集成mypUI\n\n### 拷贝UI组件\n\n直接将`mypUI`放在您的项目根目录下。\n\n### 复制UI的静态资源\n\n`loadingSrc`等公用静态资源直接使用了示范UI项目中 `/static/ui` 下面的静态文件，没有使用网络图片，所以需要拷贝到自己的项目下（`/static/ui`这个路径还是需要保持一致的）。\n\n静态文件的路径依然保持和示范项目中一致即可也就是依然是 `/static/ui` 路径。\n\n### 使css生效\n\n为了减少包体积，UI内使用了 `全局css` 。您需要在 `app.vue` 里面引入 `mypUI` 中的 `base.scss`。\n\n也就是：\n\n``` html\n<style lang=\"scss\">\n\t@import '@/mypUI/base.scss';\n</style>\n```\n\n因为使用了 `scss变量`，记得设置 `style` 的 `lang=\"scss\"`。\n\n### 配置 `easycom`\n\nUI内部使用了 `easycom` 的组件自动引入，所以您必须在项目中开启 `easycom`。\n\n在 `pages.json` 中添加如下代码：\n\n```js\n\"easycom\": {\n\t\"autoscan\": true,\n\t\"custom\": {\n\t\t\"myp-(.*)\": \"@/mypUI/myp-$1/myp-$1.vue\" // 匹配mypUI内的vue文件\n\t}\n}\n```\n\n> easycom 是什么？请看官方文档 [easycom](https://uniapp.dcloud.io/collocation/pages?id=easycom)\n\n### 定义您的 UI 主题\n\n`mypUI` 下的 `mypui.scss` 是主题 `scss变量` 定义文件。您需要根据您的项目UI的主题色对其进行修改。\n\n如果主题内定义的变量无法满足您的要求，您可以在里面进行添加，并适当在 `base.scss` 里面增加相应的 `class` 即可。\n\n关于主题的具体说明与使用，请查阅 [主题](/doc/guide/theme.html)。\n\n如果您需要用到主题内定义的`scss变量`，一定要记得在使用的地方引入`mypui.scss`，否则编译会报错。\n\n```html\n<style lang=\"scss\">\n\t@import '@/mypUI/mypui.scss';\n</style>\n```\n\n<p class=\"tip\">注意：在 app.vue 里面全局引入 mypui.scss 是不会起作用的。毕竟里面只是定义了一些 scss变量</p>\n\n### 初始化系统变量\n\n我们建议您在 `onLaunch` 里面对系统变量进行初始化（当然，这是可选的，`mypUI` 内部接口会根据需要调用初始化的接口）。\n\n初始化代码如下：\n\n- 先引入并放入mixins；\n\n- 然后调用初始化方法；\n\n```html\n<script>\n\timport systemMixin from '@/mypUI/myp-mixin/systemMixin.js'\n\t\n\texport default {\n\t\tglobalData: {\n\t\t\tcurrentTab: 0\n\t\t},\n\t\tmixins: [systemMixin],\n\t\tonLaunch: function() {\n\t\t\tconsole.log('App Launch')\n\t\t\t// #ifdef APP-NVUE || H5\n\t\t\tthis.mypInitSystemInfo()\n\t\t\t// #endif\n\t\t\t// #ifndef APP-NVUE || H5\n\t\t\tsetTimeout(()=>{\n\t\t\t\tthis.mypInitSystemInfo()\n\t\t\t}, 0)\n\t\t\t// #endif\n\t\t},\n\t\tonShow: function() {\n\t\t\tconsole.log('App Show')\n\t\t},\n\t\tonHide: function() {\n\t\t\tconsole.log('App Hide')\n\t\t}\n\t}\n</script>\n\n<style lang=\"scss\">\n\t@import '@/mypUI/base.scss';\n</style>\n```\n\n### 现在开始愉快的使用吧\n\n自由且无需手动导入 `mypUI` 的使用方式，正式开始。\n\n祝您使用愉快。\n\n<p class=\"tip\">如果在使用的过程中，您发现有任何不如意或者bug存在，敬请联系我们，或者给出您的宝贵意见。当然，您也可以给出您的实现方式。或者给我们提一个 <a href=\"https://github.com/wakaryry/mypUI\">pr</a></p>\n\n## 找到代码与我们\n\n- [mypUI-github](https://github.com/wakaryry/mypUI) 欢迎star\n\n- [mypUI-uniapp插件市场](https://ext.dcloud.net.cn/plugin?id=2190) 需要您的好评\n\n- [mypUI-文档开源](https://github.com/wakaryry/mypui-doc)\n\n- [mypUI-文档地址](https://www.mypui.cn)\n\n- 作者wx：`pptpdf`\n\n- 作者qq：`382006503`\n\n- 欢迎加入wx群和qq群。wx群请加wx，qq群请加qq群号：`306797275`\n\n<p class=\"tip\">强烈建议加入wx与qq群，获取更多mypUI的动态与帮助</p>\n\n## 快速体验\n\n- 安装HBuilderX；\n- 下载或者clone本UI库；\n- 在HBuilderX里面打开或者导入；\n- 运行到自己想要体验的平台即可；\n\n<p class=\"tip\">想了解我们是怎么使用 mypUI 的吗？又如何对 mypUI 有一个更加全面的了解？或者说站在一个代码设计者的角度去了解 mypUI? 纵观全局，对你更加高效的使用mypUI非常有用。建议您一定要看看</p>\n\n<a class=\"button\" href=\"global.html\">全局视角了解mypUI</a>\n\n您可以配合 mypUI 的示范代码 来做更加深入的理解。\n","date":"2020-07-22T02:58:25.608Z","updated":"2020-07-22T02:58:25.608Z","path":"doc/guide/index.html","_id":"ckcwngnjp000v9lxkyzrla44s","comments":1,"layout":"page","content":"<p>mypUI 是基于 uniapp 的一套组件库与工具集，可以 <strong>高效且规范</strong> 地开发出 uniapp 支持的各端应用（APP/各家小程序/H5/快应用）。兼容 nvue 页面 和 vue 页面。nvue 页面对应的 app端 依托 weex 编译为原生，具备良好的性能与体验。mypUI 绝对能为您带来 <strong>稳定、高效、规范</strong> 的开发体验。</p>\n<h2 id=\"集成mypUI\"><a href=\"#集成mypUI\" class=\"headerlink\" title=\"集成mypUI\"></a>集成mypUI</h2><h3 id=\"拷贝UI组件\"><a href=\"#拷贝UI组件\" class=\"headerlink\" title=\"拷贝UI组件\"></a>拷贝UI组件</h3><p>直接将<code>mypUI</code>放在您的项目根目录下。</p>\n<h3 id=\"复制UI的静态资源\"><a href=\"#复制UI的静态资源\" class=\"headerlink\" title=\"复制UI的静态资源\"></a>复制UI的静态资源</h3><p><code>loadingSrc</code>等公用静态资源直接使用了示范UI项目中 <code>/static/ui</code> 下面的静态文件，没有使用网络图片，所以需要拷贝到自己的项目下（<code>/static/ui</code>这个路径还是需要保持一致的）。</p>\n<p>静态文件的路径依然保持和示范项目中一致即可也就是依然是 <code>/static/ui</code> 路径。</p>\n<h3 id=\"使css生效\"><a href=\"#使css生效\" class=\"headerlink\" title=\"使css生效\"></a>使css生效</h3><p>为了减少包体积，UI内使用了 <code>全局css</code> 。您需要在 <code>app.vue</code> 里面引入 <code>mypUI</code> 中的 <code>base.scss</code>。</p>\n<p>也就是：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"scss\"</span>&gt;</span>\n\t@import '@/mypUI/base.scss';\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p>因为使用了 <code>scss变量</code>，记得设置 <code>style</code> 的 <code>lang=&quot;scss&quot;</code>。</p>\n<h3 id=\"配置-easycom\"><a href=\"#配置-easycom\" class=\"headerlink\" title=\"配置 easycom\"></a>配置 <code>easycom</code></h3><p>UI内部使用了 <code>easycom</code> 的组件自动引入，所以您必须在项目中开启 <code>easycom</code>。</p>\n<p>在 <code>pages.json</code> 中添加如下代码：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-string\">\"easycom\"</span>: &#123;\n\t<span class=\"hljs-string\">\"autoscan\"</span>: <span class=\"hljs-literal\">true</span>,\n\t<span class=\"hljs-string\">\"custom\"</span>: &#123;\n\t\t<span class=\"hljs-string\">\"myp-(.*)\"</span>: <span class=\"hljs-string\">\"@/mypUI/myp-$1/myp-$1.vue\"</span> <span class=\"hljs-comment\">// 匹配mypUI内的vue文件</span>\n\t&#125;\n&#125;</code></pre>\n<blockquote>\n<p>easycom 是什么？请看官方文档 <a href=\"https://uniapp.dcloud.io/collocation/pages?id=easycom\" target=\"_blank\" rel=\"noopener\">easycom</a></p>\n</blockquote>\n<h3 id=\"定义您的-UI-主题\"><a href=\"#定义您的-UI-主题\" class=\"headerlink\" title=\"定义您的 UI 主题\"></a>定义您的 UI 主题</h3><p><code>mypUI</code> 下的 <code>mypui.scss</code> 是主题 <code>scss变量</code> 定义文件。您需要根据您的项目UI的主题色对其进行修改。</p>\n<p>如果主题内定义的变量无法满足您的要求，您可以在里面进行添加，并适当在 <code>base.scss</code> 里面增加相应的 <code>class</code> 即可。</p>\n<p>关于主题的具体说明与使用，请查阅 <a href=\"/doc/guide/theme.html\">主题</a>。</p>\n<p>如果您需要用到主题内定义的<code>scss变量</code>，一定要记得在使用的地方引入<code>mypui.scss</code>，否则编译会报错。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"scss\"</span>&gt;</span>\n\t@import '@/mypUI/mypui.scss';\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p class=\"tip\">注意：在 app.vue 里面全局引入 mypui.scss 是不会起作用的。毕竟里面只是定义了一些 scss变量</p>\n\n<h3 id=\"初始化系统变量\"><a href=\"#初始化系统变量\" class=\"headerlink\" title=\"初始化系统变量\"></a>初始化系统变量</h3><p>我们建议您在 <code>onLaunch</code> 里面对系统变量进行初始化（当然，这是可选的，<code>mypUI</code> 内部接口会根据需要调用初始化的接口）。</p>\n<p>初始化代码如下：</p>\n<ul>\n<li><p>先引入并放入mixins；</p>\n</li>\n<li><p>然后调用初始化方法；</p>\n</li>\n</ul>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> systemMixin <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/mypUI/myp-mixin/systemMixin.js'</span>\n\t\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n\t\t<span class=\"hljs-attr\">globalData</span>: &#123;\n\t\t\t<span class=\"hljs-attr\">currentTab</span>: <span class=\"hljs-number\">0</span>\n\t\t&#125;,\n\t\t<span class=\"hljs-attr\">mixins</span>: [systemMixin],\n\t\t<span class=\"hljs-attr\">onLaunch</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n\t\t\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'App Launch'</span>)\n\t\t\t<span class=\"hljs-comment\">// #ifdef APP-NVUE || H5</span>\n\t\t\t<span class=\"hljs-keyword\">this</span>.mypInitSystemInfo()\n\t\t\t<span class=\"hljs-comment\">// #endif</span>\n\t\t\t<span class=\"hljs-comment\">// #ifndef APP-NVUE || H5</span>\n\t\t\tsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;\n\t\t\t\t<span class=\"hljs-keyword\">this</span>.mypInitSystemInfo()\n\t\t\t&#125;, <span class=\"hljs-number\">0</span>)\n\t\t\t<span class=\"hljs-comment\">// #endif</span>\n\t\t&#125;,\n\t\t<span class=\"hljs-attr\">onShow</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n\t\t\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'App Show'</span>)\n\t\t&#125;,\n\t\t<span class=\"hljs-attr\">onHide</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n\t\t\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'App Hide'</span>)\n\t\t&#125;\n\t&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"scss\"</span>&gt;</span>\n\t@import '@/mypUI/base.scss';\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<h3 id=\"现在开始愉快的使用吧\"><a href=\"#现在开始愉快的使用吧\" class=\"headerlink\" title=\"现在开始愉快的使用吧\"></a>现在开始愉快的使用吧</h3><p>自由且无需手动导入 <code>mypUI</code> 的使用方式，正式开始。</p>\n<p>祝您使用愉快。</p>\n<p class=\"tip\">如果在使用的过程中，您发现有任何不如意或者bug存在，敬请联系我们，或者给出您的宝贵意见。当然，您也可以给出您的实现方式。或者给我们提一个 <a href=\"https://github.com/wakaryry/mypUI\" target=\"_blank\" rel=\"noopener\">pr</a></p>\n\n<h2 id=\"找到代码与我们\"><a href=\"#找到代码与我们\" class=\"headerlink\" title=\"找到代码与我们\"></a>找到代码与我们</h2><ul>\n<li><p><a href=\"https://github.com/wakaryry/mypUI\" target=\"_blank\" rel=\"noopener\">mypUI-github</a> 欢迎star</p>\n</li>\n<li><p><a href=\"https://ext.dcloud.net.cn/plugin?id=2190\" target=\"_blank\" rel=\"noopener\">mypUI-uniapp插件市场</a> 需要您的好评</p>\n</li>\n<li><p><a href=\"https://github.com/wakaryry/mypui-doc\" target=\"_blank\" rel=\"noopener\">mypUI-文档开源</a></p>\n</li>\n<li><p><a href=\"https://www.mypui.cn\" target=\"_blank\" rel=\"noopener\">mypUI-文档地址</a></p>\n</li>\n<li><p>作者wx：<code>pptpdf</code></p>\n</li>\n<li><p>作者qq：<code>382006503</code></p>\n</li>\n<li><p>欢迎加入wx群和qq群。wx群请加wx，qq群请加qq群号：<code>306797275</code></p>\n</li>\n</ul>\n<p class=\"tip\">强烈建议加入wx与qq群，获取更多mypUI的动态与帮助</p>\n\n<h2 id=\"快速体验\"><a href=\"#快速体验\" class=\"headerlink\" title=\"快速体验\"></a>快速体验</h2><ul>\n<li>安装HBuilderX；</li>\n<li>下载或者clone本UI库；</li>\n<li>在HBuilderX里面打开或者导入；</li>\n<li>运行到自己想要体验的平台即可；</li>\n</ul>\n<p class=\"tip\">想了解我们是怎么使用 mypUI 的吗？又如何对 mypUI 有一个更加全面的了解？或者说站在一个代码设计者的角度去了解 mypUI? 纵观全局，对你更加高效的使用mypUI非常有用。建议您一定要看看</p>\n\n<p><a class=\"button\" href=\"global.html\">全局视角了解mypUI</a></p>\n<p>您可以配合 mypUI 的示范代码 来做更加深入的理解。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>mypUI 是基于 uniapp 的一套组件库与工具集，可以 <strong>高效且规范</strong> 地开发出 uniapp 支持的各端应用（APP/各家小程序/H5/快应用）。兼容 nvue 页面 和 vue 页面。nvue 页面对应的 app端 依托 weex 编译为原生，具备良好的性能与体验。mypUI 绝对能为您带来 <strong>稳定、高效、规范</strong> 的开发体验。</p>\n<h2 id=\"集成mypUI\"><a href=\"#集成mypUI\" class=\"headerlink\" title=\"集成mypUI\"></a>集成mypUI</h2><h3 id=\"拷贝UI组件\"><a href=\"#拷贝UI组件\" class=\"headerlink\" title=\"拷贝UI组件\"></a>拷贝UI组件</h3><p>直接将<code>mypUI</code>放在您的项目根目录下。</p>\n<h3 id=\"复制UI的静态资源\"><a href=\"#复制UI的静态资源\" class=\"headerlink\" title=\"复制UI的静态资源\"></a>复制UI的静态资源</h3><p><code>loadingSrc</code>等公用静态资源直接使用了示范UI项目中 <code>/static/ui</code> 下面的静态文件，没有使用网络图片，所以需要拷贝到自己的项目下（<code>/static/ui</code>这个路径还是需要保持一致的）。</p>\n<p>静态文件的路径依然保持和示范项目中一致即可也就是依然是 <code>/static/ui</code> 路径。</p>\n<h3 id=\"使css生效\"><a href=\"#使css生效\" class=\"headerlink\" title=\"使css生效\"></a>使css生效</h3><p>为了减少包体积，UI内使用了 <code>全局css</code> 。您需要在 <code>app.vue</code> 里面引入 <code>mypUI</code> 中的 <code>base.scss</code>。</p>\n<p>也就是：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"scss\"</span>&gt;</span>\n\t@import '@/mypUI/base.scss';\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p>因为使用了 <code>scss变量</code>，记得设置 <code>style</code> 的 <code>lang=&quot;scss&quot;</code>。</p>\n<h3 id=\"配置-easycom\"><a href=\"#配置-easycom\" class=\"headerlink\" title=\"配置 easycom\"></a>配置 <code>easycom</code></h3><p>UI内部使用了 <code>easycom</code> 的组件自动引入，所以您必须在项目中开启 <code>easycom</code>。</p>\n<p>在 <code>pages.json</code> 中添加如下代码：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-string\">\"easycom\"</span>: &#123;\n\t<span class=\"hljs-string\">\"autoscan\"</span>: <span class=\"hljs-literal\">true</span>,\n\t<span class=\"hljs-string\">\"custom\"</span>: &#123;\n\t\t<span class=\"hljs-string\">\"myp-(.*)\"</span>: <span class=\"hljs-string\">\"@/mypUI/myp-$1/myp-$1.vue\"</span> <span class=\"hljs-comment\">// 匹配mypUI内的vue文件</span>\n\t&#125;\n&#125;</code></pre>\n<blockquote>\n<p>easycom 是什么？请看官方文档 <a href=\"https://uniapp.dcloud.io/collocation/pages?id=easycom\" target=\"_blank\" rel=\"noopener\">easycom</a></p>\n</blockquote>\n<h3 id=\"定义您的-UI-主题\"><a href=\"#定义您的-UI-主题\" class=\"headerlink\" title=\"定义您的 UI 主题\"></a>定义您的 UI 主题</h3><p><code>mypUI</code> 下的 <code>mypui.scss</code> 是主题 <code>scss变量</code> 定义文件。您需要根据您的项目UI的主题色对其进行修改。</p>\n<p>如果主题内定义的变量无法满足您的要求，您可以在里面进行添加，并适当在 <code>base.scss</code> 里面增加相应的 <code>class</code> 即可。</p>\n<p>关于主题的具体说明与使用，请查阅 <a href=\"/doc/guide/theme.html\">主题</a>。</p>\n<p>如果您需要用到主题内定义的<code>scss变量</code>，一定要记得在使用的地方引入<code>mypui.scss</code>，否则编译会报错。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"scss\"</span>&gt;</span>\n\t@import '@/mypUI/mypui.scss';\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p class=\"tip\">注意：在 app.vue 里面全局引入 mypui.scss 是不会起作用的。毕竟里面只是定义了一些 scss变量</p>\n\n<h3 id=\"初始化系统变量\"><a href=\"#初始化系统变量\" class=\"headerlink\" title=\"初始化系统变量\"></a>初始化系统变量</h3><p>我们建议您在 <code>onLaunch</code> 里面对系统变量进行初始化（当然，这是可选的，<code>mypUI</code> 内部接口会根据需要调用初始化的接口）。</p>\n<p>初始化代码如下：</p>\n<ul>\n<li><p>先引入并放入mixins；</p>\n</li>\n<li><p>然后调用初始化方法；</p>\n</li>\n</ul>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> systemMixin <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/mypUI/myp-mixin/systemMixin.js'</span>\n\t\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n\t\t<span class=\"hljs-attr\">globalData</span>: &#123;\n\t\t\t<span class=\"hljs-attr\">currentTab</span>: <span class=\"hljs-number\">0</span>\n\t\t&#125;,\n\t\t<span class=\"hljs-attr\">mixins</span>: [systemMixin],\n\t\t<span class=\"hljs-attr\">onLaunch</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n\t\t\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'App Launch'</span>)\n\t\t\t<span class=\"hljs-comment\">// #ifdef APP-NVUE || H5</span>\n\t\t\t<span class=\"hljs-keyword\">this</span>.mypInitSystemInfo()\n\t\t\t<span class=\"hljs-comment\">// #endif</span>\n\t\t\t<span class=\"hljs-comment\">// #ifndef APP-NVUE || H5</span>\n\t\t\tsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span>=&gt;</span>&#123;\n\t\t\t\t<span class=\"hljs-keyword\">this</span>.mypInitSystemInfo()\n\t\t\t&#125;, <span class=\"hljs-number\">0</span>)\n\t\t\t<span class=\"hljs-comment\">// #endif</span>\n\t\t&#125;,\n\t\t<span class=\"hljs-attr\">onShow</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n\t\t\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'App Show'</span>)\n\t\t&#125;,\n\t\t<span class=\"hljs-attr\">onHide</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n\t\t\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'App Hide'</span>)\n\t\t&#125;\n\t&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"scss\"</span>&gt;</span>\n\t@import '@/mypUI/base.scss';\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<h3 id=\"现在开始愉快的使用吧\"><a href=\"#现在开始愉快的使用吧\" class=\"headerlink\" title=\"现在开始愉快的使用吧\"></a>现在开始愉快的使用吧</h3><p>自由且无需手动导入 <code>mypUI</code> 的使用方式，正式开始。</p>\n<p>祝您使用愉快。</p>\n<p class=\"tip\">如果在使用的过程中，您发现有任何不如意或者bug存在，敬请联系我们，或者给出您的宝贵意见。当然，您也可以给出您的实现方式。或者给我们提一个 <a href=\"https://github.com/wakaryry/mypUI\" target=\"_blank\" rel=\"noopener\">pr</a></p>\n\n<h2 id=\"找到代码与我们\"><a href=\"#找到代码与我们\" class=\"headerlink\" title=\"找到代码与我们\"></a>找到代码与我们</h2><ul>\n<li><p><a href=\"https://github.com/wakaryry/mypUI\" target=\"_blank\" rel=\"noopener\">mypUI-github</a> 欢迎star</p>\n</li>\n<li><p><a href=\"https://ext.dcloud.net.cn/plugin?id=2190\" target=\"_blank\" rel=\"noopener\">mypUI-uniapp插件市场</a> 需要您的好评</p>\n</li>\n<li><p><a href=\"https://github.com/wakaryry/mypui-doc\" target=\"_blank\" rel=\"noopener\">mypUI-文档开源</a></p>\n</li>\n<li><p><a href=\"https://www.mypui.cn\" target=\"_blank\" rel=\"noopener\">mypUI-文档地址</a></p>\n</li>\n<li><p>作者wx：<code>pptpdf</code></p>\n</li>\n<li><p>作者qq：<code>382006503</code></p>\n</li>\n<li><p>欢迎加入wx群和qq群。wx群请加wx，qq群请加qq群号：<code>306797275</code></p>\n</li>\n</ul>\n<p class=\"tip\">强烈建议加入wx与qq群，获取更多mypUI的动态与帮助</p>\n\n<h2 id=\"快速体验\"><a href=\"#快速体验\" class=\"headerlink\" title=\"快速体验\"></a>快速体验</h2><ul>\n<li>安装HBuilderX；</li>\n<li>下载或者clone本UI库；</li>\n<li>在HBuilderX里面打开或者导入；</li>\n<li>运行到自己想要体验的平台即可；</li>\n</ul>\n<p class=\"tip\">想了解我们是怎么使用 mypUI 的吗？又如何对 mypUI 有一个更加全面的了解？或者说站在一个代码设计者的角度去了解 mypUI? 纵观全局，对你更加高效的使用mypUI非常有用。建议您一定要看看</p>\n\n<p><a class=\"button\" href=\"global.html\">全局视角了解mypUI</a></p>\n<p>您可以配合 mypUI 的示范代码 来做更加深入的理解。</p>\n"},{"title":"更新日志","type":"guide","order":801,"_content":"\n","source":"doc/guide/history.md","raw":"---\ntitle: 更新日志\ntype: guide\norder: 801\n---\n\n","date":"2020-07-17T06:01:05.767Z","updated":"2020-07-17T06:01:05.767Z","path":"doc/guide/history.html","comments":1,"layout":"page","_id":"ckcwngnjp000w9lxkiaywwwxt","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"mixin混入","type":"guide","order":200,"_content":"","source":"doc/guide/mixins.md","raw":"---\ntitle: mixin混入\ntype: guide\norder: 200\n---\n","date":"2020-07-17T06:06:32.333Z","updated":"2020-07-17T06:06:32.333Z","path":"doc/guide/mixins.html","comments":1,"layout":"page","_id":"ckcwngnjp000x9lxkfjrp17k4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"单多选：myp-check","type":"guide","order":31,"_content":"","source":"doc/guide/myp-check.md","raw":"---\ntitle: 单多选：myp-check\ntype: guide\norder: 31\n---\n","date":"2020-07-21T14:16:32.995Z","updated":"2020-07-21T14:16:32.995Z","path":"doc/guide/myp-check.html","comments":1,"layout":"page","_id":"ckcwngnjq000y9lxkd1im79sy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"按钮：myp-button","type":"guide","order":30,"_content":"\n### 规则\n\n- 支持纯文字\n- 支持icon+文字；\n- 支持loading+文字\n- 布局是icon/loading在左，文字在右；\n- icon和loading二选一，loading为true，icon将会隐藏\n- 兼容nvue/vue；\n\n## 使用\n\n### 可配置参数\n\n| Prop | Type | Required | Default | Description |\n|-------------|------------|--------|--------|-----|\n| text | String |  | 确定 | 按钮的文字描述。|\n| icon | String | 否 | 空 | icon的名字，或者图片地址，图片会自动识别，默认不带icon。 |\n| loading | Boolean | 否 | false | 是否显示loading。true时显示loading。 |\n| loadingSrc | String | 否 | 空 | loading为true时显示，这时候icon会隐藏。默认gif是：`/static/ui/loading.gif`。|\n| bgType | String | 否 | 白色 | 背景色主题配置。可以取`nav`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-bg`。|\n| height | String | 否 | 100rpx | 按钮高度，单位rpx。可以取`ss`/`s`/`base`/`l`/`ll`。|\n| hover | String | 否 | opacity | 按钮的hover效果，状态为disabled和loading下hover无效。可以取`opacity`/`bg`/`bg-opacity`。|\n| radius | String | 否 | base | 按钮圆角设置。可以取`ss`/`s`/`base`/`l`/`ll`，`none`取消圆角。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-radius-base`。|\n| border | String | 否 | all | 边框设置。可以取`all-light`/`all-dark`/`all-primary`/`all-success`/`all-warning`/`all-error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-border-all`。|\n| disabled | Boolean | 否 | false | 禁用点击，且会具备`myp-disabled`class的禁用效果 |\n| highlight | Boolean | 否 | false | 用于状态标记，是否`hightlight`，方便设置和切换状态使用，为true时，可设置按钮`highlightStyle`/`highlightTextStyle`/`highlightIconStyle`。 |\n| space | String | 否 | 12rpx | `loading/icon`与`text`之间`margin-left`的间距。 |\n| textType | String | 否 | text | text字体颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。 |\n| textSize | String | 否 | 空 | text字体大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。 |\n| iconType | String | 否 | 空 | icon颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。 |\n| iconSize | String | 否 | `l` | icon大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。 |\n| iconMode | String | 否 | aspectFill | 当icon为图片时的mode，更多参数查看uni的image标签mode属性。 |\n| boxStyle | String | 否 | 空 | 覆盖组件最外层样式。 |\n| disabledStyle | String | 否 | 空 | 覆盖组件为disabled状态时最外层样式。 |\n| highlightStyle | String | 否 | 空 | 覆盖组件为highlight状态时最外层样式。 |\n| textStyle | String | 否 | 空 | 覆盖组件内text样式。 |\n| disabledTextStyle | String | 否 | 空 | 覆盖组件disabled状态时text样式。|\n| highlightTextStyle | String | 否 | 空 | 覆盖组件highlight状态时text样式。 |\n| iconStyle | String | 否 | 空 | 覆盖组件内icon样式。 |\n| disabledIconStyle | String | 否 | 空 | 覆盖组件为disabled时icon样式。 |\n| highlightIconStyle | String | 否 | 空 | 覆盖组件为highlight时icon样式。 |\n| loadingWidth | String | 否 | 36rpx | 设置loading的宽度。|\n| loadingHeight | String | 否 | 36rpx | 设置loading的高度。|\n\n- 默认`button`内是水平垂直居中的，`boxStyle`可以覆盖掉这个设置；\n- 其它的`style`设置可以覆盖掉这些快捷设置的效果；\n- 既满足一键配置，也满足灵活定义。也就是满足共性，包容特性；\n- 具体的`props`取值，应该参考`base.scss`以及`mypui.scss`；\n\n### slot\n\n> 默认slot\n\n### 事件回掉\n| Event     | Params   | Description  |\n|--------|--------|-----|\n| buttonClicked | | 点击触发 |\n\n### 示例与结果\n\n","source":"doc/guide/myp-button.md","raw":"---\ntitle: 按钮：myp-button\ntype: guide\norder: 30\n---\n\n### 规则\n\n- 支持纯文字\n- 支持icon+文字；\n- 支持loading+文字\n- 布局是icon/loading在左，文字在右；\n- icon和loading二选一，loading为true，icon将会隐藏\n- 兼容nvue/vue；\n\n## 使用\n\n### 可配置参数\n\n| Prop | Type | Required | Default | Description |\n|-------------|------------|--------|--------|-----|\n| text | String |  | 确定 | 按钮的文字描述。|\n| icon | String | 否 | 空 | icon的名字，或者图片地址，图片会自动识别，默认不带icon。 |\n| loading | Boolean | 否 | false | 是否显示loading。true时显示loading。 |\n| loadingSrc | String | 否 | 空 | loading为true时显示，这时候icon会隐藏。默认gif是：`/static/ui/loading.gif`。|\n| bgType | String | 否 | 白色 | 背景色主题配置。可以取`nav`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-bg`。|\n| height | String | 否 | 100rpx | 按钮高度，单位rpx。可以取`ss`/`s`/`base`/`l`/`ll`。|\n| hover | String | 否 | opacity | 按钮的hover效果，状态为disabled和loading下hover无效。可以取`opacity`/`bg`/`bg-opacity`。|\n| radius | String | 否 | base | 按钮圆角设置。可以取`ss`/`s`/`base`/`l`/`ll`，`none`取消圆角。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-radius-base`。|\n| border | String | 否 | all | 边框设置。可以取`all-light`/`all-dark`/`all-primary`/`all-success`/`all-warning`/`all-error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-border-all`。|\n| disabled | Boolean | 否 | false | 禁用点击，且会具备`myp-disabled`class的禁用效果 |\n| highlight | Boolean | 否 | false | 用于状态标记，是否`hightlight`，方便设置和切换状态使用，为true时，可设置按钮`highlightStyle`/`highlightTextStyle`/`highlightIconStyle`。 |\n| space | String | 否 | 12rpx | `loading/icon`与`text`之间`margin-left`的间距。 |\n| textType | String | 否 | text | text字体颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。 |\n| textSize | String | 否 | 空 | text字体大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。 |\n| iconType | String | 否 | 空 | icon颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。 |\n| iconSize | String | 否 | `l` | icon大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。 |\n| iconMode | String | 否 | aspectFill | 当icon为图片时的mode，更多参数查看uni的image标签mode属性。 |\n| boxStyle | String | 否 | 空 | 覆盖组件最外层样式。 |\n| disabledStyle | String | 否 | 空 | 覆盖组件为disabled状态时最外层样式。 |\n| highlightStyle | String | 否 | 空 | 覆盖组件为highlight状态时最外层样式。 |\n| textStyle | String | 否 | 空 | 覆盖组件内text样式。 |\n| disabledTextStyle | String | 否 | 空 | 覆盖组件disabled状态时text样式。|\n| highlightTextStyle | String | 否 | 空 | 覆盖组件highlight状态时text样式。 |\n| iconStyle | String | 否 | 空 | 覆盖组件内icon样式。 |\n| disabledIconStyle | String | 否 | 空 | 覆盖组件为disabled时icon样式。 |\n| highlightIconStyle | String | 否 | 空 | 覆盖组件为highlight时icon样式。 |\n| loadingWidth | String | 否 | 36rpx | 设置loading的宽度。|\n| loadingHeight | String | 否 | 36rpx | 设置loading的高度。|\n\n- 默认`button`内是水平垂直居中的，`boxStyle`可以覆盖掉这个设置；\n- 其它的`style`设置可以覆盖掉这些快捷设置的效果；\n- 既满足一键配置，也满足灵活定义。也就是满足共性，包容特性；\n- 具体的`props`取值，应该参考`base.scss`以及`mypui.scss`；\n\n### slot\n\n> 默认slot\n\n### 事件回掉\n| Event     | Params   | Description  |\n|--------|--------|-----|\n| buttonClicked | | 点击触发 |\n\n### 示例与结果\n\n","date":"2020-07-21T14:11:32.641Z","updated":"2020-07-21T14:11:32.641Z","path":"doc/guide/myp-button.html","comments":1,"layout":"page","_id":"ckcwngnjq000z9lxka55yh67z","content":"<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><ul>\n<li>支持纯文字</li>\n<li>支持icon+文字；</li>\n<li>支持loading+文字</li>\n<li>布局是icon/loading在左，文字在右；</li>\n<li>icon和loading二选一，loading为true，icon将会隐藏</li>\n<li>兼容nvue/vue；</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"可配置参数\"><a href=\"#可配置参数\" class=\"headerlink\" title=\"可配置参数\"></a>可配置参数</h3><table>\n<thead>\n<tr>\n<th>Prop</th>\n<th>Type</th>\n<th>Required</th>\n<th>Default</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text</td>\n<td>String</td>\n<td></td>\n<td>确定</td>\n<td>按钮的文字描述。</td>\n</tr>\n<tr>\n<td>icon</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>icon的名字，或者图片地址，图片会自动识别，默认不带icon。</td>\n</tr>\n<tr>\n<td>loading</td>\n<td>Boolean</td>\n<td>否</td>\n<td>false</td>\n<td>是否显示loading。true时显示loading。</td>\n</tr>\n<tr>\n<td>loadingSrc</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>loading为true时显示，这时候icon会隐藏。默认gif是：<code>/static/ui/loading.gif</code>。</td>\n</tr>\n<tr>\n<td>bgType</td>\n<td>String</td>\n<td>否</td>\n<td>白色</td>\n<td>背景色主题配置。可以取<code>nav</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-bg</code>。</td>\n</tr>\n<tr>\n<td>height</td>\n<td>String</td>\n<td>否</td>\n<td>100rpx</td>\n<td>按钮高度，单位rpx。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。</td>\n</tr>\n<tr>\n<td>hover</td>\n<td>String</td>\n<td>否</td>\n<td>opacity</td>\n<td>按钮的hover效果，状态为disabled和loading下hover无效。可以取<code>opacity</code>/<code>bg</code>/<code>bg-opacity</code>。</td>\n</tr>\n<tr>\n<td>radius</td>\n<td>String</td>\n<td>否</td>\n<td>base</td>\n<td>按钮圆角设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>，<code>none</code>取消圆角。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-radius-base</code>。</td>\n</tr>\n<tr>\n<td>border</td>\n<td>String</td>\n<td>否</td>\n<td>all</td>\n<td>边框设置。可以取<code>all-light</code>/<code>all-dark</code>/<code>all-primary</code>/<code>all-success</code>/<code>all-warning</code>/<code>all-error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-border-all</code>。</td>\n</tr>\n<tr>\n<td>disabled</td>\n<td>Boolean</td>\n<td>否</td>\n<td>false</td>\n<td>禁用点击，且会具备<code>myp-disabled</code>class的禁用效果</td>\n</tr>\n<tr>\n<td>highlight</td>\n<td>Boolean</td>\n<td>否</td>\n<td>false</td>\n<td>用于状态标记，是否<code>hightlight</code>，方便设置和切换状态使用，为true时，可设置按钮<code>highlightStyle</code>/<code>highlightTextStyle</code>/<code>highlightIconStyle</code>。</td>\n</tr>\n<tr>\n<td>space</td>\n<td>String</td>\n<td>否</td>\n<td>12rpx</td>\n<td><code>loading/icon</code>与<code>text</code>之间<code>margin-left</code>的间距。</td>\n</tr>\n<tr>\n<td>textType</td>\n<td>String</td>\n<td>否</td>\n<td>text</td>\n<td>text字体颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>textSize</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>text字体大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>iconType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>icon颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>iconSize</td>\n<td>String</td>\n<td>否</td>\n<td><code>l</code></td>\n<td>icon大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>iconMode</td>\n<td>String</td>\n<td>否</td>\n<td>aspectFill</td>\n<td>当icon为图片时的mode，更多参数查看uni的image标签mode属性。</td>\n</tr>\n<tr>\n<td>boxStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件最外层样式。</td>\n</tr>\n<tr>\n<td>disabledStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件为disabled状态时最外层样式。</td>\n</tr>\n<tr>\n<td>highlightStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件为highlight状态时最外层样式。</td>\n</tr>\n<tr>\n<td>textStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件内text样式。</td>\n</tr>\n<tr>\n<td>disabledTextStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件disabled状态时text样式。</td>\n</tr>\n<tr>\n<td>highlightTextStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件highlight状态时text样式。</td>\n</tr>\n<tr>\n<td>iconStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件内icon样式。</td>\n</tr>\n<tr>\n<td>disabledIconStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件为disabled时icon样式。</td>\n</tr>\n<tr>\n<td>highlightIconStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件为highlight时icon样式。</td>\n</tr>\n<tr>\n<td>loadingWidth</td>\n<td>String</td>\n<td>否</td>\n<td>36rpx</td>\n<td>设置loading的宽度。</td>\n</tr>\n<tr>\n<td>loadingHeight</td>\n<td>String</td>\n<td>否</td>\n<td>36rpx</td>\n<td>设置loading的高度。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>默认<code>button</code>内是水平垂直居中的，<code>boxStyle</code>可以覆盖掉这个设置；</li>\n<li>其它的<code>style</code>设置可以覆盖掉这些快捷设置的效果；</li>\n<li>既满足一键配置，也满足灵活定义。也就是满足共性，包容特性；</li>\n<li>具体的<code>props</code>取值，应该参考<code>base.scss</code>以及<code>mypui.scss</code>；</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><blockquote>\n<p>默认slot</p>\n</blockquote>\n<h3 id=\"事件回掉\"><a href=\"#事件回掉\" class=\"headerlink\" title=\"事件回掉\"></a>事件回掉</h3><table>\n<thead>\n<tr>\n<th>Event</th>\n<th>Params</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>buttonClicked</td>\n<td></td>\n<td>点击触发</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"示例与结果\"><a href=\"#示例与结果\" class=\"headerlink\" title=\"示例与结果\"></a>示例与结果</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><ul>\n<li>支持纯文字</li>\n<li>支持icon+文字；</li>\n<li>支持loading+文字</li>\n<li>布局是icon/loading在左，文字在右；</li>\n<li>icon和loading二选一，loading为true，icon将会隐藏</li>\n<li>兼容nvue/vue；</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"可配置参数\"><a href=\"#可配置参数\" class=\"headerlink\" title=\"可配置参数\"></a>可配置参数</h3><table>\n<thead>\n<tr>\n<th>Prop</th>\n<th>Type</th>\n<th>Required</th>\n<th>Default</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text</td>\n<td>String</td>\n<td></td>\n<td>确定</td>\n<td>按钮的文字描述。</td>\n</tr>\n<tr>\n<td>icon</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>icon的名字，或者图片地址，图片会自动识别，默认不带icon。</td>\n</tr>\n<tr>\n<td>loading</td>\n<td>Boolean</td>\n<td>否</td>\n<td>false</td>\n<td>是否显示loading。true时显示loading。</td>\n</tr>\n<tr>\n<td>loadingSrc</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>loading为true时显示，这时候icon会隐藏。默认gif是：<code>/static/ui/loading.gif</code>。</td>\n</tr>\n<tr>\n<td>bgType</td>\n<td>String</td>\n<td>否</td>\n<td>白色</td>\n<td>背景色主题配置。可以取<code>nav</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-bg</code>。</td>\n</tr>\n<tr>\n<td>height</td>\n<td>String</td>\n<td>否</td>\n<td>100rpx</td>\n<td>按钮高度，单位rpx。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。</td>\n</tr>\n<tr>\n<td>hover</td>\n<td>String</td>\n<td>否</td>\n<td>opacity</td>\n<td>按钮的hover效果，状态为disabled和loading下hover无效。可以取<code>opacity</code>/<code>bg</code>/<code>bg-opacity</code>。</td>\n</tr>\n<tr>\n<td>radius</td>\n<td>String</td>\n<td>否</td>\n<td>base</td>\n<td>按钮圆角设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>，<code>none</code>取消圆角。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-radius-base</code>。</td>\n</tr>\n<tr>\n<td>border</td>\n<td>String</td>\n<td>否</td>\n<td>all</td>\n<td>边框设置。可以取<code>all-light</code>/<code>all-dark</code>/<code>all-primary</code>/<code>all-success</code>/<code>all-warning</code>/<code>all-error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-border-all</code>。</td>\n</tr>\n<tr>\n<td>disabled</td>\n<td>Boolean</td>\n<td>否</td>\n<td>false</td>\n<td>禁用点击，且会具备<code>myp-disabled</code>class的禁用效果</td>\n</tr>\n<tr>\n<td>highlight</td>\n<td>Boolean</td>\n<td>否</td>\n<td>false</td>\n<td>用于状态标记，是否<code>hightlight</code>，方便设置和切换状态使用，为true时，可设置按钮<code>highlightStyle</code>/<code>highlightTextStyle</code>/<code>highlightIconStyle</code>。</td>\n</tr>\n<tr>\n<td>space</td>\n<td>String</td>\n<td>否</td>\n<td>12rpx</td>\n<td><code>loading/icon</code>与<code>text</code>之间<code>margin-left</code>的间距。</td>\n</tr>\n<tr>\n<td>textType</td>\n<td>String</td>\n<td>否</td>\n<td>text</td>\n<td>text字体颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>textSize</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>text字体大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>iconType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>icon颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>iconSize</td>\n<td>String</td>\n<td>否</td>\n<td><code>l</code></td>\n<td>icon大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>iconMode</td>\n<td>String</td>\n<td>否</td>\n<td>aspectFill</td>\n<td>当icon为图片时的mode，更多参数查看uni的image标签mode属性。</td>\n</tr>\n<tr>\n<td>boxStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件最外层样式。</td>\n</tr>\n<tr>\n<td>disabledStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件为disabled状态时最外层样式。</td>\n</tr>\n<tr>\n<td>highlightStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件为highlight状态时最外层样式。</td>\n</tr>\n<tr>\n<td>textStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件内text样式。</td>\n</tr>\n<tr>\n<td>disabledTextStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件disabled状态时text样式。</td>\n</tr>\n<tr>\n<td>highlightTextStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件highlight状态时text样式。</td>\n</tr>\n<tr>\n<td>iconStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件内icon样式。</td>\n</tr>\n<tr>\n<td>disabledIconStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件为disabled时icon样式。</td>\n</tr>\n<tr>\n<td>highlightIconStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件为highlight时icon样式。</td>\n</tr>\n<tr>\n<td>loadingWidth</td>\n<td>String</td>\n<td>否</td>\n<td>36rpx</td>\n<td>设置loading的宽度。</td>\n</tr>\n<tr>\n<td>loadingHeight</td>\n<td>String</td>\n<td>否</td>\n<td>36rpx</td>\n<td>设置loading的高度。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>默认<code>button</code>内是水平垂直居中的，<code>boxStyle</code>可以覆盖掉这个设置；</li>\n<li>其它的<code>style</code>设置可以覆盖掉这些快捷设置的效果；</li>\n<li>既满足一键配置，也满足灵活定义。也就是满足共性，包容特性；</li>\n<li>具体的<code>props</code>取值，应该参考<code>base.scss</code>以及<code>mypui.scss</code>；</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><blockquote>\n<p>默认slot</p>\n</blockquote>\n<h3 id=\"事件回掉\"><a href=\"#事件回掉\" class=\"headerlink\" title=\"事件回掉\"></a>事件回掉</h3><table>\n<thead>\n<tr>\n<th>Event</th>\n<th>Params</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>buttonClicked</td>\n<td></td>\n<td>点击触发</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"示例与结果\"><a href=\"#示例与结果\" class=\"headerlink\" title=\"示例与结果\"></a>示例与结果</h3>"},{"title":"单元：myp-cell","type":"guide","order":50,"_content":"\n### 规则\n\n- icon/title/value/indicator，默认可以实现一行4段；\n- 默认title对应一级标题，value是二级标题或者是描述内容；\n- 搭配slot可以实现多行或者一行更多段，但是不太建议用此来实现多行；\n- 多行公用cell会在另一个组件实现；\n\n## 使用\n\n### 可配置参数\n\n| Prop | Type | Required | Default | Description |\n|-------------|------------|--------|--------|-----|\n| icon | String | 否 | 空 | icon的名字/图片地址，图片会自动识别。 |\n| title | String | 否 | 空 | title文字描述。 |\n| value | String | 否 | 空 | 二级文字描述。 |\n| indicator | String |  | right | indicator `icon`的名字，或者图片地址。图片会自动识别。可以通过indicator为空字符串等来覆盖。 |\n| bgType | String | 否 | 空 | 背景色主题配置。可以取`nav`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-bg`。 |\n| titleType | String | 否 | 空 | title字体颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。 |\n| valueType | String | 否 | 空 | value字体颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。|\n| iconType | String | 否 | 空 | icon颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。|\n| indicatorType | String | 否 | 空 | indicator颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。|\n| titleSize | String | 否 | 空 | title字体大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。|\n| valueSize | String | 否 | 空 | value字体大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。|\n| iconSize | String | 否 | 空 | icon大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。|\n| indicatorSize | String | 否 | 空 | indicator大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。 |\n| height | String | 否 | `l` | 设置组件的高度。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-height`。\n| radius | String | 否 | 空 | 设置组件的圆角大小。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-radius`。|\n| border | String | 否 | 空 | 设置组件的边框样式。边框设置。可以取`all-light`/`all-dark`/`all-primary`/`all-success`/`all-warning`/`all-error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-border-all`。|\n| hover | String | 否 | bg | 设置组件的hover效果，可以取`opacity`/`bg`/`bg-opacity`。|\n| space | String | 否 | 12rpx | 设置`icon`的margin-right间距，`title`的margin-right间距 ，`indicator`的margin-left间距。|\n| iconStyle | String | 否 | 空 | 设置`icon`样式，可以覆盖之前`icon`样式。|\n| indicatorStyle | String | 否 | 空 | 设置`indicator`样式，可以覆盖之前`indicator`样式。|\n| iconMode | String | 否 | aspectFill | 当`icon`为图片时的mode，更多参数查看uni的image标签mode属性。|\n| indicatorMode | String | 否 | aspectFill | 当`indicator`为图片时的mode，更多参数查看uni的image标签mode属性。 |\n| boxStyle | String | 否 | 空 | 覆盖组件最外层样式。 |\n| titleStyle | String | 否 | 空 | 覆盖`title`样式 |\n| valueStyle | String | 否 | 空 | 覆盖`value`样式 |\n\n- type/size/iconSize/height/radius/border等可以实现快速设置，根据scss配置，可以快速实现自己的效果；\n- 其它的style设置可以覆盖掉这些快捷设置的效果；\n- 既满足一键配置，也满足灵活定义。也就是满足共性，包容特性；\n\n### slot\n\n- 默认slot，覆盖title/value；\n- extra，在value与indicator之间提供更多配置；\n\n### 事件回掉\n| Event     | Params   | Description  |\n|--------|--------|-----|\n| cellClicked | | 点击触发 |\n\n### 示例与结果\n\n## 说明\n我对一套UI的理解就是，公用性比较强的组件集合。\n\n我们把这些常用的，配置量偏小的，或者说只要很少的配置就能满足要求的组件合起来组成一套UI。而不是试图去使用这些UI组件去适配所有的样式，希望借此满足所有的组件。\n\n一个UI组件里面考虑太多的因素，或者试图利用它去实现一堆的内容，显然是不合适的。\n\n我们将UI分成了两部分，一部分是公共组件，另一部分是业务中常见的一些组件。\n\n很多业务常用组件，是很难通过一个UI组件来配置完成的，或者说就相当于重新写了一个组件。\n\n与其这样，我们还不如保持UI组件的轻量化。\n\n在这套组件内，我们不仅会提供公用的UI组件，也会提供大多数业务所涉及到的样式组件。\n\n公用UI组件基本上可以通过配置一下就能满足要求，如果改动量很大，或者层级嵌套很深，建议重新写一个组件，毕竟去适配一个组件消耗的精力可能比自己写一个还要大。\n\n而且作为公用（大家都可以用的组件）来说，需要考虑很多因素，而自己写的往往只需要完成样式即可。适配所有人和适配自己是完全不一样的。\n\n原则就是：宁愿多写几个，也不可一个去勉强适应多个。\n","source":"doc/guide/myp-cell.md","raw":"---\ntitle: 单元：myp-cell\ntype: guide\norder: 50\n---\n\n### 规则\n\n- icon/title/value/indicator，默认可以实现一行4段；\n- 默认title对应一级标题，value是二级标题或者是描述内容；\n- 搭配slot可以实现多行或者一行更多段，但是不太建议用此来实现多行；\n- 多行公用cell会在另一个组件实现；\n\n## 使用\n\n### 可配置参数\n\n| Prop | Type | Required | Default | Description |\n|-------------|------------|--------|--------|-----|\n| icon | String | 否 | 空 | icon的名字/图片地址，图片会自动识别。 |\n| title | String | 否 | 空 | title文字描述。 |\n| value | String | 否 | 空 | 二级文字描述。 |\n| indicator | String |  | right | indicator `icon`的名字，或者图片地址。图片会自动识别。可以通过indicator为空字符串等来覆盖。 |\n| bgType | String | 否 | 空 | 背景色主题配置。可以取`nav`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-bg`。 |\n| titleType | String | 否 | 空 | title字体颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。 |\n| valueType | String | 否 | 空 | value字体颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。|\n| iconType | String | 否 | 空 | icon颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。|\n| indicatorType | String | 否 | 空 | indicator颜色设置。可以取`nav`/`text`/`primary`/`success`/`warning`/`error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-color`。|\n| titleSize | String | 否 | 空 | title字体大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。|\n| valueSize | String | 否 | 空 | value字体大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。|\n| iconSize | String | 否 | 空 | icon大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。|\n| indicatorSize | String | 否 | 空 | indicator大小设置。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-size`。 |\n| height | String | 否 | `l` | 设置组件的高度。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-height`。\n| radius | String | 否 | 空 | 设置组件的圆角大小。可以取`ss`/`s`/`base`/`l`/`ll`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-radius`。|\n| border | String | 否 | 空 | 设置组件的边框样式。边框设置。可以取`all-light`/`all-dark`/`all-primary`/`all-success`/`all-warning`/`all-error`。更多参数设置查看`base.scss`文件，默认对应的`class`为`myp-border-all`。|\n| hover | String | 否 | bg | 设置组件的hover效果，可以取`opacity`/`bg`/`bg-opacity`。|\n| space | String | 否 | 12rpx | 设置`icon`的margin-right间距，`title`的margin-right间距 ，`indicator`的margin-left间距。|\n| iconStyle | String | 否 | 空 | 设置`icon`样式，可以覆盖之前`icon`样式。|\n| indicatorStyle | String | 否 | 空 | 设置`indicator`样式，可以覆盖之前`indicator`样式。|\n| iconMode | String | 否 | aspectFill | 当`icon`为图片时的mode，更多参数查看uni的image标签mode属性。|\n| indicatorMode | String | 否 | aspectFill | 当`indicator`为图片时的mode，更多参数查看uni的image标签mode属性。 |\n| boxStyle | String | 否 | 空 | 覆盖组件最外层样式。 |\n| titleStyle | String | 否 | 空 | 覆盖`title`样式 |\n| valueStyle | String | 否 | 空 | 覆盖`value`样式 |\n\n- type/size/iconSize/height/radius/border等可以实现快速设置，根据scss配置，可以快速实现自己的效果；\n- 其它的style设置可以覆盖掉这些快捷设置的效果；\n- 既满足一键配置，也满足灵活定义。也就是满足共性，包容特性；\n\n### slot\n\n- 默认slot，覆盖title/value；\n- extra，在value与indicator之间提供更多配置；\n\n### 事件回掉\n| Event     | Params   | Description  |\n|--------|--------|-----|\n| cellClicked | | 点击触发 |\n\n### 示例与结果\n\n## 说明\n我对一套UI的理解就是，公用性比较强的组件集合。\n\n我们把这些常用的，配置量偏小的，或者说只要很少的配置就能满足要求的组件合起来组成一套UI。而不是试图去使用这些UI组件去适配所有的样式，希望借此满足所有的组件。\n\n一个UI组件里面考虑太多的因素，或者试图利用它去实现一堆的内容，显然是不合适的。\n\n我们将UI分成了两部分，一部分是公共组件，另一部分是业务中常见的一些组件。\n\n很多业务常用组件，是很难通过一个UI组件来配置完成的，或者说就相当于重新写了一个组件。\n\n与其这样，我们还不如保持UI组件的轻量化。\n\n在这套组件内，我们不仅会提供公用的UI组件，也会提供大多数业务所涉及到的样式组件。\n\n公用UI组件基本上可以通过配置一下就能满足要求，如果改动量很大，或者层级嵌套很深，建议重新写一个组件，毕竟去适配一个组件消耗的精力可能比自己写一个还要大。\n\n而且作为公用（大家都可以用的组件）来说，需要考虑很多因素，而自己写的往往只需要完成样式即可。适配所有人和适配自己是完全不一样的。\n\n原则就是：宁愿多写几个，也不可一个去勉强适应多个。\n","date":"2020-07-21T14:11:49.735Z","updated":"2020-07-21T14:11:49.735Z","path":"doc/guide/myp-cell.html","comments":1,"layout":"page","_id":"ckcwngnjr00109lxkeh6lk7hn","content":"<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><ul>\n<li>icon/title/value/indicator，默认可以实现一行4段；</li>\n<li>默认title对应一级标题，value是二级标题或者是描述内容；</li>\n<li>搭配slot可以实现多行或者一行更多段，但是不太建议用此来实现多行；</li>\n<li>多行公用cell会在另一个组件实现；</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"可配置参数\"><a href=\"#可配置参数\" class=\"headerlink\" title=\"可配置参数\"></a>可配置参数</h3><table>\n<thead>\n<tr>\n<th>Prop</th>\n<th>Type</th>\n<th>Required</th>\n<th>Default</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>icon</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>icon的名字/图片地址，图片会自动识别。</td>\n</tr>\n<tr>\n<td>title</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>title文字描述。</td>\n</tr>\n<tr>\n<td>value</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>二级文字描述。</td>\n</tr>\n<tr>\n<td>indicator</td>\n<td>String</td>\n<td></td>\n<td>right</td>\n<td>indicator <code>icon</code>的名字，或者图片地址。图片会自动识别。可以通过indicator为空字符串等来覆盖。</td>\n</tr>\n<tr>\n<td>bgType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>背景色主题配置。可以取<code>nav</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-bg</code>。</td>\n</tr>\n<tr>\n<td>titleType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>title字体颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>valueType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>value字体颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>iconType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>icon颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>indicatorType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>indicator颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>titleSize</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>title字体大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>valueSize</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>value字体大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>iconSize</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>icon大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>indicatorSize</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>indicator大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>height</td>\n<td>String</td>\n<td>否</td>\n<td><code>l</code></td>\n<td>设置组件的高度。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-height</code>。</td>\n</tr>\n<tr>\n<td>radius</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>设置组件的圆角大小。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-radius</code>。</td>\n</tr>\n<tr>\n<td>border</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>设置组件的边框样式。边框设置。可以取<code>all-light</code>/<code>all-dark</code>/<code>all-primary</code>/<code>all-success</code>/<code>all-warning</code>/<code>all-error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-border-all</code>。</td>\n</tr>\n<tr>\n<td>hover</td>\n<td>String</td>\n<td>否</td>\n<td>bg</td>\n<td>设置组件的hover效果，可以取<code>opacity</code>/<code>bg</code>/<code>bg-opacity</code>。</td>\n</tr>\n<tr>\n<td>space</td>\n<td>String</td>\n<td>否</td>\n<td>12rpx</td>\n<td>设置<code>icon</code>的margin-right间距，<code>title</code>的margin-right间距 ，<code>indicator</code>的margin-left间距。</td>\n</tr>\n<tr>\n<td>iconStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>设置<code>icon</code>样式，可以覆盖之前<code>icon</code>样式。</td>\n</tr>\n<tr>\n<td>indicatorStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>设置<code>indicator</code>样式，可以覆盖之前<code>indicator</code>样式。</td>\n</tr>\n<tr>\n<td>iconMode</td>\n<td>String</td>\n<td>否</td>\n<td>aspectFill</td>\n<td>当<code>icon</code>为图片时的mode，更多参数查看uni的image标签mode属性。</td>\n</tr>\n<tr>\n<td>indicatorMode</td>\n<td>String</td>\n<td>否</td>\n<td>aspectFill</td>\n<td>当<code>indicator</code>为图片时的mode，更多参数查看uni的image标签mode属性。</td>\n</tr>\n<tr>\n<td>boxStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件最外层样式。</td>\n</tr>\n<tr>\n<td>titleStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖<code>title</code>样式</td>\n</tr>\n<tr>\n<td>valueStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖<code>value</code>样式</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>type/size/iconSize/height/radius/border等可以实现快速设置，根据scss配置，可以快速实现自己的效果；</li>\n<li>其它的style设置可以覆盖掉这些快捷设置的效果；</li>\n<li>既满足一键配置，也满足灵活定义。也就是满足共性，包容特性；</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li>默认slot，覆盖title/value；</li>\n<li>extra，在value与indicator之间提供更多配置；</li>\n</ul>\n<h3 id=\"事件回掉\"><a href=\"#事件回掉\" class=\"headerlink\" title=\"事件回掉\"></a>事件回掉</h3><table>\n<thead>\n<tr>\n<th>Event</th>\n<th>Params</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cellClicked</td>\n<td></td>\n<td>点击触发</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"示例与结果\"><a href=\"#示例与结果\" class=\"headerlink\" title=\"示例与结果\"></a>示例与结果</h3><h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>我对一套UI的理解就是，公用性比较强的组件集合。</p>\n<p>我们把这些常用的，配置量偏小的，或者说只要很少的配置就能满足要求的组件合起来组成一套UI。而不是试图去使用这些UI组件去适配所有的样式，希望借此满足所有的组件。</p>\n<p>一个UI组件里面考虑太多的因素，或者试图利用它去实现一堆的内容，显然是不合适的。</p>\n<p>我们将UI分成了两部分，一部分是公共组件，另一部分是业务中常见的一些组件。</p>\n<p>很多业务常用组件，是很难通过一个UI组件来配置完成的，或者说就相当于重新写了一个组件。</p>\n<p>与其这样，我们还不如保持UI组件的轻量化。</p>\n<p>在这套组件内，我们不仅会提供公用的UI组件，也会提供大多数业务所涉及到的样式组件。</p>\n<p>公用UI组件基本上可以通过配置一下就能满足要求，如果改动量很大，或者层级嵌套很深，建议重新写一个组件，毕竟去适配一个组件消耗的精力可能比自己写一个还要大。</p>\n<p>而且作为公用（大家都可以用的组件）来说，需要考虑很多因素，而自己写的往往只需要完成样式即可。适配所有人和适配自己是完全不一样的。</p>\n<p>原则就是：宁愿多写几个，也不可一个去勉强适应多个。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><ul>\n<li>icon/title/value/indicator，默认可以实现一行4段；</li>\n<li>默认title对应一级标题，value是二级标题或者是描述内容；</li>\n<li>搭配slot可以实现多行或者一行更多段，但是不太建议用此来实现多行；</li>\n<li>多行公用cell会在另一个组件实现；</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"可配置参数\"><a href=\"#可配置参数\" class=\"headerlink\" title=\"可配置参数\"></a>可配置参数</h3><table>\n<thead>\n<tr>\n<th>Prop</th>\n<th>Type</th>\n<th>Required</th>\n<th>Default</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>icon</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>icon的名字/图片地址，图片会自动识别。</td>\n</tr>\n<tr>\n<td>title</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>title文字描述。</td>\n</tr>\n<tr>\n<td>value</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>二级文字描述。</td>\n</tr>\n<tr>\n<td>indicator</td>\n<td>String</td>\n<td></td>\n<td>right</td>\n<td>indicator <code>icon</code>的名字，或者图片地址。图片会自动识别。可以通过indicator为空字符串等来覆盖。</td>\n</tr>\n<tr>\n<td>bgType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>背景色主题配置。可以取<code>nav</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-bg</code>。</td>\n</tr>\n<tr>\n<td>titleType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>title字体颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>valueType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>value字体颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>iconType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>icon颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>indicatorType</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>indicator颜色设置。可以取<code>nav</code>/<code>text</code>/<code>primary</code>/<code>success</code>/<code>warning</code>/<code>error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-color</code>。</td>\n</tr>\n<tr>\n<td>titleSize</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>title字体大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>valueSize</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>value字体大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>iconSize</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>icon大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>indicatorSize</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>indicator大小设置。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-size</code>。</td>\n</tr>\n<tr>\n<td>height</td>\n<td>String</td>\n<td>否</td>\n<td><code>l</code></td>\n<td>设置组件的高度。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-height</code>。</td>\n</tr>\n<tr>\n<td>radius</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>设置组件的圆角大小。可以取<code>ss</code>/<code>s</code>/<code>base</code>/<code>l</code>/<code>ll</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-radius</code>。</td>\n</tr>\n<tr>\n<td>border</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>设置组件的边框样式。边框设置。可以取<code>all-light</code>/<code>all-dark</code>/<code>all-primary</code>/<code>all-success</code>/<code>all-warning</code>/<code>all-error</code>。更多参数设置查看<code>base.scss</code>文件，默认对应的<code>class</code>为<code>myp-border-all</code>。</td>\n</tr>\n<tr>\n<td>hover</td>\n<td>String</td>\n<td>否</td>\n<td>bg</td>\n<td>设置组件的hover效果，可以取<code>opacity</code>/<code>bg</code>/<code>bg-opacity</code>。</td>\n</tr>\n<tr>\n<td>space</td>\n<td>String</td>\n<td>否</td>\n<td>12rpx</td>\n<td>设置<code>icon</code>的margin-right间距，<code>title</code>的margin-right间距 ，<code>indicator</code>的margin-left间距。</td>\n</tr>\n<tr>\n<td>iconStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>设置<code>icon</code>样式，可以覆盖之前<code>icon</code>样式。</td>\n</tr>\n<tr>\n<td>indicatorStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>设置<code>indicator</code>样式，可以覆盖之前<code>indicator</code>样式。</td>\n</tr>\n<tr>\n<td>iconMode</td>\n<td>String</td>\n<td>否</td>\n<td>aspectFill</td>\n<td>当<code>icon</code>为图片时的mode，更多参数查看uni的image标签mode属性。</td>\n</tr>\n<tr>\n<td>indicatorMode</td>\n<td>String</td>\n<td>否</td>\n<td>aspectFill</td>\n<td>当<code>indicator</code>为图片时的mode，更多参数查看uni的image标签mode属性。</td>\n</tr>\n<tr>\n<td>boxStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖组件最外层样式。</td>\n</tr>\n<tr>\n<td>titleStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖<code>title</code>样式</td>\n</tr>\n<tr>\n<td>valueStyle</td>\n<td>String</td>\n<td>否</td>\n<td>空</td>\n<td>覆盖<code>value</code>样式</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>type/size/iconSize/height/radius/border等可以实现快速设置，根据scss配置，可以快速实现自己的效果；</li>\n<li>其它的style设置可以覆盖掉这些快捷设置的效果；</li>\n<li>既满足一键配置，也满足灵活定义。也就是满足共性，包容特性；</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li>默认slot，覆盖title/value；</li>\n<li>extra，在value与indicator之间提供更多配置；</li>\n</ul>\n<h3 id=\"事件回掉\"><a href=\"#事件回掉\" class=\"headerlink\" title=\"事件回掉\"></a>事件回掉</h3><table>\n<thead>\n<tr>\n<th>Event</th>\n<th>Params</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cellClicked</td>\n<td></td>\n<td>点击触发</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"示例与结果\"><a href=\"#示例与结果\" class=\"headerlink\" title=\"示例与结果\"></a>示例与结果</h3><h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>我对一套UI的理解就是，公用性比较强的组件集合。</p>\n<p>我们把这些常用的，配置量偏小的，或者说只要很少的配置就能满足要求的组件合起来组成一套UI。而不是试图去使用这些UI组件去适配所有的样式，希望借此满足所有的组件。</p>\n<p>一个UI组件里面考虑太多的因素，或者试图利用它去实现一堆的内容，显然是不合适的。</p>\n<p>我们将UI分成了两部分，一部分是公共组件，另一部分是业务中常见的一些组件。</p>\n<p>很多业务常用组件，是很难通过一个UI组件来配置完成的，或者说就相当于重新写了一个组件。</p>\n<p>与其这样，我们还不如保持UI组件的轻量化。</p>\n<p>在这套组件内，我们不仅会提供公用的UI组件，也会提供大多数业务所涉及到的样式组件。</p>\n<p>公用UI组件基本上可以通过配置一下就能满足要求，如果改动量很大，或者层级嵌套很深，建议重新写一个组件，毕竟去适配一个组件消耗的精力可能比自己写一个还要大。</p>\n<p>而且作为公用（大家都可以用的组件）来说，需要考虑很多因素，而自己写的往往只需要完成样式即可。适配所有人和适配自己是完全不一样的。</p>\n<p>原则就是：宁愿多写几个，也不可一个去勉强适应多个。</p>\n"},{"title":"布局：myp-flex","type":"guide","order":10,"_content":"","source":"doc/guide/myp-flex.md","raw":"---\ntitle: 布局：myp-flex\ntype: guide\norder: 10\n---\n","date":"2020-07-21T14:11:22.862Z","updated":"2020-07-21T14:11:22.862Z","path":"doc/guide/myp-flex.html","comments":1,"layout":"page","_id":"ckcwngnjr00119lxkn1g54uag","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"网格：myp-grid","type":"guide","order":52,"_content":"","source":"doc/guide/myp-grid.md","raw":"---\ntitle: 网格：myp-grid\ntype: guide\norder: 52\n---\n","date":"2020-07-21T14:28:55.472Z","updated":"2020-07-21T14:28:55.472Z","path":"doc/guide/myp-grid.html","comments":1,"layout":"page","_id":"ckcwngnjr00129lxk1iqm96c7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"图标：myp-icon","type":"guide","order":51,"_content":"","source":"doc/guide/myp-icon.md","raw":"---\ntitle: 图标：myp-icon\ntype: guide\norder: 51\n---\n","date":"2020-07-21T14:28:11.173Z","updated":"2020-07-21T14:28:11.173Z","path":"doc/guide/myp-icon.html","comments":1,"layout":"page","_id":"ckcwngnjs00139lxkbd5soul6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"多行输入：myp-input-grow","type":"guide","order":34,"_content":"","source":"doc/guide/myp-input-grow.md","raw":"---\ntitle: 多行输入：myp-input-grow\ntype: guide\norder: 34\n---\n","date":"2020-07-21T14:19:20.917Z","updated":"2020-07-21T14:19:20.917Z","path":"doc/guide/myp-input-grow.html","comments":1,"layout":"page","_id":"ckcwngnjs00149lxkouh14gco","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"输入框：myp-input","type":"guide","order":32,"_content":"","source":"doc/guide/myp-input.md","raw":"---\ntitle: 输入框：myp-input\ntype: guide\norder: 32\n---\n","date":"2020-07-21T14:18:22.929Z","updated":"2020-07-21T14:18:22.929Z","path":"doc/guide/myp-input.html","comments":1,"layout":"page","_id":"ckcwngnjt00159lxktwb7voah","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"列表：myp-list-simple","type":"guide","order":90,"_content":"","source":"doc/guide/myp-list-simple.md","raw":"---\ntitle: 列表：myp-list-simple\ntype: guide\norder: 90\n---\n","date":"2020-07-21T14:11:59.227Z","updated":"2020-07-21T14:11:59.227Z","path":"doc/guide/myp-list-simple.html","comments":1,"layout":"page","_id":"ckcwngnjt00169lxk8m803xv0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"输入框：myp-input-one","type":"guide","order":33,"_content":"","source":"doc/guide/myp-input-one.md","raw":"---\ntitle: 输入框：myp-input-one\ntype: guide\norder: 33\n---\n","date":"2020-07-21T14:19:03.359Z","updated":"2020-07-21T14:19:03.359Z","path":"doc/guide/myp-input-one.html","comments":1,"layout":"page","_id":"ckcwngnjt00179lxkz6hqa7oj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"loading：myp-loading","type":"guide","order":72,"_content":"","source":"doc/guide/myp-loading.md","raw":"---\ntitle: loading：myp-loading\ntype: guide\norder: 72\n---\n","date":"2020-07-21T14:34:28.636Z","updated":"2020-07-21T14:34:28.636Z","path":"doc/guide/myp-loading.html","comments":1,"layout":"page","_id":"ckcwngnjv00189lxkcc3i9ot1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"导航栏：myp-navbar","type":"guide","order":20,"_content":"","source":"doc/guide/myp-navbar.md","raw":"---\ntitle: 导航栏：myp-navbar\ntype: guide\norder: 20\n---\n","date":"2020-07-21T14:11:36.819Z","updated":"2020-07-21T14:11:36.819Z","path":"doc/guide/myp-navbar.html","comments":1,"layout":"page","_id":"ckcwngnjv00199lxk6xbh98j1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分页器：myp-pagination","type":"guide","order":26,"_content":"","source":"doc/guide/myp-pagination.md","raw":"---\ntitle: 分页器：myp-pagination\ntype: guide\norder: 26\n---\n","date":"2020-07-21T14:12:09.066Z","updated":"2020-07-21T14:12:09.066Z","path":"doc/guide/myp-pagination.html","comments":1,"layout":"page","_id":"ckcwngnjw001a9lxklvba9gi0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"选择器：myp-picker","type":"guide","order":36,"_content":"","source":"doc/guide/myp-picker.md","raw":"---\ntitle: 选择器：myp-picker\ntype: guide\norder: 36\n---\n","date":"2020-07-21T14:20:29.659Z","updated":"2020-07-21T14:20:29.659Z","path":"doc/guide/myp-picker.html","comments":1,"layout":"page","_id":"ckcwngnjw001b9lxkukaxke4u","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"气泡：myp-popover","type":"guide","order":27,"_content":"","source":"doc/guide/myp-popover.md","raw":"---\ntitle: 气泡：myp-popover\ntype: guide\norder: 27\n---\n","date":"2020-07-21T14:12:14.980Z","updated":"2020-07-21T14:12:14.980Z","path":"doc/guide/myp-popover.html","comments":1,"layout":"page","_id":"ckcwngnjw001c9lxk4whd8ur7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"弹窗：myp-popup","type":"guide","order":70,"_content":"","source":"doc/guide/myp-popup.md","raw":"---\ntitle: 弹窗：myp-popup\ntype: guide\norder: 70\n---\n","date":"2020-07-21T13:54:00.543Z","updated":"2020-07-21T13:54:00.543Z","path":"doc/guide/myp-popup.html","comments":1,"layout":"page","_id":"ckcwngnjx001d9lxk73eddtk1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"下拉刷新：myp-refresher","type":"guide","order":80,"_content":"","source":"doc/guide/myp-refresher.md","raw":"---\ntitle: 下拉刷新：myp-refresher\ntype: guide\norder: 80\n---\n","date":"2020-07-21T13:53:10.136Z","updated":"2020-07-21T13:53:10.136Z","path":"doc/guide/myp-refresher.html","comments":1,"layout":"page","_id":"ckcwngnjx001e9lxka8pkoc71","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"抽屉：myp-popup-always","type":"guide","order":25,"_content":"","source":"doc/guide/myp-popup-always.md","raw":"---\ntitle: 抽屉：myp-popup-always\ntype: guide\norder: 25\n---\n","date":"2020-07-21T14:12:21.432Z","updated":"2020-07-21T14:12:21.432Z","path":"doc/guide/myp-popup-always.html","comments":1,"layout":"page","_id":"ckcwngnjy001f9lxknnrnsx58","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"搜索框：myp-search","type":"guide","order":35,"_content":"","source":"doc/guide/myp-search.md","raw":"---\ntitle: 搜索框：myp-search\ntype: guide\norder: 35\n---\n","date":"2020-07-21T14:19:36.298Z","updated":"2020-07-21T14:19:36.298Z","path":"doc/guide/myp-search.html","comments":1,"layout":"page","_id":"ckcwngnjy001g9lxkhc3ma460","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分段器：myp-segment","type":"guide","order":24,"_content":"","source":"doc/guide/myp-segment.md","raw":"---\ntitle: 分段器：myp-segment\ntype: guide\norder: 24\n---\n","date":"2020-07-21T14:12:34.282Z","updated":"2020-07-21T14:12:34.282Z","path":"doc/guide/myp-segment.html","comments":1,"layout":"page","_id":"ckcwngnjz001h9lxk0oray8ew","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"上下留白：myp-space","type":"guide","order":12,"_content":"","source":"doc/guide/myp-space.md","raw":"---\ntitle: 上下留白：myp-space\ntype: guide\norder: 12\n---\n","date":"2020-07-21T14:12:39.964Z","updated":"2020-07-21T14:12:39.964Z","path":"doc/guide/myp-space.html","comments":1,"layout":"page","_id":"ckcwngnjz001i9lxkkfilnwid","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"步进器：myp-stepper","type":"guide","order":38,"_content":"","source":"doc/guide/myp-stepper.md","raw":"---\ntitle: 步进器：myp-stepper\ntype: guide\norder: 38\n---\n","date":"2020-07-21T14:22:03.365Z","updated":"2020-07-21T14:22:03.365Z","path":"doc/guide/myp-stepper.html","comments":1,"layout":"page","_id":"ckcwngnjz001j9lxk2d46bmae","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"开关：myp-switch","type":"guide","order":37,"_content":"","source":"doc/guide/myp-switch.md","raw":"---\ntitle: 开关：myp-switch\ntype: guide\norder: 37\n---\n","date":"2020-07-21T14:23:22.847Z","updated":"2020-07-21T14:23:22.847Z","path":"doc/guide/myp-switch.html","comments":1,"layout":"page","_id":"ckcwngnk0001k9lxkqw4p8yeq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"横向tabs：myp-tabs-h","type":"guide","order":21,"_content":"","source":"doc/guide/myp-tabs-h.md","raw":"---\ntitle: 横向tabs：myp-tabs-h\ntype: guide\norder: 21\n---\n","date":"2020-07-21T14:12:53.639Z","updated":"2020-07-21T14:12:53.639Z","path":"doc/guide/myp-tabs-h.html","comments":1,"layout":"page","_id":"ckcwngnk0001l9lxkqpab61lp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tabbar：myp-tabbar","type":"guide","order":23,"_content":"","source":"doc/guide/myp-tabbar.md","raw":"---\ntitle: Tabbar：myp-tabbar\ntype: guide\norder: 23\n---\n","date":"2020-07-21T14:12:46.173Z","updated":"2020-07-21T14:12:46.173Z","path":"doc/guide/myp-tabbar.html","comments":1,"layout":"page","_id":"ckcwngnk1001m9lxkryhw5rwh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"竖向tabs：myp-tabs-v","type":"guide","order":22,"_content":"","source":"doc/guide/myp-tabs-v.md","raw":"---\ntitle: 竖向tabs：myp-tabs-v\ntype: guide\norder: 22\n---\n","date":"2020-07-21T14:12:59.388Z","updated":"2020-07-21T14:12:59.388Z","path":"doc/guide/myp-tabs-v.html","comments":1,"layout":"page","_id":"ckcwngnk1001n9lxkjzvwst2v","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签：myp-tag","type":"guide","order":53,"_content":"","source":"doc/guide/myp-tag.md","raw":"---\ntitle: 标签：myp-tag\ntype: guide\norder: 53\n---\n","date":"2020-07-21T14:29:54.678Z","updated":"2020-07-21T14:29:54.678Z","path":"doc/guide/myp-tag.html","comments":1,"layout":"page","_id":"ckcwngnk1001o9lxkqufaop8q","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"两翼留白：myp-wing","type":"guide","order":11,"_content":"","source":"doc/guide/myp-wing.md","raw":"---\ntitle: 两翼留白：myp-wing\ntype: guide\norder: 11\n---\n","date":"2020-07-21T14:13:05.048Z","updated":"2020-07-21T14:13:05.048Z","path":"doc/guide/myp-wing.html","comments":1,"layout":"page","_id":"ckcwngnk2001p9lxk5q21rgrl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Toast弹窗：myp-toast","type":"guide","order":71,"_content":"","source":"doc/guide/myp-toast.md","raw":"---\ntitle: Toast弹窗：myp-toast\ntype: guide\norder: 71\n---\n","date":"2020-07-21T14:33:24.526Z","updated":"2020-07-21T14:33:24.526Z","path":"doc/guide/myp-toast.html","comments":1,"layout":"page","_id":"ckcwngnk2001q9lxkn62qvxty","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分享","type":"guide","order":301,"_content":"","source":"doc/guide/share.md","raw":"---\ntitle: 分享\ntype: guide\norder: 301\n---\n","date":"2020-07-17T06:12:30.719Z","updated":"2020-07-17T06:12:30.719Z","path":"doc/guide/share.html","comments":1,"layout":"page","_id":"ckcwngnk3001r9lxk6nr25656","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"路由","type":"guide","order":300,"_content":"","source":"doc/guide/routing.md","raw":"---\ntitle: 路由\ntype: guide\norder: 300\n---\n","date":"2020-07-17T06:07:35.415Z","updated":"2020-07-17T06:07:35.415Z","path":"doc/guide/routing.html","comments":1,"layout":"page","_id":"ckcwngnk3001s9lxk29pyn9l5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"主题配置","type":"guide","order":6,"_content":"\n","source":"doc/guide/theme.md","raw":"---\ntitle: 主题配置\ntype: guide\norder: 6\n---\n\n","date":"2020-07-17T11:05:15.123Z","updated":"2020-07-17T11:05:15.123Z","path":"doc/guide/theme.html","comments":1,"layout":"page","_id":"ckcwngnk3001t9lxkz7paiubn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"组件生成器","type":"tool","order":3,"_content":"","source":"doc/tool/component.md","raw":"---\ntitle: 组件生成器\ntype: tool\norder: 3\n---\n","date":"2020-07-17T05:36:41.642Z","updated":"2020-07-17T05:36:41.642Z","path":"doc/tool/component.html","comments":1,"layout":"page","_id":"ckcwngnk4001u9lxkjc8jtz81","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"icons提取器","type":"tool","order":1,"_content":"","source":"doc/tool/icon.md","raw":"---\ntitle: icons提取器\ntype: tool\norder: 1\n---\n","date":"2020-07-17T05:36:03.240Z","updated":"2020-07-17T05:36:03.240Z","path":"doc/tool/icon.html","comments":1,"layout":"page","_id":"ckcwngnk4001v9lxk1q0r2psh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"props生成器","type":"tool","order":2,"_content":"","source":"doc/tool/props.md","raw":"---\ntitle: props生成器\ntype: tool\norder: 2\n---\n","date":"2020-07-17T05:36:29.077Z","updated":"2020-07-17T05:36:29.077Z","path":"doc/tool/props.html","comments":1,"layout":"page","_id":"ckcwngnk4001w9lxkxax073q2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"为什么选择mypUI","type":"guide","order":1,"_content":"\nmypUI 是基于 uniapp 的一套组件库与工具集，可以 **高效且规范** 地开发出 uniapp 支持的各端应用（APP/各家小程序/H5/快应用）。兼容 nvue 页面 和 vue 页面。nvue 页面对应的 app端 依托 weex 编译为原生，具备良好的性能与体验。mypUI 绝对能为您带来 **稳定、高效、规范** 的开发体验。\n\n## 思考\n\nmypUI 从一开始就一直在思考如下几个问题：\n\n- 主题的支持，以及使用哪些配置可以满足一个恰到好处，不多不少的主题特性？\n\n- 一个基础的组件，如何做到简单易用，又能够灵活的适配？\n\n- UI库往往带有很多组件，如何最大程度的降低学习成本与熟练成本，怎样才能最快上手？\n\n- 文档的可读性和可理解性，一个细致化的组件开放的属性可能几十个，如何满足新手的可读性与可理解性？\n\n- 各端的兼容往往会导致各端的差异化适配，而差异化的适配往往会降低开发的效率，如何在保证性能的基础上提高开发的效率？\n\n- 有很多变量的值，他们可能是计算而得，可能是通过api获取而得，这些值在UI内用到，用户也会经常用到，是不是可以只计算或获取一次？\n\n- 如何能够让使用者加快开发速度，减少文档依赖，减少记忆成本？\n\n- 版本的成熟性与稳定性，是不是一直维护？如何兼容版本更新，降低更新成本？\n\n- 一个组件库最重要的是什么？到底满足什么才能算是一个好的组件库？\n\n- 为什么要用这个库，她能带来什么好处？她的核心竞争力在哪里？\n\n<p class=\"tip\">以上的思考，有些是我们开发过程中需要思考的问题，有些是我们在使用第三库时遇到的问题，或者我们在开发库时需要考虑的问题。这些问题得到一个妥善的解决，绝对是一个绝佳的高效工具</p>\n\n下面我们就来回答这些问题，这也是我们推荐您使用 mypUI 的真正原因，也是 mypUI 的真正魅力所在。\n\n## 可配置的主题设计\n\nmypUI 设计规范和技术上支持灵活的样式定制，以满足业务和品牌上多样化的视觉需求，包括但不限于全局样式（主色、圆角、边框）和指定组件的视觉定制。\n\n![主题配置](/images/doc/button.png)\n\nmypUI 的样式采用了 scss 作为开发语言，并定义了一系列全局的样式变量，您可以根据需求进行相应的调整。\n\n其中包含了 主题、文字、边框、圆角、字号、尺寸 等多种通用变量，所有的样式变量以及具体的使用说明在 [这里](/doc/guide/theme.html) 找到。\n\n如果以上变量不能满足你的定制需求，可以给我们提 issue。\n\n当然，对于您自己添加变量，那也是非常的方便。更多主题配置的内容将在 [主题配置](/doc/guide/theme.html) 讲解。\n\n## 快捷配置与灵活订制\n\nmypUI 中的组件几乎开放了所有的可配置项，在满足主题配置的同时，也支持个性化的适配。\n\n比如 `myp-button` 组件，可以通过 `bgType` `border` `radius` `icon` `text` `height` 快速实现样式与主题配置。非常方便快捷，也很容易上手。\n\n如果在这些配置的基础上，还不能满足一些特殊的要求，您可以设置各种 `style` 来满足您的要求，比如 `textStyle` `boxStyle` `iconStyle` 等。\n\nmypUI 组件既能满足一键式的快捷配置，也能满足几乎所有元素的细节配置。\n\n``` html\n<myp-button icon=\"plus\" text=\"左侧带图标\"></myp-button>\n<myp-button :loading=\"loadingVisible\" bgType=\"success\" icon=\"wechat\" text=\"点击切换加载状态\" @buttonClicked=\"toggleLoading\"></myp-button>\n<myp-button icon=\"circle-wechat\" :text=\"null\" radius=\"ll\" iconType=\"success\" iconStyle=\"font-size: 100rpx;\" boxStyle=\"height: 100rpx;width: 100rpx;\" border=\"none\"></myp-button>\n```\n\n具体细节查看各个组件的文档。\n\n## 语义化与统一规范\n\n如何快速上手？如何降低学习成本？如何了解一个就是了解全部？如何减轻记忆压力，放下文档依赖？\n\n这一切还需要 **语义化的字段设计** 与 **统一规范的字段设计** 有关。\n\nmypUI 中组件的props都采用了规范与统一的命名规则。`xx` `xxType` `xxSize` `xxStyle`，你只需要知道一次，就能知道所有，并且随时都知道，因为没有模糊的设置，而且大家都彼此规则一样。\n\n这些规范涉及到了：\n\n- props的命名规范与统一，各种命名后缀都有特定的含义；\n\n- 响应事件的规范：`buttonClicked` `cellClicked` `...` 都是无需记忆的事件名字；\n\n`myp-button`中背景主题色叫做 `bgType`，`myp-cell`中背景主题色也是`bgType`。\n\n具体字段的设计规范，请查阅 [设计规范](/doc/guide/design.html)。\n\n## 文档分层，一目了然\n\n写文档是个技术活，看文档也是个难题。很多有用的东西，因为文档不全，或者文档可读性太差，大大提高了使用者的门槛，以及使用成本。\n\n而文档不分层，大量的props说明堆叠在一起，也难以一目了然，很大程度上增加了内容筛选的难度。\n\nmypUI 组件的文档，分为快捷设置，细节配置，进阶设置等层次。常规属性一目了然。降低阅读难度。\n\n## 抹平差异，减少配置\n\n在兼容各端的过程中，差异化的配置或者适配是不可避免的，但是很多差异是可以通过取舍以及封装抹平的。\n\n尤其是在app端的时候，导航栏各种设计，或者是tabbar的各种特效，使用自带的navbar或者tabbar很难满足要求，而个别页面自定义的话，又觉得风格不统一，甚至uni的在`pages.json`中的各种`subnvue`的配置实在是不够友好。\n\n这种情况，在快捷开发、便利性、统一性，与小程序端使用原生navbar的性能之间进行取舍。到底如何取舍？\n\n我的选择是去除掉系统自带的navbar和tabbar，去除掉`page.json`中各种设置，`pages.json`仅仅只是一个页面注册的地方。简单粗暴，快捷高效，各端开发基本统一，减少差异适配。\n\n当然，这仅仅只是我的选择。你依然有自由选择的权利。我们提供了自定义的navbar与tabbar。\n\n取舍，我们考虑：\n\n- 失去了什么：小程序端原生navbar比自定义的要好，但是这点性能基本上忽略不计了。因为我们都能够接受小程序端`scroll-view`自定义的下拉刷新。而在nvue-app，就更不要考虑这个性能的问题了。\n\n- 得到了什么：统一的开发方式，高效便捷，好维护。而且可实现全屏弹层，并且可以非常灵活的处理navbar层，适应各种设计；\n\n个人觉得，得大于失。在选择面前，我们不可能什么都兼顾，选择合适的就是好的。很多人纠结用这用那，其实在nvue出来之前，自己连vue页面都能够接受，结果nvue出来了，又在为这里那里纠结个不停。实在是得不偿失。赶紧动手，实现为上。去实现，去完成，去努力，去发光发热。\n\n另外就是封装组件，各端使用不同的组件时，将其封装进入一个组件，提供统一的开放接口和属性配置。比如`scroll-view`与`list`。\n\n## 复用与缓存，降低成本\n\n在开发的过程中，有些内容是多次需要的，而且很有可能是只需要计算一次的。但是因为某些原因，我们不得不重新获取或者计算。我们应该避免这种重复的行为，一是不太好维护，二是有些接口调用起来比较消耗。\n\n所以，我们把这些内容初始化一次，存放起来，封装一些方法，每次去取现成的就行。\n\n还有就是，在写代码的时候，某个页面或者组件难免会要求多次计算，但是前面的计算也是有效的，这个时候我们可以缓存已经有的计算，新的计算值不断缓存进去就行。没有必要一直从头开始。\n\n就好比，省市区三级一样，没有必要每一次省变了都去后台拉取市的信息，而是先检查缓存，缓存有就用缓存的，缓存没有才去拉取，拉取之后存入缓存。\n\n这是一种习惯，也是一种节约成本的方式。\n\n同时，大量可复用的mixin，也为你提供了极大的便利。\n\n## 性能优化\n\n性能优化，考虑几个方面。大多数的优化，uni已经帮我们做了。我们应该考虑什么？\n\n- bingdingX的运用；\n\n- 减少不必要的UI刷新；\n\n- 在必要的时候创建实例；\n\n- 及时销毁不需要的监听；\n\n## 更新策略与稳定性\n\n- mypUI 组件，基础组件已经趋向于稳定，19年双11的时候，mypUI 就已经有了上线的市场的能力，后来在内部使用改版多次，甚至还完全重构了一次，现在已经趋向稳定；\n\n- 我们会加大落地组件（开箱即用组件）的更新力度，满足一些拿来即用的用户需求。实际上，这些本来是没有什么太大的意义的，有一个快速开发的壳子就够了。但是考虑到很多开发者没有设计，没有产品，那就多多益善吧；\n\n- 每一次版本的更新会考虑对上一版的影响，即使有改动，也会列出来哪些地方做出了改动，用户需要升级调整；\n\n## 优秀的组件库\n\n<p class=\"tip\">我一直在想，一个优秀的组件库，应该备具哪些特质。我想前面列出的都具备的无疑是一个优秀的库。</p>\n\n一个组件库应该是经过设计和思考的。开发组件容易，但是开发一个适应于多数人的组件库就需要考虑很多。\n\n一个组件库，最优秀的能力，就是为一切不可能提供了可能，为一切不便利提供了便利。自由搭配与完全掌控的页面布局，完全便捷的安全区兼容，十分牛逼的全屏遮罩。\n\n一切的一切，无疑，都在说明一个事实：**mypUI 是一个优秀的库。**\n\n## 核心竞争力\n\n- header-swiper，不仅只是nvue-app端可以使用，在MP/H5端也能使用，而且支持刷新和加载更多。全端仿咸鱼/58成为可能；\n\n- chat-list，对于聊天列表，提供了两种考虑方式；\n\n- 性能、设计、快捷开发、效率等的多重考虑；\n\n- 页面管理非常灵活，没有做不到，只有想不到；\n\n- 体验最好的popup；\n\n- 最顺手的高度管理与计算，非常灵活的安全区兼容；\n\n- 自由畅想，就等你来；\n\n体验之后，你就会发现：真棒！\n\n## 选我没错\n\n说了这么多，哈哈哈哈，其实就是想告诉你：**不要纠结，选我没错！**\n\n**去用，去实现，去完成！**\n\n多谢支持。\n\n## 快速体验\n\n- 安装HBuilderX；\n- 下载或者clone本UI库；\n- 在HBuilderX里面打开或者导入；\n- 运行到自己想要体验的平台即可；\n\n<!-- zhlint ignore: min+gzip -->\n","source":"doc/guide/why.md","raw":"---\ntitle: 为什么选择mypUI\ntype: guide\norder: 1\n---\n\nmypUI 是基于 uniapp 的一套组件库与工具集，可以 **高效且规范** 地开发出 uniapp 支持的各端应用（APP/各家小程序/H5/快应用）。兼容 nvue 页面 和 vue 页面。nvue 页面对应的 app端 依托 weex 编译为原生，具备良好的性能与体验。mypUI 绝对能为您带来 **稳定、高效、规范** 的开发体验。\n\n## 思考\n\nmypUI 从一开始就一直在思考如下几个问题：\n\n- 主题的支持，以及使用哪些配置可以满足一个恰到好处，不多不少的主题特性？\n\n- 一个基础的组件，如何做到简单易用，又能够灵活的适配？\n\n- UI库往往带有很多组件，如何最大程度的降低学习成本与熟练成本，怎样才能最快上手？\n\n- 文档的可读性和可理解性，一个细致化的组件开放的属性可能几十个，如何满足新手的可读性与可理解性？\n\n- 各端的兼容往往会导致各端的差异化适配，而差异化的适配往往会降低开发的效率，如何在保证性能的基础上提高开发的效率？\n\n- 有很多变量的值，他们可能是计算而得，可能是通过api获取而得，这些值在UI内用到，用户也会经常用到，是不是可以只计算或获取一次？\n\n- 如何能够让使用者加快开发速度，减少文档依赖，减少记忆成本？\n\n- 版本的成熟性与稳定性，是不是一直维护？如何兼容版本更新，降低更新成本？\n\n- 一个组件库最重要的是什么？到底满足什么才能算是一个好的组件库？\n\n- 为什么要用这个库，她能带来什么好处？她的核心竞争力在哪里？\n\n<p class=\"tip\">以上的思考，有些是我们开发过程中需要思考的问题，有些是我们在使用第三库时遇到的问题，或者我们在开发库时需要考虑的问题。这些问题得到一个妥善的解决，绝对是一个绝佳的高效工具</p>\n\n下面我们就来回答这些问题，这也是我们推荐您使用 mypUI 的真正原因，也是 mypUI 的真正魅力所在。\n\n## 可配置的主题设计\n\nmypUI 设计规范和技术上支持灵活的样式定制，以满足业务和品牌上多样化的视觉需求，包括但不限于全局样式（主色、圆角、边框）和指定组件的视觉定制。\n\n![主题配置](/images/doc/button.png)\n\nmypUI 的样式采用了 scss 作为开发语言，并定义了一系列全局的样式变量，您可以根据需求进行相应的调整。\n\n其中包含了 主题、文字、边框、圆角、字号、尺寸 等多种通用变量，所有的样式变量以及具体的使用说明在 [这里](/doc/guide/theme.html) 找到。\n\n如果以上变量不能满足你的定制需求，可以给我们提 issue。\n\n当然，对于您自己添加变量，那也是非常的方便。更多主题配置的内容将在 [主题配置](/doc/guide/theme.html) 讲解。\n\n## 快捷配置与灵活订制\n\nmypUI 中的组件几乎开放了所有的可配置项，在满足主题配置的同时，也支持个性化的适配。\n\n比如 `myp-button` 组件，可以通过 `bgType` `border` `radius` `icon` `text` `height` 快速实现样式与主题配置。非常方便快捷，也很容易上手。\n\n如果在这些配置的基础上，还不能满足一些特殊的要求，您可以设置各种 `style` 来满足您的要求，比如 `textStyle` `boxStyle` `iconStyle` 等。\n\nmypUI 组件既能满足一键式的快捷配置，也能满足几乎所有元素的细节配置。\n\n``` html\n<myp-button icon=\"plus\" text=\"左侧带图标\"></myp-button>\n<myp-button :loading=\"loadingVisible\" bgType=\"success\" icon=\"wechat\" text=\"点击切换加载状态\" @buttonClicked=\"toggleLoading\"></myp-button>\n<myp-button icon=\"circle-wechat\" :text=\"null\" radius=\"ll\" iconType=\"success\" iconStyle=\"font-size: 100rpx;\" boxStyle=\"height: 100rpx;width: 100rpx;\" border=\"none\"></myp-button>\n```\n\n具体细节查看各个组件的文档。\n\n## 语义化与统一规范\n\n如何快速上手？如何降低学习成本？如何了解一个就是了解全部？如何减轻记忆压力，放下文档依赖？\n\n这一切还需要 **语义化的字段设计** 与 **统一规范的字段设计** 有关。\n\nmypUI 中组件的props都采用了规范与统一的命名规则。`xx` `xxType` `xxSize` `xxStyle`，你只需要知道一次，就能知道所有，并且随时都知道，因为没有模糊的设置，而且大家都彼此规则一样。\n\n这些规范涉及到了：\n\n- props的命名规范与统一，各种命名后缀都有特定的含义；\n\n- 响应事件的规范：`buttonClicked` `cellClicked` `...` 都是无需记忆的事件名字；\n\n`myp-button`中背景主题色叫做 `bgType`，`myp-cell`中背景主题色也是`bgType`。\n\n具体字段的设计规范，请查阅 [设计规范](/doc/guide/design.html)。\n\n## 文档分层，一目了然\n\n写文档是个技术活，看文档也是个难题。很多有用的东西，因为文档不全，或者文档可读性太差，大大提高了使用者的门槛，以及使用成本。\n\n而文档不分层，大量的props说明堆叠在一起，也难以一目了然，很大程度上增加了内容筛选的难度。\n\nmypUI 组件的文档，分为快捷设置，细节配置，进阶设置等层次。常规属性一目了然。降低阅读难度。\n\n## 抹平差异，减少配置\n\n在兼容各端的过程中，差异化的配置或者适配是不可避免的，但是很多差异是可以通过取舍以及封装抹平的。\n\n尤其是在app端的时候，导航栏各种设计，或者是tabbar的各种特效，使用自带的navbar或者tabbar很难满足要求，而个别页面自定义的话，又觉得风格不统一，甚至uni的在`pages.json`中的各种`subnvue`的配置实在是不够友好。\n\n这种情况，在快捷开发、便利性、统一性，与小程序端使用原生navbar的性能之间进行取舍。到底如何取舍？\n\n我的选择是去除掉系统自带的navbar和tabbar，去除掉`page.json`中各种设置，`pages.json`仅仅只是一个页面注册的地方。简单粗暴，快捷高效，各端开发基本统一，减少差异适配。\n\n当然，这仅仅只是我的选择。你依然有自由选择的权利。我们提供了自定义的navbar与tabbar。\n\n取舍，我们考虑：\n\n- 失去了什么：小程序端原生navbar比自定义的要好，但是这点性能基本上忽略不计了。因为我们都能够接受小程序端`scroll-view`自定义的下拉刷新。而在nvue-app，就更不要考虑这个性能的问题了。\n\n- 得到了什么：统一的开发方式，高效便捷，好维护。而且可实现全屏弹层，并且可以非常灵活的处理navbar层，适应各种设计；\n\n个人觉得，得大于失。在选择面前，我们不可能什么都兼顾，选择合适的就是好的。很多人纠结用这用那，其实在nvue出来之前，自己连vue页面都能够接受，结果nvue出来了，又在为这里那里纠结个不停。实在是得不偿失。赶紧动手，实现为上。去实现，去完成，去努力，去发光发热。\n\n另外就是封装组件，各端使用不同的组件时，将其封装进入一个组件，提供统一的开放接口和属性配置。比如`scroll-view`与`list`。\n\n## 复用与缓存，降低成本\n\n在开发的过程中，有些内容是多次需要的，而且很有可能是只需要计算一次的。但是因为某些原因，我们不得不重新获取或者计算。我们应该避免这种重复的行为，一是不太好维护，二是有些接口调用起来比较消耗。\n\n所以，我们把这些内容初始化一次，存放起来，封装一些方法，每次去取现成的就行。\n\n还有就是，在写代码的时候，某个页面或者组件难免会要求多次计算，但是前面的计算也是有效的，这个时候我们可以缓存已经有的计算，新的计算值不断缓存进去就行。没有必要一直从头开始。\n\n就好比，省市区三级一样，没有必要每一次省变了都去后台拉取市的信息，而是先检查缓存，缓存有就用缓存的，缓存没有才去拉取，拉取之后存入缓存。\n\n这是一种习惯，也是一种节约成本的方式。\n\n同时，大量可复用的mixin，也为你提供了极大的便利。\n\n## 性能优化\n\n性能优化，考虑几个方面。大多数的优化，uni已经帮我们做了。我们应该考虑什么？\n\n- bingdingX的运用；\n\n- 减少不必要的UI刷新；\n\n- 在必要的时候创建实例；\n\n- 及时销毁不需要的监听；\n\n## 更新策略与稳定性\n\n- mypUI 组件，基础组件已经趋向于稳定，19年双11的时候，mypUI 就已经有了上线的市场的能力，后来在内部使用改版多次，甚至还完全重构了一次，现在已经趋向稳定；\n\n- 我们会加大落地组件（开箱即用组件）的更新力度，满足一些拿来即用的用户需求。实际上，这些本来是没有什么太大的意义的，有一个快速开发的壳子就够了。但是考虑到很多开发者没有设计，没有产品，那就多多益善吧；\n\n- 每一次版本的更新会考虑对上一版的影响，即使有改动，也会列出来哪些地方做出了改动，用户需要升级调整；\n\n## 优秀的组件库\n\n<p class=\"tip\">我一直在想，一个优秀的组件库，应该备具哪些特质。我想前面列出的都具备的无疑是一个优秀的库。</p>\n\n一个组件库应该是经过设计和思考的。开发组件容易，但是开发一个适应于多数人的组件库就需要考虑很多。\n\n一个组件库，最优秀的能力，就是为一切不可能提供了可能，为一切不便利提供了便利。自由搭配与完全掌控的页面布局，完全便捷的安全区兼容，十分牛逼的全屏遮罩。\n\n一切的一切，无疑，都在说明一个事实：**mypUI 是一个优秀的库。**\n\n## 核心竞争力\n\n- header-swiper，不仅只是nvue-app端可以使用，在MP/H5端也能使用，而且支持刷新和加载更多。全端仿咸鱼/58成为可能；\n\n- chat-list，对于聊天列表，提供了两种考虑方式；\n\n- 性能、设计、快捷开发、效率等的多重考虑；\n\n- 页面管理非常灵活，没有做不到，只有想不到；\n\n- 体验最好的popup；\n\n- 最顺手的高度管理与计算，非常灵活的安全区兼容；\n\n- 自由畅想，就等你来；\n\n体验之后，你就会发现：真棒！\n\n## 选我没错\n\n说了这么多，哈哈哈哈，其实就是想告诉你：**不要纠结，选我没错！**\n\n**去用，去实现，去完成！**\n\n多谢支持。\n\n## 快速体验\n\n- 安装HBuilderX；\n- 下载或者clone本UI库；\n- 在HBuilderX里面打开或者导入；\n- 运行到自己想要体验的平台即可；\n\n<!-- zhlint ignore: min+gzip -->\n","date":"2020-07-21T12:50:25.099Z","updated":"2020-07-21T12:50:25.099Z","path":"doc/guide/why.html","comments":1,"layout":"page","_id":"ckcwngnk6001x9lxkxdlwmx6m","content":"<p>mypUI 是基于 uniapp 的一套组件库与工具集，可以 <strong>高效且规范</strong> 地开发出 uniapp 支持的各端应用（APP/各家小程序/H5/快应用）。兼容 nvue 页面 和 vue 页面。nvue 页面对应的 app端 依托 weex 编译为原生，具备良好的性能与体验。mypUI 绝对能为您带来 <strong>稳定、高效、规范</strong> 的开发体验。</p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>mypUI 从一开始就一直在思考如下几个问题：</p>\n<ul>\n<li><p>主题的支持，以及使用哪些配置可以满足一个恰到好处，不多不少的主题特性？</p>\n</li>\n<li><p>一个基础的组件，如何做到简单易用，又能够灵活的适配？</p>\n</li>\n<li><p>UI库往往带有很多组件，如何最大程度的降低学习成本与熟练成本，怎样才能最快上手？</p>\n</li>\n<li><p>文档的可读性和可理解性，一个细致化的组件开放的属性可能几十个，如何满足新手的可读性与可理解性？</p>\n</li>\n<li><p>各端的兼容往往会导致各端的差异化适配，而差异化的适配往往会降低开发的效率，如何在保证性能的基础上提高开发的效率？</p>\n</li>\n<li><p>有很多变量的值，他们可能是计算而得，可能是通过api获取而得，这些值在UI内用到，用户也会经常用到，是不是可以只计算或获取一次？</p>\n</li>\n<li><p>如何能够让使用者加快开发速度，减少文档依赖，减少记忆成本？</p>\n</li>\n<li><p>版本的成熟性与稳定性，是不是一直维护？如何兼容版本更新，降低更新成本？</p>\n</li>\n<li><p>一个组件库最重要的是什么？到底满足什么才能算是一个好的组件库？</p>\n</li>\n<li><p>为什么要用这个库，她能带来什么好处？她的核心竞争力在哪里？</p>\n</li>\n</ul>\n<p class=\"tip\">以上的思考，有些是我们开发过程中需要思考的问题，有些是我们在使用第三库时遇到的问题，或者我们在开发库时需要考虑的问题。这些问题得到一个妥善的解决，绝对是一个绝佳的高效工具</p>\n\n<p>下面我们就来回答这些问题，这也是我们推荐您使用 mypUI 的真正原因，也是 mypUI 的真正魅力所在。</p>\n<h2 id=\"可配置的主题设计\"><a href=\"#可配置的主题设计\" class=\"headerlink\" title=\"可配置的主题设计\"></a>可配置的主题设计</h2><p>mypUI 设计规范和技术上支持灵活的样式定制，以满足业务和品牌上多样化的视觉需求，包括但不限于全局样式（主色、圆角、边框）和指定组件的视觉定制。</p>\n<p><img src=\"/images/doc/button.png\" alt=\"主题配置\"></p>\n<p>mypUI 的样式采用了 scss 作为开发语言，并定义了一系列全局的样式变量，您可以根据需求进行相应的调整。</p>\n<p>其中包含了 主题、文字、边框、圆角、字号、尺寸 等多种通用变量，所有的样式变量以及具体的使用说明在 <a href=\"/doc/guide/theme.html\">这里</a> 找到。</p>\n<p>如果以上变量不能满足你的定制需求，可以给我们提 issue。</p>\n<p>当然，对于您自己添加变量，那也是非常的方便。更多主题配置的内容将在 <a href=\"/doc/guide/theme.html\">主题配置</a> 讲解。</p>\n<h2 id=\"快捷配置与灵活订制\"><a href=\"#快捷配置与灵活订制\" class=\"headerlink\" title=\"快捷配置与灵活订制\"></a>快捷配置与灵活订制</h2><p>mypUI 中的组件几乎开放了所有的可配置项，在满足主题配置的同时，也支持个性化的适配。</p>\n<p>比如 <code>myp-button</code> 组件，可以通过 <code>bgType</code> <code>border</code> <code>radius</code> <code>icon</code> <code>text</code> <code>height</code> 快速实现样式与主题配置。非常方便快捷，也很容易上手。</p>\n<p>如果在这些配置的基础上，还不能满足一些特殊的要求，您可以设置各种 <code>style</code> 来满足您的要求，比如 <code>textStyle</code> <code>boxStyle</code> <code>iconStyle</code> 等。</p>\n<p>mypUI 组件既能满足一键式的快捷配置，也能满足几乎所有元素的细节配置。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">myp-button</span> <span class=\"hljs-attr\">icon</span>=<span class=\"hljs-string\">\"plus\"</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">\"左侧带图标\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">myp-button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">myp-button</span> <span class=\"hljs-attr\">:loading</span>=<span class=\"hljs-string\">\"loadingVisible\"</span> <span class=\"hljs-attr\">bgType</span>=<span class=\"hljs-string\">\"success\"</span> <span class=\"hljs-attr\">icon</span>=<span class=\"hljs-string\">\"wechat\"</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">\"点击切换加载状态\"</span> @<span class=\"hljs-attr\">buttonClicked</span>=<span class=\"hljs-string\">\"toggleLoading\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">myp-button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">myp-button</span> <span class=\"hljs-attr\">icon</span>=<span class=\"hljs-string\">\"circle-wechat\"</span> <span class=\"hljs-attr\">:text</span>=<span class=\"hljs-string\">\"null\"</span> <span class=\"hljs-attr\">radius</span>=<span class=\"hljs-string\">\"ll\"</span> <span class=\"hljs-attr\">iconType</span>=<span class=\"hljs-string\">\"success\"</span> <span class=\"hljs-attr\">iconStyle</span>=<span class=\"hljs-string\">\"font-size: 100rpx;\"</span> <span class=\"hljs-attr\">boxStyle</span>=<span class=\"hljs-string\">\"height: 100rpx;width: 100rpx;\"</span> <span class=\"hljs-attr\">border</span>=<span class=\"hljs-string\">\"none\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">myp-button</span>&gt;</span></code></pre>\n<p>具体细节查看各个组件的文档。</p>\n<h2 id=\"语义化与统一规范\"><a href=\"#语义化与统一规范\" class=\"headerlink\" title=\"语义化与统一规范\"></a>语义化与统一规范</h2><p>如何快速上手？如何降低学习成本？如何了解一个就是了解全部？如何减轻记忆压力，放下文档依赖？</p>\n<p>这一切还需要 <strong>语义化的字段设计</strong> 与 <strong>统一规范的字段设计</strong> 有关。</p>\n<p>mypUI 中组件的props都采用了规范与统一的命名规则。<code>xx</code> <code>xxType</code> <code>xxSize</code> <code>xxStyle</code>，你只需要知道一次，就能知道所有，并且随时都知道，因为没有模糊的设置，而且大家都彼此规则一样。</p>\n<p>这些规范涉及到了：</p>\n<ul>\n<li><p>props的命名规范与统一，各种命名后缀都有特定的含义；</p>\n</li>\n<li><p>响应事件的规范：<code>buttonClicked</code> <code>cellClicked</code> <code>...</code> 都是无需记忆的事件名字；</p>\n</li>\n</ul>\n<p><code>myp-button</code>中背景主题色叫做 <code>bgType</code>，<code>myp-cell</code>中背景主题色也是<code>bgType</code>。</p>\n<p>具体字段的设计规范，请查阅 <a href=\"/doc/guide/design.html\">设计规范</a>。</p>\n<h2 id=\"文档分层，一目了然\"><a href=\"#文档分层，一目了然\" class=\"headerlink\" title=\"文档分层，一目了然\"></a>文档分层，一目了然</h2><p>写文档是个技术活，看文档也是个难题。很多有用的东西，因为文档不全，或者文档可读性太差，大大提高了使用者的门槛，以及使用成本。</p>\n<p>而文档不分层，大量的props说明堆叠在一起，也难以一目了然，很大程度上增加了内容筛选的难度。</p>\n<p>mypUI 组件的文档，分为快捷设置，细节配置，进阶设置等层次。常规属性一目了然。降低阅读难度。</p>\n<h2 id=\"抹平差异，减少配置\"><a href=\"#抹平差异，减少配置\" class=\"headerlink\" title=\"抹平差异，减少配置\"></a>抹平差异，减少配置</h2><p>在兼容各端的过程中，差异化的配置或者适配是不可避免的，但是很多差异是可以通过取舍以及封装抹平的。</p>\n<p>尤其是在app端的时候，导航栏各种设计，或者是tabbar的各种特效，使用自带的navbar或者tabbar很难满足要求，而个别页面自定义的话，又觉得风格不统一，甚至uni的在<code>pages.json</code>中的各种<code>subnvue</code>的配置实在是不够友好。</p>\n<p>这种情况，在快捷开发、便利性、统一性，与小程序端使用原生navbar的性能之间进行取舍。到底如何取舍？</p>\n<p>我的选择是去除掉系统自带的navbar和tabbar，去除掉<code>page.json</code>中各种设置，<code>pages.json</code>仅仅只是一个页面注册的地方。简单粗暴，快捷高效，各端开发基本统一，减少差异适配。</p>\n<p>当然，这仅仅只是我的选择。你依然有自由选择的权利。我们提供了自定义的navbar与tabbar。</p>\n<p>取舍，我们考虑：</p>\n<ul>\n<li><p>失去了什么：小程序端原生navbar比自定义的要好，但是这点性能基本上忽略不计了。因为我们都能够接受小程序端<code>scroll-view</code>自定义的下拉刷新。而在nvue-app，就更不要考虑这个性能的问题了。</p>\n</li>\n<li><p>得到了什么：统一的开发方式，高效便捷，好维护。而且可实现全屏弹层，并且可以非常灵活的处理navbar层，适应各种设计；</p>\n</li>\n</ul>\n<p>个人觉得，得大于失。在选择面前，我们不可能什么都兼顾，选择合适的就是好的。很多人纠结用这用那，其实在nvue出来之前，自己连vue页面都能够接受，结果nvue出来了，又在为这里那里纠结个不停。实在是得不偿失。赶紧动手，实现为上。去实现，去完成，去努力，去发光发热。</p>\n<p>另外就是封装组件，各端使用不同的组件时，将其封装进入一个组件，提供统一的开放接口和属性配置。比如<code>scroll-view</code>与<code>list</code>。</p>\n<h2 id=\"复用与缓存，降低成本\"><a href=\"#复用与缓存，降低成本\" class=\"headerlink\" title=\"复用与缓存，降低成本\"></a>复用与缓存，降低成本</h2><p>在开发的过程中，有些内容是多次需要的，而且很有可能是只需要计算一次的。但是因为某些原因，我们不得不重新获取或者计算。我们应该避免这种重复的行为，一是不太好维护，二是有些接口调用起来比较消耗。</p>\n<p>所以，我们把这些内容初始化一次，存放起来，封装一些方法，每次去取现成的就行。</p>\n<p>还有就是，在写代码的时候，某个页面或者组件难免会要求多次计算，但是前面的计算也是有效的，这个时候我们可以缓存已经有的计算，新的计算值不断缓存进去就行。没有必要一直从头开始。</p>\n<p>就好比，省市区三级一样，没有必要每一次省变了都去后台拉取市的信息，而是先检查缓存，缓存有就用缓存的，缓存没有才去拉取，拉取之后存入缓存。</p>\n<p>这是一种习惯，也是一种节约成本的方式。</p>\n<p>同时，大量可复用的mixin，也为你提供了极大的便利。</p>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><p>性能优化，考虑几个方面。大多数的优化，uni已经帮我们做了。我们应该考虑什么？</p>\n<ul>\n<li><p>bingdingX的运用；</p>\n</li>\n<li><p>减少不必要的UI刷新；</p>\n</li>\n<li><p>在必要的时候创建实例；</p>\n</li>\n<li><p>及时销毁不需要的监听；</p>\n</li>\n</ul>\n<h2 id=\"更新策略与稳定性\"><a href=\"#更新策略与稳定性\" class=\"headerlink\" title=\"更新策略与稳定性\"></a>更新策略与稳定性</h2><ul>\n<li><p>mypUI 组件，基础组件已经趋向于稳定，19年双11的时候，mypUI 就已经有了上线的市场的能力，后来在内部使用改版多次，甚至还完全重构了一次，现在已经趋向稳定；</p>\n</li>\n<li><p>我们会加大落地组件（开箱即用组件）的更新力度，满足一些拿来即用的用户需求。实际上，这些本来是没有什么太大的意义的，有一个快速开发的壳子就够了。但是考虑到很多开发者没有设计，没有产品，那就多多益善吧；</p>\n</li>\n<li><p>每一次版本的更新会考虑对上一版的影响，即使有改动，也会列出来哪些地方做出了改动，用户需要升级调整；</p>\n</li>\n</ul>\n<h2 id=\"优秀的组件库\"><a href=\"#优秀的组件库\" class=\"headerlink\" title=\"优秀的组件库\"></a>优秀的组件库</h2><p class=\"tip\">我一直在想，一个优秀的组件库，应该备具哪些特质。我想前面列出的都具备的无疑是一个优秀的库。</p>\n\n<p>一个组件库应该是经过设计和思考的。开发组件容易，但是开发一个适应于多数人的组件库就需要考虑很多。</p>\n<p>一个组件库，最优秀的能力，就是为一切不可能提供了可能，为一切不便利提供了便利。自由搭配与完全掌控的页面布局，完全便捷的安全区兼容，十分牛逼的全屏遮罩。</p>\n<p>一切的一切，无疑，都在说明一个事实：<strong>mypUI 是一个优秀的库。</strong></p>\n<h2 id=\"核心竞争力\"><a href=\"#核心竞争力\" class=\"headerlink\" title=\"核心竞争力\"></a>核心竞争力</h2><ul>\n<li><p>header-swiper，不仅只是nvue-app端可以使用，在MP/H5端也能使用，而且支持刷新和加载更多。全端仿咸鱼/58成为可能；</p>\n</li>\n<li><p>chat-list，对于聊天列表，提供了两种考虑方式；</p>\n</li>\n<li><p>性能、设计、快捷开发、效率等的多重考虑；</p>\n</li>\n<li><p>页面管理非常灵活，没有做不到，只有想不到；</p>\n</li>\n<li><p>体验最好的popup；</p>\n</li>\n<li><p>最顺手的高度管理与计算，非常灵活的安全区兼容；</p>\n</li>\n<li><p>自由畅想，就等你来；</p>\n</li>\n</ul>\n<p>体验之后，你就会发现：真棒！</p>\n<h2 id=\"选我没错\"><a href=\"#选我没错\" class=\"headerlink\" title=\"选我没错\"></a>选我没错</h2><p>说了这么多，哈哈哈哈，其实就是想告诉你：<strong>不要纠结，选我没错！</strong></p>\n<p><strong>去用，去实现，去完成！</strong></p>\n<p>多谢支持。</p>\n<h2 id=\"快速体验\"><a href=\"#快速体验\" class=\"headerlink\" title=\"快速体验\"></a>快速体验</h2><ul>\n<li>安装HBuilderX；</li>\n<li>下载或者clone本UI库；</li>\n<li>在HBuilderX里面打开或者导入；</li>\n<li>运行到自己想要体验的平台即可；</li>\n</ul>\n<!-- zhlint ignore: min+gzip -->\n","site":{"data":{}},"excerpt":"","more":"<p>mypUI 是基于 uniapp 的一套组件库与工具集，可以 <strong>高效且规范</strong> 地开发出 uniapp 支持的各端应用（APP/各家小程序/H5/快应用）。兼容 nvue 页面 和 vue 页面。nvue 页面对应的 app端 依托 weex 编译为原生，具备良好的性能与体验。mypUI 绝对能为您带来 <strong>稳定、高效、规范</strong> 的开发体验。</p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>mypUI 从一开始就一直在思考如下几个问题：</p>\n<ul>\n<li><p>主题的支持，以及使用哪些配置可以满足一个恰到好处，不多不少的主题特性？</p>\n</li>\n<li><p>一个基础的组件，如何做到简单易用，又能够灵活的适配？</p>\n</li>\n<li><p>UI库往往带有很多组件，如何最大程度的降低学习成本与熟练成本，怎样才能最快上手？</p>\n</li>\n<li><p>文档的可读性和可理解性，一个细致化的组件开放的属性可能几十个，如何满足新手的可读性与可理解性？</p>\n</li>\n<li><p>各端的兼容往往会导致各端的差异化适配，而差异化的适配往往会降低开发的效率，如何在保证性能的基础上提高开发的效率？</p>\n</li>\n<li><p>有很多变量的值，他们可能是计算而得，可能是通过api获取而得，这些值在UI内用到，用户也会经常用到，是不是可以只计算或获取一次？</p>\n</li>\n<li><p>如何能够让使用者加快开发速度，减少文档依赖，减少记忆成本？</p>\n</li>\n<li><p>版本的成熟性与稳定性，是不是一直维护？如何兼容版本更新，降低更新成本？</p>\n</li>\n<li><p>一个组件库最重要的是什么？到底满足什么才能算是一个好的组件库？</p>\n</li>\n<li><p>为什么要用这个库，她能带来什么好处？她的核心竞争力在哪里？</p>\n</li>\n</ul>\n<p class=\"tip\">以上的思考，有些是我们开发过程中需要思考的问题，有些是我们在使用第三库时遇到的问题，或者我们在开发库时需要考虑的问题。这些问题得到一个妥善的解决，绝对是一个绝佳的高效工具</p>\n\n<p>下面我们就来回答这些问题，这也是我们推荐您使用 mypUI 的真正原因，也是 mypUI 的真正魅力所在。</p>\n<h2 id=\"可配置的主题设计\"><a href=\"#可配置的主题设计\" class=\"headerlink\" title=\"可配置的主题设计\"></a>可配置的主题设计</h2><p>mypUI 设计规范和技术上支持灵活的样式定制，以满足业务和品牌上多样化的视觉需求，包括但不限于全局样式（主色、圆角、边框）和指定组件的视觉定制。</p>\n<p><img src=\"/images/doc/button.png\" alt=\"主题配置\"></p>\n<p>mypUI 的样式采用了 scss 作为开发语言，并定义了一系列全局的样式变量，您可以根据需求进行相应的调整。</p>\n<p>其中包含了 主题、文字、边框、圆角、字号、尺寸 等多种通用变量，所有的样式变量以及具体的使用说明在 <a href=\"/doc/guide/theme.html\">这里</a> 找到。</p>\n<p>如果以上变量不能满足你的定制需求，可以给我们提 issue。</p>\n<p>当然，对于您自己添加变量，那也是非常的方便。更多主题配置的内容将在 <a href=\"/doc/guide/theme.html\">主题配置</a> 讲解。</p>\n<h2 id=\"快捷配置与灵活订制\"><a href=\"#快捷配置与灵活订制\" class=\"headerlink\" title=\"快捷配置与灵活订制\"></a>快捷配置与灵活订制</h2><p>mypUI 中的组件几乎开放了所有的可配置项，在满足主题配置的同时，也支持个性化的适配。</p>\n<p>比如 <code>myp-button</code> 组件，可以通过 <code>bgType</code> <code>border</code> <code>radius</code> <code>icon</code> <code>text</code> <code>height</code> 快速实现样式与主题配置。非常方便快捷，也很容易上手。</p>\n<p>如果在这些配置的基础上，还不能满足一些特殊的要求，您可以设置各种 <code>style</code> 来满足您的要求，比如 <code>textStyle</code> <code>boxStyle</code> <code>iconStyle</code> 等。</p>\n<p>mypUI 组件既能满足一键式的快捷配置，也能满足几乎所有元素的细节配置。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">myp-button</span> <span class=\"hljs-attr\">icon</span>=<span class=\"hljs-string\">\"plus\"</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">\"左侧带图标\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">myp-button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">myp-button</span> <span class=\"hljs-attr\">:loading</span>=<span class=\"hljs-string\">\"loadingVisible\"</span> <span class=\"hljs-attr\">bgType</span>=<span class=\"hljs-string\">\"success\"</span> <span class=\"hljs-attr\">icon</span>=<span class=\"hljs-string\">\"wechat\"</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">\"点击切换加载状态\"</span> @<span class=\"hljs-attr\">buttonClicked</span>=<span class=\"hljs-string\">\"toggleLoading\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">myp-button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">myp-button</span> <span class=\"hljs-attr\">icon</span>=<span class=\"hljs-string\">\"circle-wechat\"</span> <span class=\"hljs-attr\">:text</span>=<span class=\"hljs-string\">\"null\"</span> <span class=\"hljs-attr\">radius</span>=<span class=\"hljs-string\">\"ll\"</span> <span class=\"hljs-attr\">iconType</span>=<span class=\"hljs-string\">\"success\"</span> <span class=\"hljs-attr\">iconStyle</span>=<span class=\"hljs-string\">\"font-size: 100rpx;\"</span> <span class=\"hljs-attr\">boxStyle</span>=<span class=\"hljs-string\">\"height: 100rpx;width: 100rpx;\"</span> <span class=\"hljs-attr\">border</span>=<span class=\"hljs-string\">\"none\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">myp-button</span>&gt;</span></code></pre>\n<p>具体细节查看各个组件的文档。</p>\n<h2 id=\"语义化与统一规范\"><a href=\"#语义化与统一规范\" class=\"headerlink\" title=\"语义化与统一规范\"></a>语义化与统一规范</h2><p>如何快速上手？如何降低学习成本？如何了解一个就是了解全部？如何减轻记忆压力，放下文档依赖？</p>\n<p>这一切还需要 <strong>语义化的字段设计</strong> 与 <strong>统一规范的字段设计</strong> 有关。</p>\n<p>mypUI 中组件的props都采用了规范与统一的命名规则。<code>xx</code> <code>xxType</code> <code>xxSize</code> <code>xxStyle</code>，你只需要知道一次，就能知道所有，并且随时都知道，因为没有模糊的设置，而且大家都彼此规则一样。</p>\n<p>这些规范涉及到了：</p>\n<ul>\n<li><p>props的命名规范与统一，各种命名后缀都有特定的含义；</p>\n</li>\n<li><p>响应事件的规范：<code>buttonClicked</code> <code>cellClicked</code> <code>...</code> 都是无需记忆的事件名字；</p>\n</li>\n</ul>\n<p><code>myp-button</code>中背景主题色叫做 <code>bgType</code>，<code>myp-cell</code>中背景主题色也是<code>bgType</code>。</p>\n<p>具体字段的设计规范，请查阅 <a href=\"/doc/guide/design.html\">设计规范</a>。</p>\n<h2 id=\"文档分层，一目了然\"><a href=\"#文档分层，一目了然\" class=\"headerlink\" title=\"文档分层，一目了然\"></a>文档分层，一目了然</h2><p>写文档是个技术活，看文档也是个难题。很多有用的东西，因为文档不全，或者文档可读性太差，大大提高了使用者的门槛，以及使用成本。</p>\n<p>而文档不分层，大量的props说明堆叠在一起，也难以一目了然，很大程度上增加了内容筛选的难度。</p>\n<p>mypUI 组件的文档，分为快捷设置，细节配置，进阶设置等层次。常规属性一目了然。降低阅读难度。</p>\n<h2 id=\"抹平差异，减少配置\"><a href=\"#抹平差异，减少配置\" class=\"headerlink\" title=\"抹平差异，减少配置\"></a>抹平差异，减少配置</h2><p>在兼容各端的过程中，差异化的配置或者适配是不可避免的，但是很多差异是可以通过取舍以及封装抹平的。</p>\n<p>尤其是在app端的时候，导航栏各种设计，或者是tabbar的各种特效，使用自带的navbar或者tabbar很难满足要求，而个别页面自定义的话，又觉得风格不统一，甚至uni的在<code>pages.json</code>中的各种<code>subnvue</code>的配置实在是不够友好。</p>\n<p>这种情况，在快捷开发、便利性、统一性，与小程序端使用原生navbar的性能之间进行取舍。到底如何取舍？</p>\n<p>我的选择是去除掉系统自带的navbar和tabbar，去除掉<code>page.json</code>中各种设置，<code>pages.json</code>仅仅只是一个页面注册的地方。简单粗暴，快捷高效，各端开发基本统一，减少差异适配。</p>\n<p>当然，这仅仅只是我的选择。你依然有自由选择的权利。我们提供了自定义的navbar与tabbar。</p>\n<p>取舍，我们考虑：</p>\n<ul>\n<li><p>失去了什么：小程序端原生navbar比自定义的要好，但是这点性能基本上忽略不计了。因为我们都能够接受小程序端<code>scroll-view</code>自定义的下拉刷新。而在nvue-app，就更不要考虑这个性能的问题了。</p>\n</li>\n<li><p>得到了什么：统一的开发方式，高效便捷，好维护。而且可实现全屏弹层，并且可以非常灵活的处理navbar层，适应各种设计；</p>\n</li>\n</ul>\n<p>个人觉得，得大于失。在选择面前，我们不可能什么都兼顾，选择合适的就是好的。很多人纠结用这用那，其实在nvue出来之前，自己连vue页面都能够接受，结果nvue出来了，又在为这里那里纠结个不停。实在是得不偿失。赶紧动手，实现为上。去实现，去完成，去努力，去发光发热。</p>\n<p>另外就是封装组件，各端使用不同的组件时，将其封装进入一个组件，提供统一的开放接口和属性配置。比如<code>scroll-view</code>与<code>list</code>。</p>\n<h2 id=\"复用与缓存，降低成本\"><a href=\"#复用与缓存，降低成本\" class=\"headerlink\" title=\"复用与缓存，降低成本\"></a>复用与缓存，降低成本</h2><p>在开发的过程中，有些内容是多次需要的，而且很有可能是只需要计算一次的。但是因为某些原因，我们不得不重新获取或者计算。我们应该避免这种重复的行为，一是不太好维护，二是有些接口调用起来比较消耗。</p>\n<p>所以，我们把这些内容初始化一次，存放起来，封装一些方法，每次去取现成的就行。</p>\n<p>还有就是，在写代码的时候，某个页面或者组件难免会要求多次计算，但是前面的计算也是有效的，这个时候我们可以缓存已经有的计算，新的计算值不断缓存进去就行。没有必要一直从头开始。</p>\n<p>就好比，省市区三级一样，没有必要每一次省变了都去后台拉取市的信息，而是先检查缓存，缓存有就用缓存的，缓存没有才去拉取，拉取之后存入缓存。</p>\n<p>这是一种习惯，也是一种节约成本的方式。</p>\n<p>同时，大量可复用的mixin，也为你提供了极大的便利。</p>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><p>性能优化，考虑几个方面。大多数的优化，uni已经帮我们做了。我们应该考虑什么？</p>\n<ul>\n<li><p>bingdingX的运用；</p>\n</li>\n<li><p>减少不必要的UI刷新；</p>\n</li>\n<li><p>在必要的时候创建实例；</p>\n</li>\n<li><p>及时销毁不需要的监听；</p>\n</li>\n</ul>\n<h2 id=\"更新策略与稳定性\"><a href=\"#更新策略与稳定性\" class=\"headerlink\" title=\"更新策略与稳定性\"></a>更新策略与稳定性</h2><ul>\n<li><p>mypUI 组件，基础组件已经趋向于稳定，19年双11的时候，mypUI 就已经有了上线的市场的能力，后来在内部使用改版多次，甚至还完全重构了一次，现在已经趋向稳定；</p>\n</li>\n<li><p>我们会加大落地组件（开箱即用组件）的更新力度，满足一些拿来即用的用户需求。实际上，这些本来是没有什么太大的意义的，有一个快速开发的壳子就够了。但是考虑到很多开发者没有设计，没有产品，那就多多益善吧；</p>\n</li>\n<li><p>每一次版本的更新会考虑对上一版的影响，即使有改动，也会列出来哪些地方做出了改动，用户需要升级调整；</p>\n</li>\n</ul>\n<h2 id=\"优秀的组件库\"><a href=\"#优秀的组件库\" class=\"headerlink\" title=\"优秀的组件库\"></a>优秀的组件库</h2><p class=\"tip\">我一直在想，一个优秀的组件库，应该备具哪些特质。我想前面列出的都具备的无疑是一个优秀的库。</p>\n\n<p>一个组件库应该是经过设计和思考的。开发组件容易，但是开发一个适应于多数人的组件库就需要考虑很多。</p>\n<p>一个组件库，最优秀的能力，就是为一切不可能提供了可能，为一切不便利提供了便利。自由搭配与完全掌控的页面布局，完全便捷的安全区兼容，十分牛逼的全屏遮罩。</p>\n<p>一切的一切，无疑，都在说明一个事实：<strong>mypUI 是一个优秀的库。</strong></p>\n<h2 id=\"核心竞争力\"><a href=\"#核心竞争力\" class=\"headerlink\" title=\"核心竞争力\"></a>核心竞争力</h2><ul>\n<li><p>header-swiper，不仅只是nvue-app端可以使用，在MP/H5端也能使用，而且支持刷新和加载更多。全端仿咸鱼/58成为可能；</p>\n</li>\n<li><p>chat-list，对于聊天列表，提供了两种考虑方式；</p>\n</li>\n<li><p>性能、设计、快捷开发、效率等的多重考虑；</p>\n</li>\n<li><p>页面管理非常灵活，没有做不到，只有想不到；</p>\n</li>\n<li><p>体验最好的popup；</p>\n</li>\n<li><p>最顺手的高度管理与计算，非常灵活的安全区兼容；</p>\n</li>\n<li><p>自由畅想，就等你来；</p>\n</li>\n</ul>\n<p>体验之后，你就会发现：真棒！</p>\n<h2 id=\"选我没错\"><a href=\"#选我没错\" class=\"headerlink\" title=\"选我没错\"></a>选我没错</h2><p>说了这么多，哈哈哈哈，其实就是想告诉你：<strong>不要纠结，选我没错！</strong></p>\n<p><strong>去用，去实现，去完成！</strong></p>\n<p>多谢支持。</p>\n<h2 id=\"快速体验\"><a href=\"#快速体验\" class=\"headerlink\" title=\"快速体验\"></a>快速体验</h2><ul>\n<li>安装HBuilderX；</li>\n<li>下载或者clone本UI库；</li>\n<li>在HBuilderX里面打开或者导入；</li>\n<li>运行到自己想要体验的平台即可；</li>\n</ul>\n<!-- zhlint ignore: min+gzip -->\n"},{"title":"认识团队","type":"guide","order":800,"_content":"\n{% raw %}\n<script id=\"vuer-profile-template\" type=\"text/template\">\n  <div class=\"vuer\">\n    <div class=\"avatar\">\n      <img v-if=\"profile.imageUrl\"\n        :src=\"profile.imageUrl\"\n        :alt=\"profile.name\" width=80 height=80>\n      <img v-else-if=\"profile.github\"\n        :src=\"'https://github.com/' + profile.github + '.png'\"\n        :alt=\"profile.name\" width=80 height=80>\n      <img v-else-if=\"profile.twitter\"\n        :src=\"'https://avatars.io/twitter/' + profile.twitter\"\n        :alt=\"profile.name\" width=80 height=80>\n    </div>\n    <div class=\"profile\">\n      <h3 :data-official-title=\"profile.title\">\n        {{ profile.name }}\n        <sup v-if=\"profile.title && titleVisible\" v-html=\"profile.title\"></sup>\n      </h3>\n      <dl>\n        <template v-if=\"profile.reposOfficial\">\n          <dt>Core focus</dt>\n          <dd>\n            <ul>\n              <li v-for=\"repo in profile.reposOfficial\">\n                <a :href=\"githubUrl('vuejs', repo)\" target=_blank rel=\"noopener noreferrer\">{{ repo.name || repo }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <template v-if=\"profile.github && profile.reposPersonal\">\n          <dt>Ecosystem</dt>\n          <dd>\n            <ul>\n              <li v-for=\"repo in profile.reposPersonal\">\n                <a :href=\"githubUrl(profile.github, repo)\" target=_blank rel=\"noopener noreferrer\">{{ repo.name || repo }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <template v-if=\"profile.work\">\n          <dt>\n            <i class=\"fa fa-briefcase\"></i>\n            <span class=\"sr-only\">Work</span>\n          </dt>\n          <dd v-html=\"workHtml\"></dd>\n        </template>\n        <span v-if=\"profile.distanceInKm\" class=\"distance\">\n          <dt>\n            <i class=\"fa fa-map-marker\"></i>\n            <span class=\"sr-only\">Distance</span>\n          </dt>\n          <dd>\n            About\n            <span\n              v-if=\"profile.distanceInKm <= 150\"\n              :title=\"profile.name + ' is close enough to commute to your location.'\"\n              class=\"user-match\"\n            >{{ textDistance }} away</span>\n            <template v-else>{{ textDistance }} away</template>\n            in {{ profile.city }}\n          </dd>\n        </span>\n        <template v-else-if=\"profile.city\">\n          <dt>\n            <i class=\"fa fa-map-marker\"></i>\n            <span class=\"sr-only\">City</span>\n          </dt>\n          <dd>\n            {{ profile.city }}\n          </dd>\n        </template>\n        <template v-if=\"profile.links\">\n          <dt>\n            <i class=\"fa fa-link\"></i>\n            <span class=\"sr-only\">Links</span>\n          </dt>\n          <dd>\n            <ul>\n              <li v-for=\"link in profile.links\">\n                <a :href=\"link\" target=_blank>{{ minimizeLink(link) }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <footer v-if=\"hasSocialLinks\" class=\"social\">\n          <a class=github v-if=\"profile.github\" :href=\"githubUrl(profile.github)\">\n            <i class=\"fa fa-github\"></i>\n            <span class=\"sr-only\">Github</span>\n          </a>\n          <a class=twitter v-if=\"profile.twitter\" :href=\"'https://twitter.com/' + profile.twitter\">\n            <i class=\"fa fa-twitter\"></i>\n            <span class=\"sr-only\">Twitter</span>\n          </a>\n          <a class=codepen v-if=\"profile.codepen\" :href=\"'https://codepen.io/' + profile.codepen\">\n            <i class=\"fa fa-codepen\"></i>\n            <span class=\"sr-only\">CodePen</span>\n          </a>\n          <a class=linkedin v-if=\"profile.linkedin\" :href=\"'https://www.linkedin.com/in/' + profile.linkedin\">\n            <i class=\"fa fa-linkedin\"></i>\n            <span class=\"sr-only\">LinkedIn</span>\n          </a>\n        </footer>\n      </dl>\n    </div>\n  </div>\n</script>\n\n<div id=\"team-members\">\n  <div class=\"team\">\n\n    <h2 id=\"active-core-team-members\">\n      核心团队活跃成员\n      <button\n        v-if=\"geolocationSupported && !userPosition\"\n        @click=\"getUserPosition\"\n        :disabled=\"isSorting\"\n        class=\"sort-by-distance-button\"\n      >\n        <i\n          v-if=\"isSorting\"\n          class=\"fa fa-refresh rotating-clockwise\"\n        ></i>\n        <template v-else>\n          <i class=\"fa fa-map-marker\"></i>\n          <span>谁在我附近</span>\n        </template>\n      </button>\n    </h2>\n\n    <p v-if=\"errorGettingLocation\" class=\"tip\">\n      未成功获取您的位置。\n    </p>\n\n    <p>\n      mypUI 的开发及其生态建设来自不同的省份与技术领域，这里会展示其中部分团队成员的信息。\n    </p>\n\n    <p v-if=\"userPosition\" class=\"success\">\n      核心团队成员已经按照跟你的距离排序。\n    </p>\n\n    <vuer-profile\n      v-for=\"profile in sortedTeam\"\n      :key=\"profile.name\"\n      :profile=\"profile\"\n      :title-visible=\"titleVisible\"\n    ></vuer-profile>\n  </div>\n\n  <div class=\"team\">\n    <h2 id=\"core-team-emeriti\">\n      核心团队荣誉成员\n    </h2>\n\n    <p>\n      我们在此致敬过去曾做出过突出贡献的不再活跃的团队成员。\n    </p>\n\n    <vuer-profile\n      v-for=\"profile in teamEmeriti\"\n      :key=\"profile.name\"\n      :profile=\"profile\"\n      :title-visible=\"titleVisible\"\n    ></vuer-profile>\n  </div>\n\n  <div class=\"team\">\n    <h2 id=\"community-partners\">\n      社区伙伴\n      <button\n        v-if=\"geolocationSupported && !userPosition\"\n        @click=\"getUserPosition\"\n        :disabled=\"isSorting\"\n        class=\"sort-by-distance-button\"\n      >\n        <i\n          v-if=\"isSorting\"\n          class=\"fa fa-refresh rotating-clockwise\"\n        ></i>\n        <template v-else>\n          <i class=\"fa fa-map-marker\"></i>\n          <span>谁在我附近</span>\n        </template>\n      </button>\n    </h2>\n\n    <p v-if=\"errorGettingLocation\" class=\"tip\">\n      未成功获取您的位置。\n    </p>\n\n    <p>\n      一些 mypUI 的社区成员让这里变得更加丰富多彩，有必要在此特别提及。我们与这些主要合作伙伴建立了更加亲密的关系，经常与他们就即将到来的功能和新闻展开协作。\n    </p>\n\n    <p v-if=\"userPosition\" class=\"success\">\n      社区伙伴们已经按照跟你的距离排序。\n    </p>\n\n    <vuer-profile\n      v-for=\"profile in sortedPartners\"\n      :key=\"profile.name\"\n      :profile=\"profile\"\n      :title-visible=\"titleVisible\"\n    ></vuer-profile>\n  </div>\n</div>\n\n<script>\n(function () {\n  var cityCoordsFor = {\n    '北京': [39.904200, 116.407396]\n  }\n\n  var team = [{\n    name: '马玉平',\n    title: '身体好才是真的好',\n    city: '北京',\n    github: 'wakaryry',\n    work: {\n      role: 'Creator',\n      org: 'mypUI'\n    },\n    links: [\n      'https://github.com/wakaryry'\n    ]\n  }]\n\n  team = team.concat(shuffle([\n  ]))\n\n  var emeriti = shuffle([\n  ])\n\n  var partners = [\n  ]\n\n  Vue.component('vuer-profile', {\n    template: '#vuer-profile-template',\n    props: {\n      profile: Object,\n      titleVisible: Boolean\n    },\n    computed: {\n      workHtml: function () {\n        var work = this.profile.work\n        var html = ''\n        if (work.orgUrl) {\n          html += '<a href=\"' + work.orgUrl + '\" target=\"_blank\" rel=\"noopener noreferrer\">'\n          if (work.org) {\n            html += work.org\n          } else {\n            this.minimizeLink(work.orgUrl)\n          }\n          html += '</a>'\n        } else if (work.org) {\n          html += work.org\n        }\n        if (work.role) {\n          if (html.length > 0) {\n            html = work.role + ' @ ' + html\n          } else {\n            html = work.role\n          }\n        }\n        return html\n      },\n      textDistance: function () {\n        var distanceInKm = this.profile.distanceInKm || 0\n        if (this.$root.useMiles) {\n          return roundDistance(kmToMi(distanceInKm)) + ' miles'\n        } else {\n          return roundDistance(distanceInKm) + ' km'\n        }\n      },\n      languageListHtml: function () {\n        var vm = this\n        var nav = window.navigator\n        if (!vm.profile.languages) return ''\n        var preferredLanguageCode = nav.languages\n          // The preferred language set in the browser\n          ? nav.languages[0]\n          : (\n              // The system language in IE\n              nav.userLanguage ||\n              // The language in the current page\n              nav.language\n            )\n        return (\n          '<ul><li>' +\n          vm.profile.languages.map(function (languageCode, index) {\n            var language = languageNameFor[languageCode]\n            if (\n              languageCode !== 'en' &&\n              preferredLanguageCode &&\n              languageCode === preferredLanguageCode.slice(0, 2)\n            ) {\n              return (\n                '<span ' +\n                  'class=\"user-match\" ' +\n                  'title=\"' +\n                    vm.profile.name +\n                    ' can give technical talks in your preferred language.' +\n                  '\"' +\n                '\\>' + language + '</span>'\n              )\n            }\n            return language\n          }).join('</li><li>') +\n          '</li></ul>'\n        )\n      },\n      hasSocialLinks: function () {\n        return this.profile.github || this.profile.twitter || this.profile.codepen || this.profile.linkedin\n      }\n    },\n    methods: {\n      minimizeLink: function (link) {\n        return link\n          .replace(/^https?:\\/\\/(www\\.)?/, '')\n          .replace(/\\/$/, '')\n          .replace(/^mailto:/, '')\n      },\n      /**\n       * Generate a GitHub URL using a repo and a handle.\n       */\n      githubUrl: function (handle, repo) {\n        if (repo && repo.url) {\n          return repo.url\n        }\n        if (repo && repo.indexOf('/') !== -1) {\n          // If the repo name has a slash, it must be an organization repo.\n          // In such a case, we discard the (personal) handle.\n          return (\n            'https://github.com/' +\n            repo.replace(/\\/\\*$/, '')\n          )\n        }\n        return 'https://github.com/' + handle + '/' + (repo || '')\n      }\n    }\n  })\n\n  new Vue({\n    el: '#team-members',\n    data: {\n      team: team,\n      teamEmeriti: emeriti,\n      partners: shuffle(partners),\n      geolocationSupported: false,\n      isSorting: false,\n      errorGettingLocation: false,\n      userPosition: null,\n      useMiles: false,\n      konami: {\n        position: 0,\n        code: [38, 38, 40, 40, 37, 39, 37, 39, 66, 65]\n      }\n    },\n    computed: {\n      sortedTeam: function () {\n        return this.sortVuersByDistance(this.team)\n      },\n      sortedPartners: function () {\n        return this.sortVuersByDistance(this.partners)\n      },\n      titleVisible: function () {\n        return this.konami.code.length === this.konami.position\n      }\n    },\n    created: function () {\n      var nav = window.navigator\n      if ('geolocation' in nav) {\n        this.geolocationSupported = true\n        var imperialLanguageCodes = [\n          'en-US', 'en-MY', 'en-MM', 'en-BU', 'en-LR', 'my', 'bu'\n        ]\n        if (imperialLanguageCodes.indexOf(nav.language) !== -1) {\n          this.useMiles = true\n        }\n      }\n      document.addEventListener('keydown', this.konamiKeydown)\n    },\n    beforeDestroy: function () {\n      document.removeEventListener('keydown', this.konamiKeydown)\n    },\n    methods: {\n      getUserPosition: function () {\n        var vm = this\n        var nav = window.navigator\n        vm.isSorting = true\n        nav.geolocation.getCurrentPosition(\n          function (position) {\n            vm.userPosition = position\n            vm.isSorting = false\n          },\n          function (error) {\n            vm.isSorting = false\n            vm.errorGettingLocation = true\n          },\n          {\n            enableHighAccuracy: true\n          }\n        )\n      },\n      sortVuersByDistance: function (vuers) {\n        var vm = this\n        if (!vm.userPosition) return vuers\n        var vuersWithDistances = vuers.map(function (vuer) {\n          var cityCoords = cityCoordsFor[vuer.city]\n          if (cityCoords) {\n            return Object.assign({}, vuer, {\n              distanceInKm: getDistanceFromLatLonInKm(\n                vm.userPosition.coords.latitude,\n                vm.userPosition.coords.longitude,\n                cityCoords[0],\n                cityCoords[1]\n              )\n            })\n          }\n          return Object.assign({}, vuer, {\n            distanceInKm: null\n          })\n        })\n        vuersWithDistances.sort(function (a, b) {\n          if (a.distanceInKm && b.distanceInKm) return a.distanceInKm - b.distanceInKm\n          if (a.distanceInKm && !b.distanceInKm) return -1\n          if (!a.distanceInKm && b.distanceInKm) return 1\n          if (a.name < b.name) return -1\n          if (a.name > b.name) return 1\n        })\n        return vuersWithDistances\n      },\n      konamiKeydown: function (event) {\n        if (this.titleVisible) {\n          return\n        }\n\n        if (event.keyCode !== this.konami.code[this.konami.position++]) {\n          this.konami.position = 0\n        }\n      }\n    }\n  })\n\n  /**\n  * Shuffles array in place.\n  * @param {Array} a items The array containing the items.\n  */\n  function shuffle (a) {\n    a = a.concat([])\n    if (window.location.hostname === 'localhost') {\n      return a\n    }\n    var j, x, i\n    for (i = a.length; i; i--) {\n      j = Math.floor(Math.random() * i)\n      x = a[i - 1]\n      a[i - 1] = a[j]\n      a[j] = x\n    }\n    return a\n  }\n\n  /**\n  * Calculates great-circle distances between the two points – that is, the shortest distance over the earth’s surface – using the Haversine formula.\n  * @param {Number} lat1 The latitude of the 1st location.\n  * @param {Number} lon1 The longitute of the 1st location.\n  * @param {Number} lat2 The latitude of the 2nd location.\n  * @param {Number} lon2 The longitute of the 2nd location.\n  */\n  function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2) {\n    var R = 6371 // Radius of the earth in km\n    var dLat = deg2rad(lat2-lat1)  // deg2rad below\n    var dLon = deg2rad(lon2-lon1)\n    var a =\n      Math.sin(dLat/2) * Math.sin(dLat/2) +\n      Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *\n      Math.sin(dLon/2) * Math.sin(dLon/2)\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))\n    var d = R * c // Distance in km\n    return d\n  }\n\n  function deg2rad(deg) {\n    return deg * (Math.PI/180)\n  }\n\n  function kmToMi (km) {\n    return km * 0.62137\n  }\n\n  function roundDistance (num) {\n    return Number(Math.ceil(num).toPrecision(2))\n  }\n})()\n</script>\n{% endraw %}\n","source":"doc/guide/team.md","raw":"---\ntitle: 认识团队\ntype: guide\norder: 800\n---\n\n{% raw %}\n<script id=\"vuer-profile-template\" type=\"text/template\">\n  <div class=\"vuer\">\n    <div class=\"avatar\">\n      <img v-if=\"profile.imageUrl\"\n        :src=\"profile.imageUrl\"\n        :alt=\"profile.name\" width=80 height=80>\n      <img v-else-if=\"profile.github\"\n        :src=\"'https://github.com/' + profile.github + '.png'\"\n        :alt=\"profile.name\" width=80 height=80>\n      <img v-else-if=\"profile.twitter\"\n        :src=\"'https://avatars.io/twitter/' + profile.twitter\"\n        :alt=\"profile.name\" width=80 height=80>\n    </div>\n    <div class=\"profile\">\n      <h3 :data-official-title=\"profile.title\">\n        {{ profile.name }}\n        <sup v-if=\"profile.title && titleVisible\" v-html=\"profile.title\"></sup>\n      </h3>\n      <dl>\n        <template v-if=\"profile.reposOfficial\">\n          <dt>Core focus</dt>\n          <dd>\n            <ul>\n              <li v-for=\"repo in profile.reposOfficial\">\n                <a :href=\"githubUrl('vuejs', repo)\" target=_blank rel=\"noopener noreferrer\">{{ repo.name || repo }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <template v-if=\"profile.github && profile.reposPersonal\">\n          <dt>Ecosystem</dt>\n          <dd>\n            <ul>\n              <li v-for=\"repo in profile.reposPersonal\">\n                <a :href=\"githubUrl(profile.github, repo)\" target=_blank rel=\"noopener noreferrer\">{{ repo.name || repo }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <template v-if=\"profile.work\">\n          <dt>\n            <i class=\"fa fa-briefcase\"></i>\n            <span class=\"sr-only\">Work</span>\n          </dt>\n          <dd v-html=\"workHtml\"></dd>\n        </template>\n        <span v-if=\"profile.distanceInKm\" class=\"distance\">\n          <dt>\n            <i class=\"fa fa-map-marker\"></i>\n            <span class=\"sr-only\">Distance</span>\n          </dt>\n          <dd>\n            About\n            <span\n              v-if=\"profile.distanceInKm <= 150\"\n              :title=\"profile.name + ' is close enough to commute to your location.'\"\n              class=\"user-match\"\n            >{{ textDistance }} away</span>\n            <template v-else>{{ textDistance }} away</template>\n            in {{ profile.city }}\n          </dd>\n        </span>\n        <template v-else-if=\"profile.city\">\n          <dt>\n            <i class=\"fa fa-map-marker\"></i>\n            <span class=\"sr-only\">City</span>\n          </dt>\n          <dd>\n            {{ profile.city }}\n          </dd>\n        </template>\n        <template v-if=\"profile.links\">\n          <dt>\n            <i class=\"fa fa-link\"></i>\n            <span class=\"sr-only\">Links</span>\n          </dt>\n          <dd>\n            <ul>\n              <li v-for=\"link in profile.links\">\n                <a :href=\"link\" target=_blank>{{ minimizeLink(link) }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <footer v-if=\"hasSocialLinks\" class=\"social\">\n          <a class=github v-if=\"profile.github\" :href=\"githubUrl(profile.github)\">\n            <i class=\"fa fa-github\"></i>\n            <span class=\"sr-only\">Github</span>\n          </a>\n          <a class=twitter v-if=\"profile.twitter\" :href=\"'https://twitter.com/' + profile.twitter\">\n            <i class=\"fa fa-twitter\"></i>\n            <span class=\"sr-only\">Twitter</span>\n          </a>\n          <a class=codepen v-if=\"profile.codepen\" :href=\"'https://codepen.io/' + profile.codepen\">\n            <i class=\"fa fa-codepen\"></i>\n            <span class=\"sr-only\">CodePen</span>\n          </a>\n          <a class=linkedin v-if=\"profile.linkedin\" :href=\"'https://www.linkedin.com/in/' + profile.linkedin\">\n            <i class=\"fa fa-linkedin\"></i>\n            <span class=\"sr-only\">LinkedIn</span>\n          </a>\n        </footer>\n      </dl>\n    </div>\n  </div>\n</script>\n\n<div id=\"team-members\">\n  <div class=\"team\">\n\n    <h2 id=\"active-core-team-members\">\n      核心团队活跃成员\n      <button\n        v-if=\"geolocationSupported && !userPosition\"\n        @click=\"getUserPosition\"\n        :disabled=\"isSorting\"\n        class=\"sort-by-distance-button\"\n      >\n        <i\n          v-if=\"isSorting\"\n          class=\"fa fa-refresh rotating-clockwise\"\n        ></i>\n        <template v-else>\n          <i class=\"fa fa-map-marker\"></i>\n          <span>谁在我附近</span>\n        </template>\n      </button>\n    </h2>\n\n    <p v-if=\"errorGettingLocation\" class=\"tip\">\n      未成功获取您的位置。\n    </p>\n\n    <p>\n      mypUI 的开发及其生态建设来自不同的省份与技术领域，这里会展示其中部分团队成员的信息。\n    </p>\n\n    <p v-if=\"userPosition\" class=\"success\">\n      核心团队成员已经按照跟你的距离排序。\n    </p>\n\n    <vuer-profile\n      v-for=\"profile in sortedTeam\"\n      :key=\"profile.name\"\n      :profile=\"profile\"\n      :title-visible=\"titleVisible\"\n    ></vuer-profile>\n  </div>\n\n  <div class=\"team\">\n    <h2 id=\"core-team-emeriti\">\n      核心团队荣誉成员\n    </h2>\n\n    <p>\n      我们在此致敬过去曾做出过突出贡献的不再活跃的团队成员。\n    </p>\n\n    <vuer-profile\n      v-for=\"profile in teamEmeriti\"\n      :key=\"profile.name\"\n      :profile=\"profile\"\n      :title-visible=\"titleVisible\"\n    ></vuer-profile>\n  </div>\n\n  <div class=\"team\">\n    <h2 id=\"community-partners\">\n      社区伙伴\n      <button\n        v-if=\"geolocationSupported && !userPosition\"\n        @click=\"getUserPosition\"\n        :disabled=\"isSorting\"\n        class=\"sort-by-distance-button\"\n      >\n        <i\n          v-if=\"isSorting\"\n          class=\"fa fa-refresh rotating-clockwise\"\n        ></i>\n        <template v-else>\n          <i class=\"fa fa-map-marker\"></i>\n          <span>谁在我附近</span>\n        </template>\n      </button>\n    </h2>\n\n    <p v-if=\"errorGettingLocation\" class=\"tip\">\n      未成功获取您的位置。\n    </p>\n\n    <p>\n      一些 mypUI 的社区成员让这里变得更加丰富多彩，有必要在此特别提及。我们与这些主要合作伙伴建立了更加亲密的关系，经常与他们就即将到来的功能和新闻展开协作。\n    </p>\n\n    <p v-if=\"userPosition\" class=\"success\">\n      社区伙伴们已经按照跟你的距离排序。\n    </p>\n\n    <vuer-profile\n      v-for=\"profile in sortedPartners\"\n      :key=\"profile.name\"\n      :profile=\"profile\"\n      :title-visible=\"titleVisible\"\n    ></vuer-profile>\n  </div>\n</div>\n\n<script>\n(function () {\n  var cityCoordsFor = {\n    '北京': [39.904200, 116.407396]\n  }\n\n  var team = [{\n    name: '马玉平',\n    title: '身体好才是真的好',\n    city: '北京',\n    github: 'wakaryry',\n    work: {\n      role: 'Creator',\n      org: 'mypUI'\n    },\n    links: [\n      'https://github.com/wakaryry'\n    ]\n  }]\n\n  team = team.concat(shuffle([\n  ]))\n\n  var emeriti = shuffle([\n  ])\n\n  var partners = [\n  ]\n\n  Vue.component('vuer-profile', {\n    template: '#vuer-profile-template',\n    props: {\n      profile: Object,\n      titleVisible: Boolean\n    },\n    computed: {\n      workHtml: function () {\n        var work = this.profile.work\n        var html = ''\n        if (work.orgUrl) {\n          html += '<a href=\"' + work.orgUrl + '\" target=\"_blank\" rel=\"noopener noreferrer\">'\n          if (work.org) {\n            html += work.org\n          } else {\n            this.minimizeLink(work.orgUrl)\n          }\n          html += '</a>'\n        } else if (work.org) {\n          html += work.org\n        }\n        if (work.role) {\n          if (html.length > 0) {\n            html = work.role + ' @ ' + html\n          } else {\n            html = work.role\n          }\n        }\n        return html\n      },\n      textDistance: function () {\n        var distanceInKm = this.profile.distanceInKm || 0\n        if (this.$root.useMiles) {\n          return roundDistance(kmToMi(distanceInKm)) + ' miles'\n        } else {\n          return roundDistance(distanceInKm) + ' km'\n        }\n      },\n      languageListHtml: function () {\n        var vm = this\n        var nav = window.navigator\n        if (!vm.profile.languages) return ''\n        var preferredLanguageCode = nav.languages\n          // The preferred language set in the browser\n          ? nav.languages[0]\n          : (\n              // The system language in IE\n              nav.userLanguage ||\n              // The language in the current page\n              nav.language\n            )\n        return (\n          '<ul><li>' +\n          vm.profile.languages.map(function (languageCode, index) {\n            var language = languageNameFor[languageCode]\n            if (\n              languageCode !== 'en' &&\n              preferredLanguageCode &&\n              languageCode === preferredLanguageCode.slice(0, 2)\n            ) {\n              return (\n                '<span ' +\n                  'class=\"user-match\" ' +\n                  'title=\"' +\n                    vm.profile.name +\n                    ' can give technical talks in your preferred language.' +\n                  '\"' +\n                '\\>' + language + '</span>'\n              )\n            }\n            return language\n          }).join('</li><li>') +\n          '</li></ul>'\n        )\n      },\n      hasSocialLinks: function () {\n        return this.profile.github || this.profile.twitter || this.profile.codepen || this.profile.linkedin\n      }\n    },\n    methods: {\n      minimizeLink: function (link) {\n        return link\n          .replace(/^https?:\\/\\/(www\\.)?/, '')\n          .replace(/\\/$/, '')\n          .replace(/^mailto:/, '')\n      },\n      /**\n       * Generate a GitHub URL using a repo and a handle.\n       */\n      githubUrl: function (handle, repo) {\n        if (repo && repo.url) {\n          return repo.url\n        }\n        if (repo && repo.indexOf('/') !== -1) {\n          // If the repo name has a slash, it must be an organization repo.\n          // In such a case, we discard the (personal) handle.\n          return (\n            'https://github.com/' +\n            repo.replace(/\\/\\*$/, '')\n          )\n        }\n        return 'https://github.com/' + handle + '/' + (repo || '')\n      }\n    }\n  })\n\n  new Vue({\n    el: '#team-members',\n    data: {\n      team: team,\n      teamEmeriti: emeriti,\n      partners: shuffle(partners),\n      geolocationSupported: false,\n      isSorting: false,\n      errorGettingLocation: false,\n      userPosition: null,\n      useMiles: false,\n      konami: {\n        position: 0,\n        code: [38, 38, 40, 40, 37, 39, 37, 39, 66, 65]\n      }\n    },\n    computed: {\n      sortedTeam: function () {\n        return this.sortVuersByDistance(this.team)\n      },\n      sortedPartners: function () {\n        return this.sortVuersByDistance(this.partners)\n      },\n      titleVisible: function () {\n        return this.konami.code.length === this.konami.position\n      }\n    },\n    created: function () {\n      var nav = window.navigator\n      if ('geolocation' in nav) {\n        this.geolocationSupported = true\n        var imperialLanguageCodes = [\n          'en-US', 'en-MY', 'en-MM', 'en-BU', 'en-LR', 'my', 'bu'\n        ]\n        if (imperialLanguageCodes.indexOf(nav.language) !== -1) {\n          this.useMiles = true\n        }\n      }\n      document.addEventListener('keydown', this.konamiKeydown)\n    },\n    beforeDestroy: function () {\n      document.removeEventListener('keydown', this.konamiKeydown)\n    },\n    methods: {\n      getUserPosition: function () {\n        var vm = this\n        var nav = window.navigator\n        vm.isSorting = true\n        nav.geolocation.getCurrentPosition(\n          function (position) {\n            vm.userPosition = position\n            vm.isSorting = false\n          },\n          function (error) {\n            vm.isSorting = false\n            vm.errorGettingLocation = true\n          },\n          {\n            enableHighAccuracy: true\n          }\n        )\n      },\n      sortVuersByDistance: function (vuers) {\n        var vm = this\n        if (!vm.userPosition) return vuers\n        var vuersWithDistances = vuers.map(function (vuer) {\n          var cityCoords = cityCoordsFor[vuer.city]\n          if (cityCoords) {\n            return Object.assign({}, vuer, {\n              distanceInKm: getDistanceFromLatLonInKm(\n                vm.userPosition.coords.latitude,\n                vm.userPosition.coords.longitude,\n                cityCoords[0],\n                cityCoords[1]\n              )\n            })\n          }\n          return Object.assign({}, vuer, {\n            distanceInKm: null\n          })\n        })\n        vuersWithDistances.sort(function (a, b) {\n          if (a.distanceInKm && b.distanceInKm) return a.distanceInKm - b.distanceInKm\n          if (a.distanceInKm && !b.distanceInKm) return -1\n          if (!a.distanceInKm && b.distanceInKm) return 1\n          if (a.name < b.name) return -1\n          if (a.name > b.name) return 1\n        })\n        return vuersWithDistances\n      },\n      konamiKeydown: function (event) {\n        if (this.titleVisible) {\n          return\n        }\n\n        if (event.keyCode !== this.konami.code[this.konami.position++]) {\n          this.konami.position = 0\n        }\n      }\n    }\n  })\n\n  /**\n  * Shuffles array in place.\n  * @param {Array} a items The array containing the items.\n  */\n  function shuffle (a) {\n    a = a.concat([])\n    if (window.location.hostname === 'localhost') {\n      return a\n    }\n    var j, x, i\n    for (i = a.length; i; i--) {\n      j = Math.floor(Math.random() * i)\n      x = a[i - 1]\n      a[i - 1] = a[j]\n      a[j] = x\n    }\n    return a\n  }\n\n  /**\n  * Calculates great-circle distances between the two points – that is, the shortest distance over the earth’s surface – using the Haversine formula.\n  * @param {Number} lat1 The latitude of the 1st location.\n  * @param {Number} lon1 The longitute of the 1st location.\n  * @param {Number} lat2 The latitude of the 2nd location.\n  * @param {Number} lon2 The longitute of the 2nd location.\n  */\n  function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2) {\n    var R = 6371 // Radius of the earth in km\n    var dLat = deg2rad(lat2-lat1)  // deg2rad below\n    var dLon = deg2rad(lon2-lon1)\n    var a =\n      Math.sin(dLat/2) * Math.sin(dLat/2) +\n      Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *\n      Math.sin(dLon/2) * Math.sin(dLon/2)\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))\n    var d = R * c // Distance in km\n    return d\n  }\n\n  function deg2rad(deg) {\n    return deg * (Math.PI/180)\n  }\n\n  function kmToMi (km) {\n    return km * 0.62137\n  }\n\n  function roundDistance (num) {\n    return Number(Math.ceil(num).toPrecision(2))\n  }\n})()\n</script>\n{% endraw %}\n","date":"2020-07-17T06:00:32.394Z","updated":"2020-07-17T06:00:32.394Z","path":"doc/guide/team.html","comments":1,"layout":"page","_id":"ckcwngnk6001y9lxkov7zkksy","content":"\n<script id=\"vuer-profile-template\" type=\"text/template\">\n  <div class=\"vuer\">\n    <div class=\"avatar\">\n      <img v-if=\"profile.imageUrl\"\n        :src=\"profile.imageUrl\"\n        :alt=\"profile.name\" width=80 height=80>\n      <img v-else-if=\"profile.github\"\n        :src=\"'https://github.com/' + profile.github + '.png'\"\n        :alt=\"profile.name\" width=80 height=80>\n      <img v-else-if=\"profile.twitter\"\n        :src=\"'https://avatars.io/twitter/' + profile.twitter\"\n        :alt=\"profile.name\" width=80 height=80>\n    </div>\n    <div class=\"profile\">\n      <h3 :data-official-title=\"profile.title\">\n        {{ profile.name }}\n        <sup v-if=\"profile.title && titleVisible\" v-html=\"profile.title\"></sup>\n      </h3>\n      <dl>\n        <template v-if=\"profile.reposOfficial\">\n          <dt>Core focus</dt>\n          <dd>\n            <ul>\n              <li v-for=\"repo in profile.reposOfficial\">\n                <a :href=\"githubUrl('vuejs', repo)\" target=_blank rel=\"noopener noreferrer\">{{ repo.name || repo }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <template v-if=\"profile.github && profile.reposPersonal\">\n          <dt>Ecosystem</dt>\n          <dd>\n            <ul>\n              <li v-for=\"repo in profile.reposPersonal\">\n                <a :href=\"githubUrl(profile.github, repo)\" target=_blank rel=\"noopener noreferrer\">{{ repo.name || repo }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <template v-if=\"profile.work\">\n          <dt>\n            <i class=\"fa fa-briefcase\"></i>\n            <span class=\"sr-only\">Work</span>\n          </dt>\n          <dd v-html=\"workHtml\"></dd>\n        </template>\n        <span v-if=\"profile.distanceInKm\" class=\"distance\">\n          <dt>\n            <i class=\"fa fa-map-marker\"></i>\n            <span class=\"sr-only\">Distance</span>\n          </dt>\n          <dd>\n            About\n            <span\n              v-if=\"profile.distanceInKm <= 150\"\n              :title=\"profile.name + ' is close enough to commute to your location.'\"\n              class=\"user-match\"\n            >{{ textDistance }} away</span>\n            <template v-else>{{ textDistance }} away</template>\n            in {{ profile.city }}\n          </dd>\n        </span>\n        <template v-else-if=\"profile.city\">\n          <dt>\n            <i class=\"fa fa-map-marker\"></i>\n            <span class=\"sr-only\">City</span>\n          </dt>\n          <dd>\n            {{ profile.city }}\n          </dd>\n        </template>\n        <template v-if=\"profile.links\">\n          <dt>\n            <i class=\"fa fa-link\"></i>\n            <span class=\"sr-only\">Links</span>\n          </dt>\n          <dd>\n            <ul>\n              <li v-for=\"link in profile.links\">\n                <a :href=\"link\" target=_blank>{{ minimizeLink(link) }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <footer v-if=\"hasSocialLinks\" class=\"social\">\n          <a class=github v-if=\"profile.github\" :href=\"githubUrl(profile.github)\">\n            <i class=\"fa fa-github\"></i>\n            <span class=\"sr-only\">Github</span>\n          </a>\n          <a class=twitter v-if=\"profile.twitter\" :href=\"'https://twitter.com/' + profile.twitter\">\n            <i class=\"fa fa-twitter\"></i>\n            <span class=\"sr-only\">Twitter</span>\n          </a>\n          <a class=codepen v-if=\"profile.codepen\" :href=\"'https://codepen.io/' + profile.codepen\">\n            <i class=\"fa fa-codepen\"></i>\n            <span class=\"sr-only\">CodePen</span>\n          </a>\n          <a class=linkedin v-if=\"profile.linkedin\" :href=\"'https://www.linkedin.com/in/' + profile.linkedin\">\n            <i class=\"fa fa-linkedin\"></i>\n            <span class=\"sr-only\">LinkedIn</span>\n          </a>\n        </footer>\n      </dl>\n    </div>\n  </div>\n</script>\n\n<div id=\"team-members\">\n  <div class=\"team\">\n\n    <h2 id=\"active-core-team-members\">\n      核心团队活跃成员\n      <button v-if=\"geolocationSupported && !userPosition\" @click=\"getUserPosition\" :disabled=\"isSorting\" class=\"sort-by-distance-button\">\n        <i v-if=\"isSorting\" class=\"fa fa-refresh rotating-clockwise\"></i>\n        <template v-else>\n          <i class=\"fa fa-map-marker\"></i>\n          <span>谁在我附近</span>\n        </template>\n      </button>\n    </h2>\n\n    <p v-if=\"errorGettingLocation\" class=\"tip\">\n      未成功获取您的位置。\n    </p>\n\n    <p>\n      mypUI 的开发及其生态建设来自不同的省份与技术领域，这里会展示其中部分团队成员的信息。\n    </p>\n\n    <p v-if=\"userPosition\" class=\"success\">\n      核心团队成员已经按照跟你的距离排序。\n    </p>\n\n    <vuer-profile v-for=\"profile in sortedTeam\" :key=\"profile.name\" :profile=\"profile\" :title-visible=\"titleVisible\"></vuer-profile>\n  </div>\n\n  <div class=\"team\">\n    <h2 id=\"core-team-emeriti\">\n      核心团队荣誉成员\n    </h2>\n\n    <p>\n      我们在此致敬过去曾做出过突出贡献的不再活跃的团队成员。\n    </p>\n\n    <vuer-profile v-for=\"profile in teamEmeriti\" :key=\"profile.name\" :profile=\"profile\" :title-visible=\"titleVisible\"></vuer-profile>\n  </div>\n\n  <div class=\"team\">\n    <h2 id=\"community-partners\">\n      社区伙伴\n      <button v-if=\"geolocationSupported && !userPosition\" @click=\"getUserPosition\" :disabled=\"isSorting\" class=\"sort-by-distance-button\">\n        <i v-if=\"isSorting\" class=\"fa fa-refresh rotating-clockwise\"></i>\n        <template v-else>\n          <i class=\"fa fa-map-marker\"></i>\n          <span>谁在我附近</span>\n        </template>\n      </button>\n    </h2>\n\n    <p v-if=\"errorGettingLocation\" class=\"tip\">\n      未成功获取您的位置。\n    </p>\n\n    <p>\n      一些 mypUI 的社区成员让这里变得更加丰富多彩，有必要在此特别提及。我们与这些主要合作伙伴建立了更加亲密的关系，经常与他们就即将到来的功能和新闻展开协作。\n    </p>\n\n    <p v-if=\"userPosition\" class=\"success\">\n      社区伙伴们已经按照跟你的距离排序。\n    </p>\n\n    <vuer-profile v-for=\"profile in sortedPartners\" :key=\"profile.name\" :profile=\"profile\" :title-visible=\"titleVisible\"></vuer-profile>\n  </div>\n</div>\n\n<script>\n(function () {\n  var cityCoordsFor = {\n    '北京': [39.904200, 116.407396]\n  }\n\n  var team = [{\n    name: '马玉平',\n    title: '身体好才是真的好',\n    city: '北京',\n    github: 'wakaryry',\n    work: {\n      role: 'Creator',\n      org: 'mypUI'\n    },\n    links: [\n      'https://github.com/wakaryry'\n    ]\n  }]\n\n  team = team.concat(shuffle([\n  ]))\n\n  var emeriti = shuffle([\n  ])\n\n  var partners = [\n  ]\n\n  Vue.component('vuer-profile', {\n    template: '#vuer-profile-template',\n    props: {\n      profile: Object,\n      titleVisible: Boolean\n    },\n    computed: {\n      workHtml: function () {\n        var work = this.profile.work\n        var html = ''\n        if (work.orgUrl) {\n          html += '<a href=\"' + work.orgUrl + '\" target=\"_blank\" rel=\"noopener noreferrer\">'\n          if (work.org) {\n            html += work.org\n          } else {\n            this.minimizeLink(work.orgUrl)\n          }\n          html += '</a>'\n        } else if (work.org) {\n          html += work.org\n        }\n        if (work.role) {\n          if (html.length > 0) {\n            html = work.role + ' @ ' + html\n          } else {\n            html = work.role\n          }\n        }\n        return html\n      },\n      textDistance: function () {\n        var distanceInKm = this.profile.distanceInKm || 0\n        if (this.$root.useMiles) {\n          return roundDistance(kmToMi(distanceInKm)) + ' miles'\n        } else {\n          return roundDistance(distanceInKm) + ' km'\n        }\n      },\n      languageListHtml: function () {\n        var vm = this\n        var nav = window.navigator\n        if (!vm.profile.languages) return ''\n        var preferredLanguageCode = nav.languages\n          // The preferred language set in the browser\n          ? nav.languages[0]\n          : (\n              // The system language in IE\n              nav.userLanguage ||\n              // The language in the current page\n              nav.language\n            )\n        return (\n          '<ul><li>' +\n          vm.profile.languages.map(function (languageCode, index) {\n            var language = languageNameFor[languageCode]\n            if (\n              languageCode !== 'en' &&\n              preferredLanguageCode &&\n              languageCode === preferredLanguageCode.slice(0, 2)\n            ) {\n              return (\n                '<span ' +\n                  'class=\"user-match\" ' +\n                  'title=\"' +\n                    vm.profile.name +\n                    ' can give technical talks in your preferred language.' +\n                  '\"' +\n                '\\>' + language + '</span>'\n              )\n            }\n            return language\n          }).join('</li><li>') +\n          '</li></ul>'\n        )\n      },\n      hasSocialLinks: function () {\n        return this.profile.github || this.profile.twitter || this.profile.codepen || this.profile.linkedin\n      }\n    },\n    methods: {\n      minimizeLink: function (link) {\n        return link\n          .replace(/^https?:\\/\\/(www\\.)?/, '')\n          .replace(/\\/$/, '')\n          .replace(/^mailto:/, '')\n      },\n      /**\n       * Generate a GitHub URL using a repo and a handle.\n       */\n      githubUrl: function (handle, repo) {\n        if (repo && repo.url) {\n          return repo.url\n        }\n        if (repo && repo.indexOf('/') !== -1) {\n          // If the repo name has a slash, it must be an organization repo.\n          // In such a case, we discard the (personal) handle.\n          return (\n            'https://github.com/' +\n            repo.replace(/\\/\\*$/, '')\n          )\n        }\n        return 'https://github.com/' + handle + '/' + (repo || '')\n      }\n    }\n  })\n\n  new Vue({\n    el: '#team-members',\n    data: {\n      team: team,\n      teamEmeriti: emeriti,\n      partners: shuffle(partners),\n      geolocationSupported: false,\n      isSorting: false,\n      errorGettingLocation: false,\n      userPosition: null,\n      useMiles: false,\n      konami: {\n        position: 0,\n        code: [38, 38, 40, 40, 37, 39, 37, 39, 66, 65]\n      }\n    },\n    computed: {\n      sortedTeam: function () {\n        return this.sortVuersByDistance(this.team)\n      },\n      sortedPartners: function () {\n        return this.sortVuersByDistance(this.partners)\n      },\n      titleVisible: function () {\n        return this.konami.code.length === this.konami.position\n      }\n    },\n    created: function () {\n      var nav = window.navigator\n      if ('geolocation' in nav) {\n        this.geolocationSupported = true\n        var imperialLanguageCodes = [\n          'en-US', 'en-MY', 'en-MM', 'en-BU', 'en-LR', 'my', 'bu'\n        ]\n        if (imperialLanguageCodes.indexOf(nav.language) !== -1) {\n          this.useMiles = true\n        }\n      }\n      document.addEventListener('keydown', this.konamiKeydown)\n    },\n    beforeDestroy: function () {\n      document.removeEventListener('keydown', this.konamiKeydown)\n    },\n    methods: {\n      getUserPosition: function () {\n        var vm = this\n        var nav = window.navigator\n        vm.isSorting = true\n        nav.geolocation.getCurrentPosition(\n          function (position) {\n            vm.userPosition = position\n            vm.isSorting = false\n          },\n          function (error) {\n            vm.isSorting = false\n            vm.errorGettingLocation = true\n          },\n          {\n            enableHighAccuracy: true\n          }\n        )\n      },\n      sortVuersByDistance: function (vuers) {\n        var vm = this\n        if (!vm.userPosition) return vuers\n        var vuersWithDistances = vuers.map(function (vuer) {\n          var cityCoords = cityCoordsFor[vuer.city]\n          if (cityCoords) {\n            return Object.assign({}, vuer, {\n              distanceInKm: getDistanceFromLatLonInKm(\n                vm.userPosition.coords.latitude,\n                vm.userPosition.coords.longitude,\n                cityCoords[0],\n                cityCoords[1]\n              )\n            })\n          }\n          return Object.assign({}, vuer, {\n            distanceInKm: null\n          })\n        })\n        vuersWithDistances.sort(function (a, b) {\n          if (a.distanceInKm && b.distanceInKm) return a.distanceInKm - b.distanceInKm\n          if (a.distanceInKm && !b.distanceInKm) return -1\n          if (!a.distanceInKm && b.distanceInKm) return 1\n          if (a.name < b.name) return -1\n          if (a.name > b.name) return 1\n        })\n        return vuersWithDistances\n      },\n      konamiKeydown: function (event) {\n        if (this.titleVisible) {\n          return\n        }\n\n        if (event.keyCode !== this.konami.code[this.konami.position++]) {\n          this.konami.position = 0\n        }\n      }\n    }\n  })\n\n  /**\n  * Shuffles array in place.\n  * @param {Array} a items The array containing the items.\n  */\n  function shuffle (a) {\n    a = a.concat([])\n    if (window.location.hostname === 'localhost') {\n      return a\n    }\n    var j, x, i\n    for (i = a.length; i; i--) {\n      j = Math.floor(Math.random() * i)\n      x = a[i - 1]\n      a[i - 1] = a[j]\n      a[j] = x\n    }\n    return a\n  }\n\n  /**\n  * Calculates great-circle distances between the two points – that is, the shortest distance over the earth’s surface – using the Haversine formula.\n  * @param {Number} lat1 The latitude of the 1st location.\n  * @param {Number} lon1 The longitute of the 1st location.\n  * @param {Number} lat2 The latitude of the 2nd location.\n  * @param {Number} lon2 The longitute of the 2nd location.\n  */\n  function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2) {\n    var R = 6371 // Radius of the earth in km\n    var dLat = deg2rad(lat2-lat1)  // deg2rad below\n    var dLon = deg2rad(lon2-lon1)\n    var a =\n      Math.sin(dLat/2) * Math.sin(dLat/2) +\n      Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *\n      Math.sin(dLon/2) * Math.sin(dLon/2)\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))\n    var d = R * c // Distance in km\n    return d\n  }\n\n  function deg2rad(deg) {\n    return deg * (Math.PI/180)\n  }\n\n  function kmToMi (km) {\n    return km * 0.62137\n  }\n\n  function roundDistance (num) {\n    return Number(Math.ceil(num).toPrecision(2))\n  }\n})()\n</script>\n\n","site":{"data":{}},"excerpt":"","more":"\n<script id=\"vuer-profile-template\" type=\"text/template\">\n  <div class=\"vuer\">\n    <div class=\"avatar\">\n      <img v-if=\"profile.imageUrl\"\n        :src=\"profile.imageUrl\"\n        :alt=\"profile.name\" width=80 height=80>\n      <img v-else-if=\"profile.github\"\n        :src=\"'https://github.com/' + profile.github + '.png'\"\n        :alt=\"profile.name\" width=80 height=80>\n      <img v-else-if=\"profile.twitter\"\n        :src=\"'https://avatars.io/twitter/' + profile.twitter\"\n        :alt=\"profile.name\" width=80 height=80>\n    </div>\n    <div class=\"profile\">\n      <h3 :data-official-title=\"profile.title\">\n        {{ profile.name }}\n        <sup v-if=\"profile.title && titleVisible\" v-html=\"profile.title\"></sup>\n      </h3>\n      <dl>\n        <template v-if=\"profile.reposOfficial\">\n          <dt>Core focus</dt>\n          <dd>\n            <ul>\n              <li v-for=\"repo in profile.reposOfficial\">\n                <a :href=\"githubUrl('vuejs', repo)\" target=_blank rel=\"noopener noreferrer\">{{ repo.name || repo }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <template v-if=\"profile.github && profile.reposPersonal\">\n          <dt>Ecosystem</dt>\n          <dd>\n            <ul>\n              <li v-for=\"repo in profile.reposPersonal\">\n                <a :href=\"githubUrl(profile.github, repo)\" target=_blank rel=\"noopener noreferrer\">{{ repo.name || repo }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <template v-if=\"profile.work\">\n          <dt>\n            <i class=\"fa fa-briefcase\"></i>\n            <span class=\"sr-only\">Work</span>\n          </dt>\n          <dd v-html=\"workHtml\"></dd>\n        </template>\n        <span v-if=\"profile.distanceInKm\" class=\"distance\">\n          <dt>\n            <i class=\"fa fa-map-marker\"></i>\n            <span class=\"sr-only\">Distance</span>\n          </dt>\n          <dd>\n            About\n            <span\n              v-if=\"profile.distanceInKm <= 150\"\n              :title=\"profile.name + ' is close enough to commute to your location.'\"\n              class=\"user-match\"\n            >{{ textDistance }} away</span>\n            <template v-else>{{ textDistance }} away</template>\n            in {{ profile.city }}\n          </dd>\n        </span>\n        <template v-else-if=\"profile.city\">\n          <dt>\n            <i class=\"fa fa-map-marker\"></i>\n            <span class=\"sr-only\">City</span>\n          </dt>\n          <dd>\n            {{ profile.city }}\n          </dd>\n        </template>\n        <template v-if=\"profile.links\">\n          <dt>\n            <i class=\"fa fa-link\"></i>\n            <span class=\"sr-only\">Links</span>\n          </dt>\n          <dd>\n            <ul>\n              <li v-for=\"link in profile.links\">\n                <a :href=\"link\" target=_blank>{{ minimizeLink(link) }}</a>\n              </li>\n            </ul>\n          </dd>\n        </template>\n        <footer v-if=\"hasSocialLinks\" class=\"social\">\n          <a class=github v-if=\"profile.github\" :href=\"githubUrl(profile.github)\">\n            <i class=\"fa fa-github\"></i>\n            <span class=\"sr-only\">Github</span>\n          </a>\n          <a class=twitter v-if=\"profile.twitter\" :href=\"'https://twitter.com/' + profile.twitter\">\n            <i class=\"fa fa-twitter\"></i>\n            <span class=\"sr-only\">Twitter</span>\n          </a>\n          <a class=codepen v-if=\"profile.codepen\" :href=\"'https://codepen.io/' + profile.codepen\">\n            <i class=\"fa fa-codepen\"></i>\n            <span class=\"sr-only\">CodePen</span>\n          </a>\n          <a class=linkedin v-if=\"profile.linkedin\" :href=\"'https://www.linkedin.com/in/' + profile.linkedin\">\n            <i class=\"fa fa-linkedin\"></i>\n            <span class=\"sr-only\">LinkedIn</span>\n          </a>\n        </footer>\n      </dl>\n    </div>\n  </div>\n</script>\n\n<div id=\"team-members\">\n  <div class=\"team\">\n\n    <h2 id=\"active-core-team-members\">\n      核心团队活跃成员\n      <button v-if=\"geolocationSupported && !userPosition\" @click=\"getUserPosition\" :disabled=\"isSorting\" class=\"sort-by-distance-button\">\n        <i v-if=\"isSorting\" class=\"fa fa-refresh rotating-clockwise\"></i>\n        <template v-else>\n          <i class=\"fa fa-map-marker\"></i>\n          <span>谁在我附近</span>\n        </template>\n      </button>\n    </h2>\n\n    <p v-if=\"errorGettingLocation\" class=\"tip\">\n      未成功获取您的位置。\n    </p>\n\n    <p>\n      mypUI 的开发及其生态建设来自不同的省份与技术领域，这里会展示其中部分团队成员的信息。\n    </p>\n\n    <p v-if=\"userPosition\" class=\"success\">\n      核心团队成员已经按照跟你的距离排序。\n    </p>\n\n    <vuer-profile v-for=\"profile in sortedTeam\" :key=\"profile.name\" :profile=\"profile\" :title-visible=\"titleVisible\"></vuer-profile>\n  </div>\n\n  <div class=\"team\">\n    <h2 id=\"core-team-emeriti\">\n      核心团队荣誉成员\n    </h2>\n\n    <p>\n      我们在此致敬过去曾做出过突出贡献的不再活跃的团队成员。\n    </p>\n\n    <vuer-profile v-for=\"profile in teamEmeriti\" :key=\"profile.name\" :profile=\"profile\" :title-visible=\"titleVisible\"></vuer-profile>\n  </div>\n\n  <div class=\"team\">\n    <h2 id=\"community-partners\">\n      社区伙伴\n      <button v-if=\"geolocationSupported && !userPosition\" @click=\"getUserPosition\" :disabled=\"isSorting\" class=\"sort-by-distance-button\">\n        <i v-if=\"isSorting\" class=\"fa fa-refresh rotating-clockwise\"></i>\n        <template v-else>\n          <i class=\"fa fa-map-marker\"></i>\n          <span>谁在我附近</span>\n        </template>\n      </button>\n    </h2>\n\n    <p v-if=\"errorGettingLocation\" class=\"tip\">\n      未成功获取您的位置。\n    </p>\n\n    <p>\n      一些 mypUI 的社区成员让这里变得更加丰富多彩，有必要在此特别提及。我们与这些主要合作伙伴建立了更加亲密的关系，经常与他们就即将到来的功能和新闻展开协作。\n    </p>\n\n    <p v-if=\"userPosition\" class=\"success\">\n      社区伙伴们已经按照跟你的距离排序。\n    </p>\n\n    <vuer-profile v-for=\"profile in sortedPartners\" :key=\"profile.name\" :profile=\"profile\" :title-visible=\"titleVisible\"></vuer-profile>\n  </div>\n</div>\n\n<script>\n(function () {\n  var cityCoordsFor = {\n    '北京': [39.904200, 116.407396]\n  }\n\n  var team = [{\n    name: '马玉平',\n    title: '身体好才是真的好',\n    city: '北京',\n    github: 'wakaryry',\n    work: {\n      role: 'Creator',\n      org: 'mypUI'\n    },\n    links: [\n      'https://github.com/wakaryry'\n    ]\n  }]\n\n  team = team.concat(shuffle([\n  ]))\n\n  var emeriti = shuffle([\n  ])\n\n  var partners = [\n  ]\n\n  Vue.component('vuer-profile', {\n    template: '#vuer-profile-template',\n    props: {\n      profile: Object,\n      titleVisible: Boolean\n    },\n    computed: {\n      workHtml: function () {\n        var work = this.profile.work\n        var html = ''\n        if (work.orgUrl) {\n          html += '<a href=\"' + work.orgUrl + '\" target=\"_blank\" rel=\"noopener noreferrer\">'\n          if (work.org) {\n            html += work.org\n          } else {\n            this.minimizeLink(work.orgUrl)\n          }\n          html += '</a>'\n        } else if (work.org) {\n          html += work.org\n        }\n        if (work.role) {\n          if (html.length > 0) {\n            html = work.role + ' @ ' + html\n          } else {\n            html = work.role\n          }\n        }\n        return html\n      },\n      textDistance: function () {\n        var distanceInKm = this.profile.distanceInKm || 0\n        if (this.$root.useMiles) {\n          return roundDistance(kmToMi(distanceInKm)) + ' miles'\n        } else {\n          return roundDistance(distanceInKm) + ' km'\n        }\n      },\n      languageListHtml: function () {\n        var vm = this\n        var nav = window.navigator\n        if (!vm.profile.languages) return ''\n        var preferredLanguageCode = nav.languages\n          // The preferred language set in the browser\n          ? nav.languages[0]\n          : (\n              // The system language in IE\n              nav.userLanguage ||\n              // The language in the current page\n              nav.language\n            )\n        return (\n          '<ul><li>' +\n          vm.profile.languages.map(function (languageCode, index) {\n            var language = languageNameFor[languageCode]\n            if (\n              languageCode !== 'en' &&\n              preferredLanguageCode &&\n              languageCode === preferredLanguageCode.slice(0, 2)\n            ) {\n              return (\n                '<span ' +\n                  'class=\"user-match\" ' +\n                  'title=\"' +\n                    vm.profile.name +\n                    ' can give technical talks in your preferred language.' +\n                  '\"' +\n                '\\>' + language + '</span>'\n              )\n            }\n            return language\n          }).join('</li><li>') +\n          '</li></ul>'\n        )\n      },\n      hasSocialLinks: function () {\n        return this.profile.github || this.profile.twitter || this.profile.codepen || this.profile.linkedin\n      }\n    },\n    methods: {\n      minimizeLink: function (link) {\n        return link\n          .replace(/^https?:\\/\\/(www\\.)?/, '')\n          .replace(/\\/$/, '')\n          .replace(/^mailto:/, '')\n      },\n      /**\n       * Generate a GitHub URL using a repo and a handle.\n       */\n      githubUrl: function (handle, repo) {\n        if (repo && repo.url) {\n          return repo.url\n        }\n        if (repo && repo.indexOf('/') !== -1) {\n          // If the repo name has a slash, it must be an organization repo.\n          // In such a case, we discard the (personal) handle.\n          return (\n            'https://github.com/' +\n            repo.replace(/\\/\\*$/, '')\n          )\n        }\n        return 'https://github.com/' + handle + '/' + (repo || '')\n      }\n    }\n  })\n\n  new Vue({\n    el: '#team-members',\n    data: {\n      team: team,\n      teamEmeriti: emeriti,\n      partners: shuffle(partners),\n      geolocationSupported: false,\n      isSorting: false,\n      errorGettingLocation: false,\n      userPosition: null,\n      useMiles: false,\n      konami: {\n        position: 0,\n        code: [38, 38, 40, 40, 37, 39, 37, 39, 66, 65]\n      }\n    },\n    computed: {\n      sortedTeam: function () {\n        return this.sortVuersByDistance(this.team)\n      },\n      sortedPartners: function () {\n        return this.sortVuersByDistance(this.partners)\n      },\n      titleVisible: function () {\n        return this.konami.code.length === this.konami.position\n      }\n    },\n    created: function () {\n      var nav = window.navigator\n      if ('geolocation' in nav) {\n        this.geolocationSupported = true\n        var imperialLanguageCodes = [\n          'en-US', 'en-MY', 'en-MM', 'en-BU', 'en-LR', 'my', 'bu'\n        ]\n        if (imperialLanguageCodes.indexOf(nav.language) !== -1) {\n          this.useMiles = true\n        }\n      }\n      document.addEventListener('keydown', this.konamiKeydown)\n    },\n    beforeDestroy: function () {\n      document.removeEventListener('keydown', this.konamiKeydown)\n    },\n    methods: {\n      getUserPosition: function () {\n        var vm = this\n        var nav = window.navigator\n        vm.isSorting = true\n        nav.geolocation.getCurrentPosition(\n          function (position) {\n            vm.userPosition = position\n            vm.isSorting = false\n          },\n          function (error) {\n            vm.isSorting = false\n            vm.errorGettingLocation = true\n          },\n          {\n            enableHighAccuracy: true\n          }\n        )\n      },\n      sortVuersByDistance: function (vuers) {\n        var vm = this\n        if (!vm.userPosition) return vuers\n        var vuersWithDistances = vuers.map(function (vuer) {\n          var cityCoords = cityCoordsFor[vuer.city]\n          if (cityCoords) {\n            return Object.assign({}, vuer, {\n              distanceInKm: getDistanceFromLatLonInKm(\n                vm.userPosition.coords.latitude,\n                vm.userPosition.coords.longitude,\n                cityCoords[0],\n                cityCoords[1]\n              )\n            })\n          }\n          return Object.assign({}, vuer, {\n            distanceInKm: null\n          })\n        })\n        vuersWithDistances.sort(function (a, b) {\n          if (a.distanceInKm && b.distanceInKm) return a.distanceInKm - b.distanceInKm\n          if (a.distanceInKm && !b.distanceInKm) return -1\n          if (!a.distanceInKm && b.distanceInKm) return 1\n          if (a.name < b.name) return -1\n          if (a.name > b.name) return 1\n        })\n        return vuersWithDistances\n      },\n      konamiKeydown: function (event) {\n        if (this.titleVisible) {\n          return\n        }\n\n        if (event.keyCode !== this.konami.code[this.konami.position++]) {\n          this.konami.position = 0\n        }\n      }\n    }\n  })\n\n  /**\n  * Shuffles array in place.\n  * @param {Array} a items The array containing the items.\n  */\n  function shuffle (a) {\n    a = a.concat([])\n    if (window.location.hostname === 'localhost') {\n      return a\n    }\n    var j, x, i\n    for (i = a.length; i; i--) {\n      j = Math.floor(Math.random() * i)\n      x = a[i - 1]\n      a[i - 1] = a[j]\n      a[j] = x\n    }\n    return a\n  }\n\n  /**\n  * Calculates great-circle distances between the two points – that is, the shortest distance over the earth’s surface – using the Haversine formula.\n  * @param {Number} lat1 The latitude of the 1st location.\n  * @param {Number} lon1 The longitute of the 1st location.\n  * @param {Number} lat2 The latitude of the 2nd location.\n  * @param {Number} lon2 The longitute of the 2nd location.\n  */\n  function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2) {\n    var R = 6371 // Radius of the earth in km\n    var dLat = deg2rad(lat2-lat1)  // deg2rad below\n    var dLon = deg2rad(lon2-lon1)\n    var a =\n      Math.sin(dLat/2) * Math.sin(dLat/2) +\n      Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *\n      Math.sin(dLon/2) * Math.sin(dLon/2)\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))\n    var d = R * c // Distance in km\n    return d\n  }\n\n  function deg2rad(deg) {\n    return deg * (Math.PI/180)\n  }\n\n  function kmToMi (km) {\n    return km * 0.62137\n  }\n\n  function roundDistance (num) {\n    return Number(Math.ceil(num).toPrecision(2))\n  }\n})()\n</script>\n\n"},{"title":"风格指南","type":"style-guide","_content":"\n这里是官方的 Vue 特有代码的风格指南。如果在工程中使用 Vue，为了回避错误、小纠结和反模式，该指南是份不错的参考。不过我们也不确信风格指南的所有内容对于所有的团队或工程都是理想的。所以根据过去的经验、周围的技术栈、个人价值观做出有意义的偏差是可取的。\n\n对于其绝大部分，我们也总体上避免就 JavaScript 或 HTML 的本身提出建议。我们不介意你是否使用分号或结尾的逗号。我们不介意你在 HTML attribute 中使用单引号还是双引号。不过当我们发现在 Vue 的情景下有帮助的特定模式时，也会存在例外。\n\n> **不久之后，我们还会提供操作层面的技巧。**有的时候你只需要遵守规则，而我们会尽可能向你展示如何使用 ESLint 及其它自动化程序把操作层面弄得更简单。\n\n最终，我们把所有的规则归为了四个大类：\n\n\n\n## 规则归类\n\n### 优先级 A：必要的\n\n这些规则会帮你规避错误，所以学习并接受它们带来的全部代价吧。这里面可能存在例外，但应该非常少，且只有你同时精通 JavaScript 和 Vue 才可以这样做。\n\n### 优先级 B：强烈推荐\n\n这些规则能够在绝大多数工程中改善可读性和开发体验。即使你违反了，代码还是能照常运行，但例外应该尽可能少且有合理的理由。\n\n### 优先级 C：推荐\n\n当存在多个同样好的选项，选任意一个都可以确保一致性。在这些规则里，我们描述了每个选项并建议一个默认的选择。也就是说只要保持一致且理由充分，你可以随意在你的代码库中做出不同的选择。请务必给出一个好的理由！通过接受社区的标准，你将会：\n\n1. 训练你的大脑，以便更容易的处理你在社区遇到的代码；\n2. 不做修改就可以直接复制粘贴社区的代码示例；\n3. 能够经常招聘到和你编码习惯相同的新人，至少跟 Vue 相关的东西是这样的。\n\n### 优先级 D：谨慎使用\n\n有些 Vue 特性的存在是为了照顾极端情况或帮助老代码的平稳迁移。当被过度使用时，这些特性会让你的代码难于维护甚至变成 bug 的来源。这些规则是为了给有潜在风险的特性敲个警钟，并说明它们什么时候不应该使用以及为什么。\n\n\n\n## 优先级 A 的规则：必要的 (规避错误)\n\n\n\n### 组件名为多个单词<sup data-p=\"a\">必要</sup>\n\n**组件名应该始终是多个单词的，根组件 `App` 以及 `<transition>`、`<component>` 之类的 Vue 内置组件除外。**\n\n这样做可以避免跟现有的以及未来的 HTML 元素[相冲突](http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name)，因为所有的 HTML 元素名称都是单个单词的。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nVue.component('todo', {\n  // ...\n})\n```\n\n``` js\nexport default {\n  name: 'Todo',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nVue.component('todo-item', {\n  // ...\n})\n```\n\n``` js\nexport default {\n  name: 'TodoItem',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 组件数据<sup data-p=\"a\">必要</sup>\n\n**组件的 `data` 必须是一个函数。**\n\n当在组件中使用 `data` property 的时候 (除了 `new Vue` 外的任何地方)，它的值必须是返回一个对象的函数。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n当 `data` 的值是一个对象时，它会在这个组件的所有实例之间共享。想象一下，假如一个 `TodoList` 组件的数据是这样的：\n\n``` js\ndata: {\n  listTitle: '',\n  todos: []\n}\n```\n\n我们可能希望重用这个组件，允许用户维护多个列表 (比如分为购物、心愿单、日常事务等)。这时就会产生问题。因为每个组件的实例都引用了相同的数据对象，更改其中一个列表的标题就会改变其它每一个列表的标题。增删改一个待办事项的时候也是如此。\n\n取而代之的是，我们希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了：\n\n``` js\ndata: function () {\n  return {\n    listTitle: '',\n    todos: []\n  }\n}\n```\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nVue.component('some-comp', {\n  data: {\n    foo: 'bar'\n  }\n})\n```\n\n``` js\nexport default {\n  data: {\n    foo: 'bar'\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n``` js\nVue.component('some-comp', {\n  data: function () {\n    return {\n      foo: 'bar'\n    }\n  }\n})\n```\n\n``` js\n// In a .vue file\nexport default {\n  data () {\n    return {\n      foo: 'bar'\n    }\n  }\n}\n```\n\n``` js\n// 在一个 Vue 的根实例上直接使用对象是可以的，\n// 因为只存在一个这样的实例。\nnew Vue({\n  data: {\n    foo: 'bar'\n  }\n})\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Prop 定义<sup data-p=\"a\">必要</sup>\n\n**Prop 定义应该尽量详细。**\n\n在你提交的代码中，prop 的定义应该尽量详细，至少需要指定其类型。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n细致的 [prop 定义](../guide/components-props.html#Prop-验证)有两个好处：\n\n- 它们写明了组件的 API，所以很容易看懂组件的用法；\n- 在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\n// 这样做只有开发原型系统时可以接受\nprops: ['status']\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nprops: {\n  status: String\n}\n```\n\n``` js\n// 更好的做法！\nprops: {\n  status: {\n    type: String,\n    required: true,\n    validator: function (value) {\n      return [\n        'syncing',\n        'synced',\n        'version-conflict',\n        'error'\n      ].indexOf(value) !== -1\n    }\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 为 `v-for` 设置键值<sup data-p=\"a\">必要</sup>\n\n**总是用 `key` 配合 `v-for`。**\n\n在组件上*总是*必须用 `key` 配合 `v-for`，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的[对象固化 (object constancy)](https://bost.ocks.org/mike/constancy/)，也是一种好的做法。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n假设你有一个待办事项列表：\n\n``` js\ndata: function () {\n  return {\n    todos: [\n      {\n        id: 1,\n        text: '学习使用 v-for'\n      },\n      {\n        id: 2,\n        text: '学习使用 key'\n      }\n    ]\n  }\n}\n```\n\n然后你把它们按照字母顺序排序。在更新 DOM 的时候，Vue 将会优化渲染把可能的 DOM 变更降到最低。即可能删掉第一个待办事项元素，然后把它重新加回到列表的最末尾。\n\n这里的问题在于，不要删除仍然会留在 DOM 中的元素。比如你想使用 `<transition-group>` 给列表加过渡动画，或想在被渲染元素是 `<input>` 时保持聚焦。在这些情况下，为每一个项目添加一个唯一的键值 (比如 `:key=\"todo.id\"`) 将会让 Vue 知道如何使行为更容易预测。\n\n根据我们的经验，最好*始终*添加一个唯一的键值，以便你和你的团队永远不必担心这些极端情况。也在少数对性能有严格要求的情况下，为了避免对象固化，你可以刻意做一些非常规的处理。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<ul>\n  <li v-for=\"todo in todos\">\n    {{ todo.text }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<ul>\n  <li\n    v-for=\"todo in todos\"\n    :key=\"todo.id\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 避免 `v-if` 和 `v-for` 用在一起<sup data-p=\"a\">必要</sup>\n\n**永远不要把 `v-if` 和 `v-for` 同时用在同一个元素上。**\n\n一般我们在两种常见的情况下会倾向于这样做：\n\n- 为了过滤一个列表中的项目 (比如 `v-for=\"user in users\" v-if=\"user.isActive\"`)。在这种情形下，请将 `users` 替换为一个计算属性 (比如 `activeUsers`)，让其返回过滤后的列表。\n\n- 为了避免渲染本应该被隐藏的列表 (比如 `v-for=\"user in users\" v-if=\"shouldShowUsers\"`)。这种情形下，请将 `v-if` 移动至容器元素上 (比如 `ul`、`ol`)。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n当 Vue 处理指令时，`v-for` 比 `v-if` 具有更高的优先级，所以这个模板：\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"user.isActive\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n将会经过如下运算：\n\n``` js\nthis.users.map(function (user) {\n  if (user.isActive) {\n    return user.name\n  }\n})\n```\n\n因此哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。\n\n通过将其更换为在如下的一个计算属性上遍历：\n\n``` js\ncomputed: {\n  activeUsers: function () {\n    return this.users.filter(function (user) {\n      return user.isActive\n    })\n  }\n}\n```\n\n``` html\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n我们将会获得如下好处：\n\n- 过滤后的列表*只*会在 `users` 数组发生相关变化时才被重新运算，过滤更高效。\n- 使用 `v-for=\"user in activeUsers\"` 之后，我们在渲染的时候*只*遍历活跃用户，渲染更高效。\n- 解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。\n\n为了获得同样的好处，我们也可以把：\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"shouldShowUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n更新为：\n\n``` html\n<ul v-if=\"shouldShowUsers\">\n  <li\n    v-for=\"user in users\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n通过将 `v-if` 移动到容器元素，我们不会再对列表中的*每个*用户检查 `shouldShowUsers`。取而代之的是，我们只检查它一次，且不会在 `shouldShowUsers` 为否的时候运算 `v-for`。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"user.isActive\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"shouldShowUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n``` html\n<ul v-if=\"shouldShowUsers\">\n  <li\n    v-for=\"user in users\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 为组件样式设置作用域<sup data-p=\"a\">必要</sup>\n\n**对于应用来说，顶级 `App` 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的。**\n\n这条规则只和[单文件组件](../guide/single-file-components.html)有关。你*不一定*要使用 [`scoped` attribute](https://vue-loader.vuejs.org/zh-cn/features/scoped-css.html)。设置作用域也可以通过 [CSS Modules](https://vue-loader.vuejs.org/zh-cn/features/css-modules.html)，那是一个基于 class 的类似 [BEM](http://getbem.com/) 的策略，当然你也可以使用其它的库或约定。\n\n\n**不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 `scoped` attribute。**\n\n这让覆写内部样式更容易：使用了常人可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n如果你和其他开发者一起开发一个大型工程，或有时引入三方 HTML/CSS (比如来自 Auth0)，设置一致的作用域会确保你的样式只会运用在它们想要作用的组件上。\n\n不止要使用 `scoped` attribute，使用唯一的 class 名可以帮你确保那些三方库的 CSS 不会运用在你自己的 HTML 上。比如许多工程都使用了 `button`、`btn` 或 `icon` class 名，所以即便你不使用类似 BEM 的策略，添加一个 app 专属或组件专属的前缀 (比如 `ButtonClose-icon`) 也可以提供很多保护。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<template>\n  <button class=\"btn btn-close\">X</button>\n</template>\n\n<style>\n.btn-close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<template>\n  <button class=\"button button-close\">X</button>\n</template>\n\n<!-- 使用 `scoped` attribute -->\n<style scoped>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.button-close {\n  background-color: red;\n}\n</style>\n```\n\n``` html\n<template>\n  <button :class=\"[$style.button, $style.buttonClose]\">X</button>\n</template>\n\n<!-- 使用 CSS Modules -->\n<style module>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.buttonClose {\n  background-color: red;\n}\n</style>\n```\n\n``` html\n<template>\n  <button class=\"c-Button c-Button--close\">X</button>\n</template>\n\n<!-- 使用 BEM 约定 -->\n<style>\n.c-Button {\n  border: none;\n  border-radius: 2px;\n}\n\n.c-Button--close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 私有 property 名<sup data-p=\"a\">必要</sup>\n\n**使用模块作用域保持不允许外部访问的函数的私有性。如果无法做到这一点，就始终为插件、混入等不考虑作为对外公共 API 的自定义私有 property 使用 `$_` 前缀。并附带一个命名空间以回避和其它作者的冲突 (比如 `$_yourPluginName_`)。**\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\nVue 使用 `_` 前缀来定义其自身的私有 property，所以使用相同的前缀 (比如 `_update`) 有覆写实例 property 的风险。即便你检查确认 Vue 当前版本没有用到这个 property 名，也不能保证和将来的版本没有冲突。\n\n对于 `$` 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例 property，所以把它用于*私有* property 并不合适。\n\n不过，我们推荐把这两个前缀结合为 `$_`，作为一个用户定义的私有 property 的约定，以确保不会和 Vue 自身相冲突。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    _update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $_update: function () {\n      // ...\n    }\n  }\n}\n```\n\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $_myGreatMixin_update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\n// 甚至更好！\nvar myGreatMixin = {\n  // ...\n  methods: {\n    publicMethod() {\n      // ...\n      myPrivateFunction()\n    }\n  }\n}\n\nfunction myPrivateFunction() {\n  // ...\n}\n\nexport default myGreatMixin\n```\n{% raw %}</div>{% endraw %}\n\n\n\n## 优先级 B 的规则：强烈推荐 (增强可读性)\n\n\n\n### 组件文件<sup data-p=\"b\">强烈推荐</sup>\n\n**只要有能够拼接文件的构建系统，就把每个组件单独分成文件。**\n\n当你需要编辑一个组件或查阅一个组件的用法时，可以更快速的找到它。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nVue.component('TodoList', {\n  // ...\n})\n\nVue.component('TodoItem', {\n  // ...\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- TodoList.js\n|- TodoItem.js\n```\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoItem.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 单文件组件文件的大小写<sup data-p=\"b\">强烈推荐</sup>\n\n**[单文件组件](../guide/single-file-components.html)的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。**\n\n单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- mycomponent.vue\n```\n\n```\ncomponents/\n|- myComponent.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- MyComponent.vue\n```\n\n```\ncomponents/\n|- my-component.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 基础组件名<sup data-p=\"b\">强烈推荐</sup>\n\n**应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 `Base`、`App` 或 `V`。**\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n这些组件为你的应用奠定了一致的基础样式和行为。它们可能**只**包括：\n\n- HTML 元素\n- 其它基础组件\n- 第三方 UI 组件库\n\n但是它们**绝不会**包括全局状态 (比如来自 Vuex store)。\n\n它们的名字通常包含所包裹元素的名字 (比如 `BaseButton`、`BaseTable`)，除非没有现成的对应功能的元素 (比如 `BaseIcon`)。如果你为特定的上下文构建类似的组件，那它们几乎总会消费这些组件 (比如 `BaseButton` 可能会用在 `ButtonSubmit` 上)。\n\n这样做的几个好处：\n\n- 当你在编辑器中以字母顺序排序时，你的应用的基础组件会全部列在一起，这样更容易识别。\n\n- 因为组件名应该始终是多个单词，所以这样做可以避免你在包裹简单组件时随意选择前缀 (比如 `MyButton`、`VueButton`)。\n\n- 因为这些组件会被频繁使用，所以你可能想把它们放到全局而不是在各处分别导入它们。使用相同的前缀可以让 webpack 这样工作：\n\n  ``` js\n  var requireComponent = require.context(\"./src\", true, /Base[A-Z]\\w+\\.(vue|js)$/)\n  requireComponent.keys().forEach(function (fileName) {\n    var baseComponentConfig = requireComponent(fileName)\n    baseComponentConfig = baseComponentConfig.default || baseComponentConfig\n    var baseComponentName = baseComponentConfig.name || (\n      fileName\n        .replace(/^.+\\//, '')\n        .replace(/\\.\\w+$/, '')\n    )\n    Vue.component(baseComponentName, baseComponentConfig)\n  })\n  ```\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- MyButton.vue\n|- VueTable.vue\n|- Icon.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue\n```\n\n```\ncomponents/\n|- AppButton.vue\n|- AppTable.vue\n|- AppIcon.vue\n```\n\n```\ncomponents/\n|- VButton.vue\n|- VTable.vue\n|- VIcon.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 单例组件名<sup data-p=\"b\">强烈推荐</sup>\n\n**只应该拥有单个活跃实例的组件应该以 `The` 前缀命名，以示其唯一性。**\n\n这不意味着组件只可用于一个单页面，而是*每个页面*只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，*只是目前*在每个页面里只使用一次。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- Heading.vue\n|- MySidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- TheHeading.vue\n|- TheSidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 紧密耦合的组件名<sup data-p=\"b\">强烈推荐</sup>\n\n**和父组件紧密耦合的子组件应该以父组件名作为前缀命名。**\n\n如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n你可以试着通过在其父组件命名的目录中嵌套子组件以解决这个问题。比如：\n\n```\ncomponents/\n|- TodoList/\n   |- Item/\n      |- index.vue\n      |- Button.vue\n   |- index.vue\n```\n\n或：\n\n```\ncomponents/\n|- TodoList/\n   |- Item/\n      |- Button.vue\n   |- Item.vue\n|- TodoList.vue\n```\n\n但是这种方式并不推荐，因为这会导致：\n\n- 许多文件的名字相同，使得在编辑器中快速切换文件变得困难。\n- 过多嵌套的子目录增加了在编辑器侧边栏中浏览组件所花的时间。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoItem.vue\n|- TodoButton.vue\n```\n\n```\ncomponents/\n|- SearchSidebar.vue\n|- NavigationForSearchSidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemButton.vue\n```\n\n```\ncomponents/\n|- SearchSidebar.vue\n|- SearchSidebarNavigation.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 组件名中的单词顺序<sup data-p=\"b\">强烈推荐</sup>\n\n**组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。**\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n你可能会疑惑：\n\n> “为什么我们给组件命名时不多遵从自然语言呢？”\n\n在自然的英文里，形容词和其它描述语通常都出现在名词之前，否则需要使用连接词。比如：\n\n- Coffee _with_ milk\n- Soup _of the_ day\n- Visitor _to the_ museum\n\n如果你愿意，你完全可以在组件名里包含这些连接词，但是单词的顺序很重要。\n\n同样要注意**在你的应用中所谓的“高级别”是跟语境有关的**。比如对于一个带搜索表单的应用来说，它可能包含这样的组件：\n\n```\ncomponents/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue\n```\n\n你可能注意到了，我们很难看出来哪些组件是针对搜索的。现在我们来根据规则给组件重新命名：\n\n```\ncomponents/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputExcludeGlob.vue\n|- SearchInputQuery.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n|- SettingsCheckboxTerms.vue\n```\n\n因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。\n\n你可能想换成多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为：\n\n- 在多级目录间找来找去，要比在单个 `components` 目录下滚动查找要花费更多的精力。\n- 存在组件重名 (比如存在多个 `ButtonDelete` 组件) 的时候在编辑器里更难快速定位。\n- 让重构变得更难，因为为一个移动了的组件更新相关引用时，查找/替换通常并不高效。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputQuery.vue\n|- SearchInputExcludeGlob.vue\n|- SettingsCheckboxTerms.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 自闭合组件<sup data-p=\"b\">强烈推荐</sup>\n\n**在[单文件组件](../guide/single-file-components.html)、字符串模板和 [JSX](../guide/render-function.html#JSX) 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。**\n\n自闭合组件表示它们不仅没有内容，而且**刻意**没有内容。其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸。而且没有了额外的闭合标签，你的代码也更简洁。\n\n不幸的是，HTML 并不支持自闭合的自定义元素——只有[官方的“空”元素](https://www.w3.org/TR/html/syntax.html#void-elements)。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<!-- 在单文件组件、字符串模板和 JSX 中 -->\n<MyComponent></MyComponent>\n```\n\n``` html\n<!-- 在 DOM 模板中 -->\n<my-component/>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<!-- 在单文件组件、字符串模板和 JSX 中 -->\n<MyComponent/>\n```\n\n``` html\n<!-- 在 DOM 模板中 -->\n<my-component></my-component>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 模板中的组件名大小写<sup data-p=\"b\">强烈推荐</sup>\n\n**对于绝大多数项目来说，在[单文件组件](../guide/single-file-components.html)和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。**\n\nPascalCase 相比 kebab-case 有一些优势：\n\n- 编辑器可以在模板里自动补全组件名，因为 PascalCase 同样适用于 JavaScript。\n- `<MyComponent>` 视觉上比 `<my-component>` 更能够和单个单词的 HTML 元素区别开来，因为前者的不同之处有两个大写字母，后者只有一个横线。\n- 如果你在模板中使用任何非 Vue 的自定义元素，比如一个 Web Component，PascalCase 确保了你的 Vue 组件在视觉上仍然是易识别的。\n\n不幸的是，由于 HTML 是大小写不敏感的，在 DOM 模板中必须仍使用 kebab-case。\n\n还请注意，如果你已经是 kebab-case 的重度用户，那么与 HTML 保持一致的命名约定且在多个项目中保持相同的大小写规则就可能比上述优势更为重要了。在这些情况下，**在所有的地方都使用 kebab-case 同样是可以接受的。**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<!-- 在单文件组件和字符串模板中 -->\n<mycomponent/>\n```\n\n``` html\n<!-- 在单文件组件和字符串模板中 -->\n<myComponent/>\n```\n\n``` html\n<!-- 在 DOM 模板中 -->\n<MyComponent></MyComponent>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<!-- 在单文件组件和字符串模板中 -->\n<MyComponent/>\n```\n\n``` html\n<!-- 在 DOM 模板中 -->\n<my-component></my-component>\n```\n\n或者\n\n``` html\n<!-- 在所有地方 -->\n<my-component></my-component>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### JS/JSX 中的组件名大小写<sup data-p=\"b\">强烈推荐</sup>\n\n**JS/[JSX](../guide/render-function.html#JSX) 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 `Vue.component` 进行全局组件注册时，可以使用 kebab-case 字符串。**\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n在 JavaScript 中，PascalCase 是类和构造函数 (本质上任何可以产生多份不同实例的东西) 的命名约定。Vue 组件也有多份实例，所以同样使用 PascalCase 是有意义的。额外的好处是，在 JSX (和模板) 里使用 PascalCase 使得代码的读者更容易分辨 Vue 组件和 HTML 元素。\n\n然而，对于**只**通过 `Vue.component` 定义全局组件的应用来说，我们推荐 kebab-case 作为替代。原因是：\n\n- 全局组件很少被 JavaScript 引用，所以遵守 JavaScript 的命名约定意义不大。\n- 这些应用往往包含许多 DOM 内的模板，这种情况下是[**必须**使用 kebab-case](#模板中的组件名大小写-强烈推荐) 的。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nVue.component('myComponent', {\n  // ...\n})\n```\n\n``` js\nimport myComponent from './MyComponent.vue'\n```\n\n``` js\nexport default {\n  name: 'myComponent',\n  // ...\n}\n```\n\n``` js\nexport default {\n  name: 'my-component',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nVue.component('MyComponent', {\n  // ...\n})\n```\n\n``` js\nVue.component('my-component', {\n  // ...\n})\n```\n\n``` js\nimport MyComponent from './MyComponent.vue'\n```\n\n``` js\nexport default {\n  name: 'MyComponent',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 完整单词的组件名<sup data-p=\"b\">强烈推荐</sup>\n\n**组件名应该倾向于完整单词而不是缩写。**\n\n编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- SdSettings.vue\n|- UProfOpts.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- StudentDashboardSettings.vue\n|- UserProfileOptions.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Prop 名大小写<sup data-p=\"b\">强烈推荐</sup>\n\n**在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 [JSX](../guide/render-function.html#JSX) 中应该始终使用 kebab-case。**\n\n我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nprops: {\n  'greeting-text': String\n}\n```\n\n{% codeblock lang:html %}\n<WelcomeMessage greetingText=\"hi\"/>\n{% endcodeblock %}\n\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nprops: {\n  greetingText: String\n}\n```\n\n{% codeblock lang:html %}\n<WelcomeMessage greeting-text=\"hi\"/>\n{% endcodeblock %}\n\n{% raw %}</div>{% endraw %}\n\n\n\n### 多个 attribute 的元素<sup data-p=\"b\">强烈推荐</sup>\n\n**多个 attribute 的元素应该分多行撰写，每个 attribute 一行。**\n\n在 JavaScript 中，用多行分隔对象的多个 property 是很常见的最佳实践，因为这样更易读。模板和 [JSX](../guide/render-function.html#JSX) 值得我们做相同的考虑。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<img src=\"https://vuejs.org/images/logo.png\" alt=\"Vue Logo\">\n```\n\n``` html\n<MyComponent foo=\"a\" bar=\"b\" baz=\"c\"/>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<img\n  src=\"https://vuejs.org/images/logo.png\"\n  alt=\"Vue Logo\"\n>\n```\n\n``` html\n<MyComponent\n  foo=\"a\"\n  bar=\"b\"\n  baz=\"c\"\n/>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 模板中简单的表达式<sup data-p=\"b\">强烈推荐</sup>\n\n**组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。**\n\n复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的*是什么*，而非*如何*计算那个值。而且计算属性和方法使得代码可以重用。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n{{\n  fullName.split(' ').map(function (word) {\n    return word[0].toUpperCase() + word.slice(1)\n  }).join(' ')\n}}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<!-- 在模板中 -->\n{{ normalizedFullName }}\n```\n\n``` js\n// 复杂表达式已经移入一个计算属性\ncomputed: {\n  normalizedFullName: function () {\n    return this.fullName.split(' ').map(function (word) {\n      return word[0].toUpperCase() + word.slice(1)\n    }).join(' ')\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 简单的计算属性<sup data-p=\"b\">强烈推荐</sup>\n\n**应该把复杂计算属性分割为尽可能多的更简单的 property。**\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n更简单、命名得当的计算属性是这样的：\n\n- **易于测试**\n\n  当每个计算属性都包含一个非常简单且很少依赖的表达式时，撰写测试以确保其正确工作就会更加容易。\n\n- **易于阅读**\n\n  简化计算属性要求你为每一个值都起一个描述性的名称，即便它不可复用。这使得其他开发者 (以及未来的你) 更容易专注在他们关心的代码上并搞清楚发生了什么。\n\n- **更好的“拥抱变化”**\n\n  任何能够命名的值都可能用在视图上。举个例子，我们可能打算展示一个信息，告诉用户他们存了多少钱；也可能打算计算税费，但是可能会分开展现，而不是作为总价的一部分。\n\n  小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\ncomputed: {\n  price: function () {\n    var basePrice = this.manufactureCost / (1 - this.profitMargin)\n    return (\n      basePrice -\n      basePrice * (this.discountPercent || 0)\n    )\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\ncomputed: {\n  basePrice: function () {\n    return this.manufactureCost / (1 - this.profitMargin)\n  },\n  discount: function () {\n    return this.basePrice * (this.discountPercent || 0)\n  },\n  finalPrice: function () {\n    return this.basePrice - this.discount\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 带引号的 attribute 值<sup data-p=\"b\">强烈推荐</sup>\n\n**非空 HTML attribute 值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。**\n\n在 HTML 中不带空格的 attribute 值是可以没有引号的，但这鼓励了大家在特征值里*不写*空格，导致可读性变差。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<input type=text>\n```\n\n``` html\n<AppSidebar :style={width:sidebarWidth+'px'}>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<input type=\"text\">\n```\n\n``` html\n<AppSidebar :style=\"{ width: sidebarWidth + 'px' }\">\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 指令缩写<sup data-p=\"b\">强烈推荐</sup>\n\n**指令缩写 (用 `:` 表示 `v-bind:`、用 `@` 表示 `v-on:` 和用 `#` 表示 `v-slot:`) 应该要么都用要么都不用。**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<input\n  v-bind:value=\"newTodoText\"\n  :placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  v-on:input=\"onInput\"\n  @focus=\"onFocus\"\n>\n```\n\n``` html\n<template v-slot:header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template #footer>\n  <p>Here's some contact info</p>\n</template>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<input\n  :value=\"newTodoText\"\n  :placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  v-bind:value=\"newTodoText\"\n  v-bind:placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  @input=\"onInput\"\n  @focus=\"onFocus\"\n>\n```\n\n``` html\n<input\n  v-on:input=\"onInput\"\n  v-on:focus=\"onFocus\"\n>\n```\n\n``` html\n<template v-slot:header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template v-slot:footer>\n  <p>Here's some contact info</p>\n</template>\n```\n\n``` html\n<template #header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template #footer>\n  <p>Here's some contact info</p>\n</template>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n## 优先级 C 的规则：推荐 (将选择和认知成本最小化)\n\n\n\n### 组件/实例的选项的顺序<sup data-p=\"c\">推荐</sup>\n\n**组件/实例的选项应该有统一的顺序。**\n\n这是我们推荐的组件选项默认顺序。它们被划分为几大类，所以你也能知道从插件里添加的新 property 应该放到哪里。\n\n1. **副作用** (触发组件外的影响)\n  - `el`\n\n2. **全局感知** (要求组件以外的知识)\n  - `name`\n  - `parent`\n\n3. **组件类型** (更改组件的类型)\n  - `functional`\n\n4. **模板修改器** (改变模板的编译方式)\n  - `delimiters`\n  - `comments`\n\n5. **模板依赖** (模板内使用的资源)\n  - `components`\n  - `directives`\n  - `filters`\n\n6. **组合** (向选项里合并 property)\n  - `extends`\n  - `mixins`\n\n7. **接口** (组件的接口)\n  - `inheritAttrs`\n  - `model`\n  - `props`/`propsData`\n\n8. **本地状态** (本地的响应式 property)\n  - `data`\n  - `computed`\n\n9. **事件** (通过响应式事件触发的回调)\n  - `watch`\n  - 生命周期钩子 (按照它们被调用的顺序)\n    - `beforeCreate`\n    - `created`\n    - `beforeMount`\n    - `mounted`\n    - `beforeUpdate`\n    - `updated`\n    - `activated`\n    - `deactivated`\n    - `beforeDestroy`\n    - `destroyed`\n\n10. **非响应式的 property** (不依赖响应系统的实例 property)\n  - `methods`\n\n11. **渲染** (组件输出的声明式描述)\n  - `template`/`render`\n  - `renderError`\n\n\n\n### 元素 attribute 的顺序<sup data-p=\"c\">推荐</sup>\n\n**元素 (包括组件) 的 attribute 应该有统一的顺序。**\n\n这是我们为组件选项推荐的默认顺序。它们被划分为几大类，所以你也能知道新添加的自定义 attribute 和指令应该放到哪里。\n\n1. **定义** (提供组件的选项)\n  - `is`\n\n2. **列表渲染** (创建多个变化的相同元素)\n  - `v-for`\n\n3. **条件渲染** (元素是否渲染/显示)\n  - `v-if`\n  - `v-else-if`\n  - `v-else`\n  - `v-show`\n  - `v-cloak`\n\n4. **渲染方式** (改变元素的渲染方式)\n  - `v-pre`\n  - `v-once`\n\n5. **全局感知** (需要超越组件的知识)\n  - `id`\n\n6. **唯一的 attribute** (需要唯一值的 attribute)\n  - `ref`\n  - `key`\n\n7. **双向绑定** (把绑定和事件结合起来)\n  - `v-model`\n\n8. **其它 attribute** (所有普通的绑定或未绑定的 attribute)\n\n9. **事件** (组件事件监听器)\n  - `v-on`\n\n10. **内容** (覆写元素的内容)\n  - `v-html`\n  - `v-text`\n\n\n\n### 组件/实例选项中的空行<sup data-p=\"c\">推荐</sup>\n\n**你可能想在多个 property 之间增加一个空行，特别是在这些选项一屏放不下，需要滚动才能都看到的时候。**\n\n当你的组件开始觉得密集或难以阅读时，在多个 property 之间添加空行可以让其变得容易。在一些诸如 Vim 的编辑器里，这样格式化后的选项还能通过键盘被快速导航。\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nprops: {\n  value: {\n    type: String,\n    required: true\n  },\n\n  focused: {\n    type: Boolean,\n    default: false\n  },\n\n  label: String,\n  icon: String\n},\n\ncomputed: {\n  formattedValue: function () {\n    // ...\n  },\n\n  inputClasses: function () {\n    // ...\n  }\n}\n```\n\n``` js\n// 没有空行在组件易于阅读和导航时也没问题。\nprops: {\n  value: {\n    type: String,\n    required: true\n  },\n  focused: {\n    type: Boolean,\n    default: false\n  },\n  label: String,\n  icon: String\n},\ncomputed: {\n  formattedValue: function () {\n    // ...\n  },\n  inputClasses: function () {\n    // ...\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 单文件组件的顶级元素的顺序<sup data-p=\"c\">推荐</sup>\n\n**[单文件组件](../guide/single-file-components.html)应该总是让 `<script>`、`<template>` 和 `<style>` 标签的顺序保持一致。且 `<style>` 要放在最后，因为另外两个标签至少要有一个。**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<style>/* ... */</style>\n<script>/* ... */</script>\n<template>...</template>\n```\n\n``` html\n<!-- ComponentA.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<!-- ComponentA.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n```\n\n``` html\n<!-- ComponentA.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n## 优先级 D 的规则：谨慎使用 (有潜在危险的模式)\n\n\n\n### 没有在 `v-if`/`v-else-if`/`v-else` 中使用 `key` <sup data-p=\"d\">谨慎使用</sup>\n\n**如果一组 `v-if` + `v-else` 的元素类型相同，最好使用 `key` (比如两个 `<div>` 元素)。**\n\n默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现[意料之外的结果](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-priority-d-rules-unintended-consequences)。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<div v-if=\"error\">\n  错误：{{ error }}\n</div>\n<div v-else>\n  {{ results }}\n</div>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<div\n  v-if=\"error\"\n  key=\"search-status\"\n>\n  错误：{{ error }}\n</div>\n<div\n  v-else\n  key=\"search-results\"\n>\n  {{ results }}\n</div>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### `scoped` 中的元素选择器<sup data-p=\"d\">谨慎使用</sup>\n\n**元素选择器应该避免在 `scoped` 中出现。**\n\n在 `scoped` 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n为了给样式设置作用域，Vue 会为元素添加一个独一无二的 attribute，例如 `data-v-f3f3eg9`。然后修改选择器，使得在匹配选择器的元素中，只有带这个 attribute 才会真正生效 (比如 `button[data-v-f3f3eg9]`)。\n\n问题在于大量的[元素和 attribute 组合的选择器](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=a%5Bhref%5D&body=background%3A+%23CFD&ne=1000) (比如 `button[data-v-f3f3eg9]`) 会比[类和 attribute 组合的选择器](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=.class%5Bhref%5D&body=background%3A+%23CFD&ne=1000)慢，所以应该尽可能选用类选择器。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<template>\n  <button>X</button>\n</template>\n\n<style scoped>\nbutton {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<template>\n  <button class=\"btn btn-close\">X</button>\n</template>\n\n<style scoped>\n.btn-close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 隐性的父子组件通信<sup data-p=\"d\">谨慎使用</sup>\n\n**应该优先通过 prop 和事件进行父子组件之间的通信，而不是 `this.$parent` 或变更 prop。**\n\n一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 `this.$parent` 能够简化两个深度耦合的组件。\n\n问题在于，这种做法在很多*简单*的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: '<input v-model=\"todo.text\">'\n})\n```\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  methods: {\n    removeTodo () {\n      var vm = this\n      vm.$parent.todos = vm.$parent.todos.filter(function (todo) {\n        return todo.id !== vm.todo.id\n      })\n    }\n  },\n  template: `\n    <span>\n      {{ todo.text }}\n      <button @click=\"removeTodo\">\n        X\n      </button>\n    </span>\n  `\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: `\n    <input\n      :value=\"todo.text\"\n      @input=\"$emit('input', $event.target.value)\"\n    >\n  `\n})\n```\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: `\n    <span>\n      {{ todo.text }}\n      <button @click=\"$emit('delete')\">\n        X\n      </button>\n    </span>\n  `\n})\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 非 Flux 的全局状态管理<sup data-p=\"d\">谨慎使用</sup>\n\n**应该优先通过 [Vuex](https://github.com/vuejs/vuex) 管理全局状态，而不是通过 `this.$root` 或一个全局事件总线。**\n\n通过 `this.$root` 和/或[全局事件总线](../guide/migration.html#dispatch-和-broadcast-替换)管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。\n\nVuex 是 Vue 的[官方类 flux 实现](../guide/state-management.html#类-Flux-状态管理的官方实现)，其提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。它很好地集成在了 Vue 生态系统之中 (包括完整的 [Vue DevTools](../guide/installation.html#Vue-Devtools) 支持)。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\n// main.js\nnew Vue({\n  data: {\n    todos: []\n  },\n  created: function () {\n    this.$on('remove-todo', this.removeTodo)\n  },\n  methods: {\n    removeTodo: function (todo) {\n      var todoIdToRemove = todo.id\n      this.todos = this.todos.filter(function (todo) {\n        return todo.id !== todoIdToRemove\n      })\n    }\n  }\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\n// store/modules/todos.js\nexport default {\n  state: {\n    list: []\n  },\n  mutations: {\n    REMOVE_TODO (state, todoId) {\n      state.list = state.list.filter(todo => todo.id !== todoId)\n    }\n  },\n  actions: {\n    removeTodo ({ commit, state }, todo) {\n      commit('REMOVE_TODO', todo.id)\n    }\n  }\n}\n```\n\n``` html\n<!-- TodoItem.vue -->\n<template>\n  <span>\n    {{ todo.text }}\n    <button @click=\"removeTodo(todo)\">\n      X\n    </button>\n  </span>\n</template>\n\n<script>\nimport { mapActions } from 'vuex'\n\nexport default {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  methods: mapActions(['removeTodo'])\n}\n</script>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n{% raw %}\n<script>\n(function () {\n  var enforcementTypes = {\n    none: '<span title=\"这一规则无法强制执行\">自律</span>',\n    runtime: '运行时错误',\n    linter: '<a href=\"https://github.com/vuejs/eslint-plugin-vue#eslint-plugin-vue\" target=\"_blank\" rel=\"noopener noreferrer\">plugin:vue/recommended</a>'\n  }\n  Vue.component('sg-enforcement', {\n    template: '\\\n      <span>\\\n        <strong>强制执行</strong>:\\\n        <span class=\"style-rule-tag\" v-html=\"humanType\"/>\\\n      </span>\\\n    ',\n    props: {\n      type: {\n        type: String,\n        required: true,\n        validate: function (value) {\n          Object.keys(enforcementTypes).indexOf(value) !== -1\n        }\n      }\n    },\n    computed: {\n      humanType: function () {\n        return enforcementTypes[this.type]\n      }\n    }\n  })\n\n  // new Vue({\n  //  el: '#main'\n  // })\n})()\n</script>\n{% endraw %}\n","source":"doc/style-guide/index.md","raw":"---\ntitle: 风格指南\ntype: style-guide\n---\n\n这里是官方的 Vue 特有代码的风格指南。如果在工程中使用 Vue，为了回避错误、小纠结和反模式，该指南是份不错的参考。不过我们也不确信风格指南的所有内容对于所有的团队或工程都是理想的。所以根据过去的经验、周围的技术栈、个人价值观做出有意义的偏差是可取的。\n\n对于其绝大部分，我们也总体上避免就 JavaScript 或 HTML 的本身提出建议。我们不介意你是否使用分号或结尾的逗号。我们不介意你在 HTML attribute 中使用单引号还是双引号。不过当我们发现在 Vue 的情景下有帮助的特定模式时，也会存在例外。\n\n> **不久之后，我们还会提供操作层面的技巧。**有的时候你只需要遵守规则，而我们会尽可能向你展示如何使用 ESLint 及其它自动化程序把操作层面弄得更简单。\n\n最终，我们把所有的规则归为了四个大类：\n\n\n\n## 规则归类\n\n### 优先级 A：必要的\n\n这些规则会帮你规避错误，所以学习并接受它们带来的全部代价吧。这里面可能存在例外，但应该非常少，且只有你同时精通 JavaScript 和 Vue 才可以这样做。\n\n### 优先级 B：强烈推荐\n\n这些规则能够在绝大多数工程中改善可读性和开发体验。即使你违反了，代码还是能照常运行，但例外应该尽可能少且有合理的理由。\n\n### 优先级 C：推荐\n\n当存在多个同样好的选项，选任意一个都可以确保一致性。在这些规则里，我们描述了每个选项并建议一个默认的选择。也就是说只要保持一致且理由充分，你可以随意在你的代码库中做出不同的选择。请务必给出一个好的理由！通过接受社区的标准，你将会：\n\n1. 训练你的大脑，以便更容易的处理你在社区遇到的代码；\n2. 不做修改就可以直接复制粘贴社区的代码示例；\n3. 能够经常招聘到和你编码习惯相同的新人，至少跟 Vue 相关的东西是这样的。\n\n### 优先级 D：谨慎使用\n\n有些 Vue 特性的存在是为了照顾极端情况或帮助老代码的平稳迁移。当被过度使用时，这些特性会让你的代码难于维护甚至变成 bug 的来源。这些规则是为了给有潜在风险的特性敲个警钟，并说明它们什么时候不应该使用以及为什么。\n\n\n\n## 优先级 A 的规则：必要的 (规避错误)\n\n\n\n### 组件名为多个单词<sup data-p=\"a\">必要</sup>\n\n**组件名应该始终是多个单词的，根组件 `App` 以及 `<transition>`、`<component>` 之类的 Vue 内置组件除外。**\n\n这样做可以避免跟现有的以及未来的 HTML 元素[相冲突](http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name)，因为所有的 HTML 元素名称都是单个单词的。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nVue.component('todo', {\n  // ...\n})\n```\n\n``` js\nexport default {\n  name: 'Todo',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nVue.component('todo-item', {\n  // ...\n})\n```\n\n``` js\nexport default {\n  name: 'TodoItem',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 组件数据<sup data-p=\"a\">必要</sup>\n\n**组件的 `data` 必须是一个函数。**\n\n当在组件中使用 `data` property 的时候 (除了 `new Vue` 外的任何地方)，它的值必须是返回一个对象的函数。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n当 `data` 的值是一个对象时，它会在这个组件的所有实例之间共享。想象一下，假如一个 `TodoList` 组件的数据是这样的：\n\n``` js\ndata: {\n  listTitle: '',\n  todos: []\n}\n```\n\n我们可能希望重用这个组件，允许用户维护多个列表 (比如分为购物、心愿单、日常事务等)。这时就会产生问题。因为每个组件的实例都引用了相同的数据对象，更改其中一个列表的标题就会改变其它每一个列表的标题。增删改一个待办事项的时候也是如此。\n\n取而代之的是，我们希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了：\n\n``` js\ndata: function () {\n  return {\n    listTitle: '',\n    todos: []\n  }\n}\n```\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nVue.component('some-comp', {\n  data: {\n    foo: 'bar'\n  }\n})\n```\n\n``` js\nexport default {\n  data: {\n    foo: 'bar'\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n``` js\nVue.component('some-comp', {\n  data: function () {\n    return {\n      foo: 'bar'\n    }\n  }\n})\n```\n\n``` js\n// In a .vue file\nexport default {\n  data () {\n    return {\n      foo: 'bar'\n    }\n  }\n}\n```\n\n``` js\n// 在一个 Vue 的根实例上直接使用对象是可以的，\n// 因为只存在一个这样的实例。\nnew Vue({\n  data: {\n    foo: 'bar'\n  }\n})\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Prop 定义<sup data-p=\"a\">必要</sup>\n\n**Prop 定义应该尽量详细。**\n\n在你提交的代码中，prop 的定义应该尽量详细，至少需要指定其类型。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n细致的 [prop 定义](../guide/components-props.html#Prop-验证)有两个好处：\n\n- 它们写明了组件的 API，所以很容易看懂组件的用法；\n- 在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\n// 这样做只有开发原型系统时可以接受\nprops: ['status']\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nprops: {\n  status: String\n}\n```\n\n``` js\n// 更好的做法！\nprops: {\n  status: {\n    type: String,\n    required: true,\n    validator: function (value) {\n      return [\n        'syncing',\n        'synced',\n        'version-conflict',\n        'error'\n      ].indexOf(value) !== -1\n    }\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 为 `v-for` 设置键值<sup data-p=\"a\">必要</sup>\n\n**总是用 `key` 配合 `v-for`。**\n\n在组件上*总是*必须用 `key` 配合 `v-for`，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的[对象固化 (object constancy)](https://bost.ocks.org/mike/constancy/)，也是一种好的做法。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n假设你有一个待办事项列表：\n\n``` js\ndata: function () {\n  return {\n    todos: [\n      {\n        id: 1,\n        text: '学习使用 v-for'\n      },\n      {\n        id: 2,\n        text: '学习使用 key'\n      }\n    ]\n  }\n}\n```\n\n然后你把它们按照字母顺序排序。在更新 DOM 的时候，Vue 将会优化渲染把可能的 DOM 变更降到最低。即可能删掉第一个待办事项元素，然后把它重新加回到列表的最末尾。\n\n这里的问题在于，不要删除仍然会留在 DOM 中的元素。比如你想使用 `<transition-group>` 给列表加过渡动画，或想在被渲染元素是 `<input>` 时保持聚焦。在这些情况下，为每一个项目添加一个唯一的键值 (比如 `:key=\"todo.id\"`) 将会让 Vue 知道如何使行为更容易预测。\n\n根据我们的经验，最好*始终*添加一个唯一的键值，以便你和你的团队永远不必担心这些极端情况。也在少数对性能有严格要求的情况下，为了避免对象固化，你可以刻意做一些非常规的处理。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<ul>\n  <li v-for=\"todo in todos\">\n    {{ todo.text }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<ul>\n  <li\n    v-for=\"todo in todos\"\n    :key=\"todo.id\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 避免 `v-if` 和 `v-for` 用在一起<sup data-p=\"a\">必要</sup>\n\n**永远不要把 `v-if` 和 `v-for` 同时用在同一个元素上。**\n\n一般我们在两种常见的情况下会倾向于这样做：\n\n- 为了过滤一个列表中的项目 (比如 `v-for=\"user in users\" v-if=\"user.isActive\"`)。在这种情形下，请将 `users` 替换为一个计算属性 (比如 `activeUsers`)，让其返回过滤后的列表。\n\n- 为了避免渲染本应该被隐藏的列表 (比如 `v-for=\"user in users\" v-if=\"shouldShowUsers\"`)。这种情形下，请将 `v-if` 移动至容器元素上 (比如 `ul`、`ol`)。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n当 Vue 处理指令时，`v-for` 比 `v-if` 具有更高的优先级，所以这个模板：\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"user.isActive\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n将会经过如下运算：\n\n``` js\nthis.users.map(function (user) {\n  if (user.isActive) {\n    return user.name\n  }\n})\n```\n\n因此哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。\n\n通过将其更换为在如下的一个计算属性上遍历：\n\n``` js\ncomputed: {\n  activeUsers: function () {\n    return this.users.filter(function (user) {\n      return user.isActive\n    })\n  }\n}\n```\n\n``` html\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n我们将会获得如下好处：\n\n- 过滤后的列表*只*会在 `users` 数组发生相关变化时才被重新运算，过滤更高效。\n- 使用 `v-for=\"user in activeUsers\"` 之后，我们在渲染的时候*只*遍历活跃用户，渲染更高效。\n- 解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。\n\n为了获得同样的好处，我们也可以把：\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"shouldShowUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n更新为：\n\n``` html\n<ul v-if=\"shouldShowUsers\">\n  <li\n    v-for=\"user in users\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n通过将 `v-if` 移动到容器元素，我们不会再对列表中的*每个*用户检查 `shouldShowUsers`。取而代之的是，我们只检查它一次，且不会在 `shouldShowUsers` 为否的时候运算 `v-for`。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"user.isActive\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"shouldShowUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n``` html\n<ul v-if=\"shouldShowUsers\">\n  <li\n    v-for=\"user in users\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 为组件样式设置作用域<sup data-p=\"a\">必要</sup>\n\n**对于应用来说，顶级 `App` 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的。**\n\n这条规则只和[单文件组件](../guide/single-file-components.html)有关。你*不一定*要使用 [`scoped` attribute](https://vue-loader.vuejs.org/zh-cn/features/scoped-css.html)。设置作用域也可以通过 [CSS Modules](https://vue-loader.vuejs.org/zh-cn/features/css-modules.html)，那是一个基于 class 的类似 [BEM](http://getbem.com/) 的策略，当然你也可以使用其它的库或约定。\n\n\n**不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 `scoped` attribute。**\n\n这让覆写内部样式更容易：使用了常人可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n如果你和其他开发者一起开发一个大型工程，或有时引入三方 HTML/CSS (比如来自 Auth0)，设置一致的作用域会确保你的样式只会运用在它们想要作用的组件上。\n\n不止要使用 `scoped` attribute，使用唯一的 class 名可以帮你确保那些三方库的 CSS 不会运用在你自己的 HTML 上。比如许多工程都使用了 `button`、`btn` 或 `icon` class 名，所以即便你不使用类似 BEM 的策略，添加一个 app 专属或组件专属的前缀 (比如 `ButtonClose-icon`) 也可以提供很多保护。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<template>\n  <button class=\"btn btn-close\">X</button>\n</template>\n\n<style>\n.btn-close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<template>\n  <button class=\"button button-close\">X</button>\n</template>\n\n<!-- 使用 `scoped` attribute -->\n<style scoped>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.button-close {\n  background-color: red;\n}\n</style>\n```\n\n``` html\n<template>\n  <button :class=\"[$style.button, $style.buttonClose]\">X</button>\n</template>\n\n<!-- 使用 CSS Modules -->\n<style module>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.buttonClose {\n  background-color: red;\n}\n</style>\n```\n\n``` html\n<template>\n  <button class=\"c-Button c-Button--close\">X</button>\n</template>\n\n<!-- 使用 BEM 约定 -->\n<style>\n.c-Button {\n  border: none;\n  border-radius: 2px;\n}\n\n.c-Button--close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 私有 property 名<sup data-p=\"a\">必要</sup>\n\n**使用模块作用域保持不允许外部访问的函数的私有性。如果无法做到这一点，就始终为插件、混入等不考虑作为对外公共 API 的自定义私有 property 使用 `$_` 前缀。并附带一个命名空间以回避和其它作者的冲突 (比如 `$_yourPluginName_`)。**\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\nVue 使用 `_` 前缀来定义其自身的私有 property，所以使用相同的前缀 (比如 `_update`) 有覆写实例 property 的风险。即便你检查确认 Vue 当前版本没有用到这个 property 名，也不能保证和将来的版本没有冲突。\n\n对于 `$` 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例 property，所以把它用于*私有* property 并不合适。\n\n不过，我们推荐把这两个前缀结合为 `$_`，作为一个用户定义的私有 property 的约定，以确保不会和 Vue 自身相冲突。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    _update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $_update: function () {\n      // ...\n    }\n  }\n}\n```\n\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $_myGreatMixin_update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\n// 甚至更好！\nvar myGreatMixin = {\n  // ...\n  methods: {\n    publicMethod() {\n      // ...\n      myPrivateFunction()\n    }\n  }\n}\n\nfunction myPrivateFunction() {\n  // ...\n}\n\nexport default myGreatMixin\n```\n{% raw %}</div>{% endraw %}\n\n\n\n## 优先级 B 的规则：强烈推荐 (增强可读性)\n\n\n\n### 组件文件<sup data-p=\"b\">强烈推荐</sup>\n\n**只要有能够拼接文件的构建系统，就把每个组件单独分成文件。**\n\n当你需要编辑一个组件或查阅一个组件的用法时，可以更快速的找到它。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nVue.component('TodoList', {\n  // ...\n})\n\nVue.component('TodoItem', {\n  // ...\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- TodoList.js\n|- TodoItem.js\n```\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoItem.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 单文件组件文件的大小写<sup data-p=\"b\">强烈推荐</sup>\n\n**[单文件组件](../guide/single-file-components.html)的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。**\n\n单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- mycomponent.vue\n```\n\n```\ncomponents/\n|- myComponent.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- MyComponent.vue\n```\n\n```\ncomponents/\n|- my-component.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 基础组件名<sup data-p=\"b\">强烈推荐</sup>\n\n**应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 `Base`、`App` 或 `V`。**\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n这些组件为你的应用奠定了一致的基础样式和行为。它们可能**只**包括：\n\n- HTML 元素\n- 其它基础组件\n- 第三方 UI 组件库\n\n但是它们**绝不会**包括全局状态 (比如来自 Vuex store)。\n\n它们的名字通常包含所包裹元素的名字 (比如 `BaseButton`、`BaseTable`)，除非没有现成的对应功能的元素 (比如 `BaseIcon`)。如果你为特定的上下文构建类似的组件，那它们几乎总会消费这些组件 (比如 `BaseButton` 可能会用在 `ButtonSubmit` 上)。\n\n这样做的几个好处：\n\n- 当你在编辑器中以字母顺序排序时，你的应用的基础组件会全部列在一起，这样更容易识别。\n\n- 因为组件名应该始终是多个单词，所以这样做可以避免你在包裹简单组件时随意选择前缀 (比如 `MyButton`、`VueButton`)。\n\n- 因为这些组件会被频繁使用，所以你可能想把它们放到全局而不是在各处分别导入它们。使用相同的前缀可以让 webpack 这样工作：\n\n  ``` js\n  var requireComponent = require.context(\"./src\", true, /Base[A-Z]\\w+\\.(vue|js)$/)\n  requireComponent.keys().forEach(function (fileName) {\n    var baseComponentConfig = requireComponent(fileName)\n    baseComponentConfig = baseComponentConfig.default || baseComponentConfig\n    var baseComponentName = baseComponentConfig.name || (\n      fileName\n        .replace(/^.+\\//, '')\n        .replace(/\\.\\w+$/, '')\n    )\n    Vue.component(baseComponentName, baseComponentConfig)\n  })\n  ```\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- MyButton.vue\n|- VueTable.vue\n|- Icon.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue\n```\n\n```\ncomponents/\n|- AppButton.vue\n|- AppTable.vue\n|- AppIcon.vue\n```\n\n```\ncomponents/\n|- VButton.vue\n|- VTable.vue\n|- VIcon.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 单例组件名<sup data-p=\"b\">强烈推荐</sup>\n\n**只应该拥有单个活跃实例的组件应该以 `The` 前缀命名，以示其唯一性。**\n\n这不意味着组件只可用于一个单页面，而是*每个页面*只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，*只是目前*在每个页面里只使用一次。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- Heading.vue\n|- MySidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- TheHeading.vue\n|- TheSidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 紧密耦合的组件名<sup data-p=\"b\">强烈推荐</sup>\n\n**和父组件紧密耦合的子组件应该以父组件名作为前缀命名。**\n\n如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n你可以试着通过在其父组件命名的目录中嵌套子组件以解决这个问题。比如：\n\n```\ncomponents/\n|- TodoList/\n   |- Item/\n      |- index.vue\n      |- Button.vue\n   |- index.vue\n```\n\n或：\n\n```\ncomponents/\n|- TodoList/\n   |- Item/\n      |- Button.vue\n   |- Item.vue\n|- TodoList.vue\n```\n\n但是这种方式并不推荐，因为这会导致：\n\n- 许多文件的名字相同，使得在编辑器中快速切换文件变得困难。\n- 过多嵌套的子目录增加了在编辑器侧边栏中浏览组件所花的时间。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoItem.vue\n|- TodoButton.vue\n```\n\n```\ncomponents/\n|- SearchSidebar.vue\n|- NavigationForSearchSidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemButton.vue\n```\n\n```\ncomponents/\n|- SearchSidebar.vue\n|- SearchSidebarNavigation.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 组件名中的单词顺序<sup data-p=\"b\">强烈推荐</sup>\n\n**组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。**\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n你可能会疑惑：\n\n> “为什么我们给组件命名时不多遵从自然语言呢？”\n\n在自然的英文里，形容词和其它描述语通常都出现在名词之前，否则需要使用连接词。比如：\n\n- Coffee _with_ milk\n- Soup _of the_ day\n- Visitor _to the_ museum\n\n如果你愿意，你完全可以在组件名里包含这些连接词，但是单词的顺序很重要。\n\n同样要注意**在你的应用中所谓的“高级别”是跟语境有关的**。比如对于一个带搜索表单的应用来说，它可能包含这样的组件：\n\n```\ncomponents/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue\n```\n\n你可能注意到了，我们很难看出来哪些组件是针对搜索的。现在我们来根据规则给组件重新命名：\n\n```\ncomponents/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputExcludeGlob.vue\n|- SearchInputQuery.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n|- SettingsCheckboxTerms.vue\n```\n\n因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。\n\n你可能想换成多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为：\n\n- 在多级目录间找来找去，要比在单个 `components` 目录下滚动查找要花费更多的精力。\n- 存在组件重名 (比如存在多个 `ButtonDelete` 组件) 的时候在编辑器里更难快速定位。\n- 让重构变得更难，因为为一个移动了的组件更新相关引用时，查找/替换通常并不高效。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputQuery.vue\n|- SearchInputExcludeGlob.vue\n|- SettingsCheckboxTerms.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 自闭合组件<sup data-p=\"b\">强烈推荐</sup>\n\n**在[单文件组件](../guide/single-file-components.html)、字符串模板和 [JSX](../guide/render-function.html#JSX) 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。**\n\n自闭合组件表示它们不仅没有内容，而且**刻意**没有内容。其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸。而且没有了额外的闭合标签，你的代码也更简洁。\n\n不幸的是，HTML 并不支持自闭合的自定义元素——只有[官方的“空”元素](https://www.w3.org/TR/html/syntax.html#void-elements)。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<!-- 在单文件组件、字符串模板和 JSX 中 -->\n<MyComponent></MyComponent>\n```\n\n``` html\n<!-- 在 DOM 模板中 -->\n<my-component/>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<!-- 在单文件组件、字符串模板和 JSX 中 -->\n<MyComponent/>\n```\n\n``` html\n<!-- 在 DOM 模板中 -->\n<my-component></my-component>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 模板中的组件名大小写<sup data-p=\"b\">强烈推荐</sup>\n\n**对于绝大多数项目来说，在[单文件组件](../guide/single-file-components.html)和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。**\n\nPascalCase 相比 kebab-case 有一些优势：\n\n- 编辑器可以在模板里自动补全组件名，因为 PascalCase 同样适用于 JavaScript。\n- `<MyComponent>` 视觉上比 `<my-component>` 更能够和单个单词的 HTML 元素区别开来，因为前者的不同之处有两个大写字母，后者只有一个横线。\n- 如果你在模板中使用任何非 Vue 的自定义元素，比如一个 Web Component，PascalCase 确保了你的 Vue 组件在视觉上仍然是易识别的。\n\n不幸的是，由于 HTML 是大小写不敏感的，在 DOM 模板中必须仍使用 kebab-case。\n\n还请注意，如果你已经是 kebab-case 的重度用户，那么与 HTML 保持一致的命名约定且在多个项目中保持相同的大小写规则就可能比上述优势更为重要了。在这些情况下，**在所有的地方都使用 kebab-case 同样是可以接受的。**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<!-- 在单文件组件和字符串模板中 -->\n<mycomponent/>\n```\n\n``` html\n<!-- 在单文件组件和字符串模板中 -->\n<myComponent/>\n```\n\n``` html\n<!-- 在 DOM 模板中 -->\n<MyComponent></MyComponent>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<!-- 在单文件组件和字符串模板中 -->\n<MyComponent/>\n```\n\n``` html\n<!-- 在 DOM 模板中 -->\n<my-component></my-component>\n```\n\n或者\n\n``` html\n<!-- 在所有地方 -->\n<my-component></my-component>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### JS/JSX 中的组件名大小写<sup data-p=\"b\">强烈推荐</sup>\n\n**JS/[JSX](../guide/render-function.html#JSX) 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 `Vue.component` 进行全局组件注册时，可以使用 kebab-case 字符串。**\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n在 JavaScript 中，PascalCase 是类和构造函数 (本质上任何可以产生多份不同实例的东西) 的命名约定。Vue 组件也有多份实例，所以同样使用 PascalCase 是有意义的。额外的好处是，在 JSX (和模板) 里使用 PascalCase 使得代码的读者更容易分辨 Vue 组件和 HTML 元素。\n\n然而，对于**只**通过 `Vue.component` 定义全局组件的应用来说，我们推荐 kebab-case 作为替代。原因是：\n\n- 全局组件很少被 JavaScript 引用，所以遵守 JavaScript 的命名约定意义不大。\n- 这些应用往往包含许多 DOM 内的模板，这种情况下是[**必须**使用 kebab-case](#模板中的组件名大小写-强烈推荐) 的。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nVue.component('myComponent', {\n  // ...\n})\n```\n\n``` js\nimport myComponent from './MyComponent.vue'\n```\n\n``` js\nexport default {\n  name: 'myComponent',\n  // ...\n}\n```\n\n``` js\nexport default {\n  name: 'my-component',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nVue.component('MyComponent', {\n  // ...\n})\n```\n\n``` js\nVue.component('my-component', {\n  // ...\n})\n```\n\n``` js\nimport MyComponent from './MyComponent.vue'\n```\n\n``` js\nexport default {\n  name: 'MyComponent',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 完整单词的组件名<sup data-p=\"b\">强烈推荐</sup>\n\n**组件名应该倾向于完整单词而不是缩写。**\n\n编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n```\ncomponents/\n|- SdSettings.vue\n|- UProfOpts.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n```\ncomponents/\n|- StudentDashboardSettings.vue\n|- UserProfileOptions.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Prop 名大小写<sup data-p=\"b\">强烈推荐</sup>\n\n**在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 [JSX](../guide/render-function.html#JSX) 中应该始终使用 kebab-case。**\n\n我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nprops: {\n  'greeting-text': String\n}\n```\n\n{% codeblock lang:html %}\n<WelcomeMessage greetingText=\"hi\"/>\n{% endcodeblock %}\n\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nprops: {\n  greetingText: String\n}\n```\n\n{% codeblock lang:html %}\n<WelcomeMessage greeting-text=\"hi\"/>\n{% endcodeblock %}\n\n{% raw %}</div>{% endraw %}\n\n\n\n### 多个 attribute 的元素<sup data-p=\"b\">强烈推荐</sup>\n\n**多个 attribute 的元素应该分多行撰写，每个 attribute 一行。**\n\n在 JavaScript 中，用多行分隔对象的多个 property 是很常见的最佳实践，因为这样更易读。模板和 [JSX](../guide/render-function.html#JSX) 值得我们做相同的考虑。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<img src=\"https://vuejs.org/images/logo.png\" alt=\"Vue Logo\">\n```\n\n``` html\n<MyComponent foo=\"a\" bar=\"b\" baz=\"c\"/>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<img\n  src=\"https://vuejs.org/images/logo.png\"\n  alt=\"Vue Logo\"\n>\n```\n\n``` html\n<MyComponent\n  foo=\"a\"\n  bar=\"b\"\n  baz=\"c\"\n/>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 模板中简单的表达式<sup data-p=\"b\">强烈推荐</sup>\n\n**组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。**\n\n复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的*是什么*，而非*如何*计算那个值。而且计算属性和方法使得代码可以重用。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n{{\n  fullName.split(' ').map(function (word) {\n    return word[0].toUpperCase() + word.slice(1)\n  }).join(' ')\n}}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<!-- 在模板中 -->\n{{ normalizedFullName }}\n```\n\n``` js\n// 复杂表达式已经移入一个计算属性\ncomputed: {\n  normalizedFullName: function () {\n    return this.fullName.split(' ').map(function (word) {\n      return word[0].toUpperCase() + word.slice(1)\n    }).join(' ')\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 简单的计算属性<sup data-p=\"b\">强烈推荐</sup>\n\n**应该把复杂计算属性分割为尽可能多的更简单的 property。**\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n更简单、命名得当的计算属性是这样的：\n\n- **易于测试**\n\n  当每个计算属性都包含一个非常简单且很少依赖的表达式时，撰写测试以确保其正确工作就会更加容易。\n\n- **易于阅读**\n\n  简化计算属性要求你为每一个值都起一个描述性的名称，即便它不可复用。这使得其他开发者 (以及未来的你) 更容易专注在他们关心的代码上并搞清楚发生了什么。\n\n- **更好的“拥抱变化”**\n\n  任何能够命名的值都可能用在视图上。举个例子，我们可能打算展示一个信息，告诉用户他们存了多少钱；也可能打算计算税费，但是可能会分开展现，而不是作为总价的一部分。\n\n  小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\ncomputed: {\n  price: function () {\n    var basePrice = this.manufactureCost / (1 - this.profitMargin)\n    return (\n      basePrice -\n      basePrice * (this.discountPercent || 0)\n    )\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\ncomputed: {\n  basePrice: function () {\n    return this.manufactureCost / (1 - this.profitMargin)\n  },\n  discount: function () {\n    return this.basePrice * (this.discountPercent || 0)\n  },\n  finalPrice: function () {\n    return this.basePrice - this.discount\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 带引号的 attribute 值<sup data-p=\"b\">强烈推荐</sup>\n\n**非空 HTML attribute 值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。**\n\n在 HTML 中不带空格的 attribute 值是可以没有引号的，但这鼓励了大家在特征值里*不写*空格，导致可读性变差。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<input type=text>\n```\n\n``` html\n<AppSidebar :style={width:sidebarWidth+'px'}>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<input type=\"text\">\n```\n\n``` html\n<AppSidebar :style=\"{ width: sidebarWidth + 'px' }\">\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 指令缩写<sup data-p=\"b\">强烈推荐</sup>\n\n**指令缩写 (用 `:` 表示 `v-bind:`、用 `@` 表示 `v-on:` 和用 `#` 表示 `v-slot:`) 应该要么都用要么都不用。**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<input\n  v-bind:value=\"newTodoText\"\n  :placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  v-on:input=\"onInput\"\n  @focus=\"onFocus\"\n>\n```\n\n``` html\n<template v-slot:header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template #footer>\n  <p>Here's some contact info</p>\n</template>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<input\n  :value=\"newTodoText\"\n  :placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  v-bind:value=\"newTodoText\"\n  v-bind:placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  @input=\"onInput\"\n  @focus=\"onFocus\"\n>\n```\n\n``` html\n<input\n  v-on:input=\"onInput\"\n  v-on:focus=\"onFocus\"\n>\n```\n\n``` html\n<template v-slot:header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template v-slot:footer>\n  <p>Here's some contact info</p>\n</template>\n```\n\n``` html\n<template #header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template #footer>\n  <p>Here's some contact info</p>\n</template>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n## 优先级 C 的规则：推荐 (将选择和认知成本最小化)\n\n\n\n### 组件/实例的选项的顺序<sup data-p=\"c\">推荐</sup>\n\n**组件/实例的选项应该有统一的顺序。**\n\n这是我们推荐的组件选项默认顺序。它们被划分为几大类，所以你也能知道从插件里添加的新 property 应该放到哪里。\n\n1. **副作用** (触发组件外的影响)\n  - `el`\n\n2. **全局感知** (要求组件以外的知识)\n  - `name`\n  - `parent`\n\n3. **组件类型** (更改组件的类型)\n  - `functional`\n\n4. **模板修改器** (改变模板的编译方式)\n  - `delimiters`\n  - `comments`\n\n5. **模板依赖** (模板内使用的资源)\n  - `components`\n  - `directives`\n  - `filters`\n\n6. **组合** (向选项里合并 property)\n  - `extends`\n  - `mixins`\n\n7. **接口** (组件的接口)\n  - `inheritAttrs`\n  - `model`\n  - `props`/`propsData`\n\n8. **本地状态** (本地的响应式 property)\n  - `data`\n  - `computed`\n\n9. **事件** (通过响应式事件触发的回调)\n  - `watch`\n  - 生命周期钩子 (按照它们被调用的顺序)\n    - `beforeCreate`\n    - `created`\n    - `beforeMount`\n    - `mounted`\n    - `beforeUpdate`\n    - `updated`\n    - `activated`\n    - `deactivated`\n    - `beforeDestroy`\n    - `destroyed`\n\n10. **非响应式的 property** (不依赖响应系统的实例 property)\n  - `methods`\n\n11. **渲染** (组件输出的声明式描述)\n  - `template`/`render`\n  - `renderError`\n\n\n\n### 元素 attribute 的顺序<sup data-p=\"c\">推荐</sup>\n\n**元素 (包括组件) 的 attribute 应该有统一的顺序。**\n\n这是我们为组件选项推荐的默认顺序。它们被划分为几大类，所以你也能知道新添加的自定义 attribute 和指令应该放到哪里。\n\n1. **定义** (提供组件的选项)\n  - `is`\n\n2. **列表渲染** (创建多个变化的相同元素)\n  - `v-for`\n\n3. **条件渲染** (元素是否渲染/显示)\n  - `v-if`\n  - `v-else-if`\n  - `v-else`\n  - `v-show`\n  - `v-cloak`\n\n4. **渲染方式** (改变元素的渲染方式)\n  - `v-pre`\n  - `v-once`\n\n5. **全局感知** (需要超越组件的知识)\n  - `id`\n\n6. **唯一的 attribute** (需要唯一值的 attribute)\n  - `ref`\n  - `key`\n\n7. **双向绑定** (把绑定和事件结合起来)\n  - `v-model`\n\n8. **其它 attribute** (所有普通的绑定或未绑定的 attribute)\n\n9. **事件** (组件事件监听器)\n  - `v-on`\n\n10. **内容** (覆写元素的内容)\n  - `v-html`\n  - `v-text`\n\n\n\n### 组件/实例选项中的空行<sup data-p=\"c\">推荐</sup>\n\n**你可能想在多个 property 之间增加一个空行，特别是在这些选项一屏放不下，需要滚动才能都看到的时候。**\n\n当你的组件开始觉得密集或难以阅读时，在多个 property 之间添加空行可以让其变得容易。在一些诸如 Vim 的编辑器里，这样格式化后的选项还能通过键盘被快速导航。\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nprops: {\n  value: {\n    type: String,\n    required: true\n  },\n\n  focused: {\n    type: Boolean,\n    default: false\n  },\n\n  label: String,\n  icon: String\n},\n\ncomputed: {\n  formattedValue: function () {\n    // ...\n  },\n\n  inputClasses: function () {\n    // ...\n  }\n}\n```\n\n``` js\n// 没有空行在组件易于阅读和导航时也没问题。\nprops: {\n  value: {\n    type: String,\n    required: true\n  },\n  focused: {\n    type: Boolean,\n    default: false\n  },\n  label: String,\n  icon: String\n},\ncomputed: {\n  formattedValue: function () {\n    // ...\n  },\n  inputClasses: function () {\n    // ...\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 单文件组件的顶级元素的顺序<sup data-p=\"c\">推荐</sup>\n\n**[单文件组件](../guide/single-file-components.html)应该总是让 `<script>`、`<template>` 和 `<style>` 标签的顺序保持一致。且 `<style>` 要放在最后，因为另外两个标签至少要有一个。**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<style>/* ... */</style>\n<script>/* ... */</script>\n<template>...</template>\n```\n\n``` html\n<!-- ComponentA.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<!-- ComponentA.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n```\n\n``` html\n<!-- ComponentA.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n## 优先级 D 的规则：谨慎使用 (有潜在危险的模式)\n\n\n\n### 没有在 `v-if`/`v-else-if`/`v-else` 中使用 `key` <sup data-p=\"d\">谨慎使用</sup>\n\n**如果一组 `v-if` + `v-else` 的元素类型相同，最好使用 `key` (比如两个 `<div>` 元素)。**\n\n默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现[意料之外的结果](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-priority-d-rules-unintended-consequences)。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<div v-if=\"error\">\n  错误：{{ error }}\n</div>\n<div v-else>\n  {{ results }}\n</div>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<div\n  v-if=\"error\"\n  key=\"search-status\"\n>\n  错误：{{ error }}\n</div>\n<div\n  v-else\n  key=\"search-results\"\n>\n  {{ results }}\n</div>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### `scoped` 中的元素选择器<sup data-p=\"d\">谨慎使用</sup>\n\n**元素选择器应该避免在 `scoped` 中出现。**\n\n在 `scoped` 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。\n\n{% raw %}\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n{% endraw %}\n\n为了给样式设置作用域，Vue 会为元素添加一个独一无二的 attribute，例如 `data-v-f3f3eg9`。然后修改选择器，使得在匹配选择器的元素中，只有带这个 attribute 才会真正生效 (比如 `button[data-v-f3f3eg9]`)。\n\n问题在于大量的[元素和 attribute 组合的选择器](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=a%5Bhref%5D&body=background%3A+%23CFD&ne=1000) (比如 `button[data-v-f3f3eg9]`) 会比[类和 attribute 组合的选择器](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=.class%5Bhref%5D&body=background%3A+%23CFD&ne=1000)慢，所以应该尽可能选用类选择器。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` html\n<template>\n  <button>X</button>\n</template>\n\n<style scoped>\nbutton {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` html\n<template>\n  <button class=\"btn btn-close\">X</button>\n</template>\n\n<style scoped>\n.btn-close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 隐性的父子组件通信<sup data-p=\"d\">谨慎使用</sup>\n\n**应该优先通过 prop 和事件进行父子组件之间的通信，而不是 `this.$parent` 或变更 prop。**\n\n一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 `this.$parent` 能够简化两个深度耦合的组件。\n\n问题在于，这种做法在很多*简单*的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: '<input v-model=\"todo.text\">'\n})\n```\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  methods: {\n    removeTodo () {\n      var vm = this\n      vm.$parent.todos = vm.$parent.todos.filter(function (todo) {\n        return todo.id !== vm.todo.id\n      })\n    }\n  },\n  template: `\n    <span>\n      {{ todo.text }}\n      <button @click=\"removeTodo\">\n        X\n      </button>\n    </span>\n  `\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: `\n    <input\n      :value=\"todo.text\"\n      @input=\"$emit('input', $event.target.value)\"\n    >\n  `\n})\n```\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: `\n    <span>\n      {{ todo.text }}\n      <button @click=\"$emit('delete')\">\n        X\n      </button>\n    </span>\n  `\n})\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### 非 Flux 的全局状态管理<sup data-p=\"d\">谨慎使用</sup>\n\n**应该优先通过 [Vuex](https://github.com/vuejs/vuex) 管理全局状态，而不是通过 `this.$root` 或一个全局事件总线。**\n\n通过 `this.$root` 和/或[全局事件总线](../guide/migration.html#dispatch-和-broadcast-替换)管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。\n\nVuex 是 Vue 的[官方类 flux 实现](../guide/state-management.html#类-Flux-状态管理的官方实现)，其提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。它很好地集成在了 Vue 生态系统之中 (包括完整的 [Vue DevTools](../guide/installation.html#Vue-Devtools) 支持)。\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n\n#### 反例\n\n``` js\n// main.js\nnew Vue({\n  data: {\n    todos: []\n  },\n  created: function () {\n    this.$on('remove-todo', this.removeTodo)\n  },\n  methods: {\n    removeTodo: function (todo) {\n      var todoIdToRemove = todo.id\n      this.todos = this.todos.filter(function (todo) {\n        return todo.id !== todoIdToRemove\n      })\n    }\n  }\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n\n#### 好例子\n\n``` js\n// store/modules/todos.js\nexport default {\n  state: {\n    list: []\n  },\n  mutations: {\n    REMOVE_TODO (state, todoId) {\n      state.list = state.list.filter(todo => todo.id !== todoId)\n    }\n  },\n  actions: {\n    removeTodo ({ commit, state }, todo) {\n      commit('REMOVE_TODO', todo.id)\n    }\n  }\n}\n```\n\n``` html\n<!-- TodoItem.vue -->\n<template>\n  <span>\n    {{ todo.text }}\n    <button @click=\"removeTodo(todo)\">\n      X\n    </button>\n  </span>\n</template>\n\n<script>\nimport { mapActions } from 'vuex'\n\nexport default {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  methods: mapActions(['removeTodo'])\n}\n</script>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n{% raw %}\n<script>\n(function () {\n  var enforcementTypes = {\n    none: '<span title=\"这一规则无法强制执行\">自律</span>',\n    runtime: '运行时错误',\n    linter: '<a href=\"https://github.com/vuejs/eslint-plugin-vue#eslint-plugin-vue\" target=\"_blank\" rel=\"noopener noreferrer\">plugin:vue/recommended</a>'\n  }\n  Vue.component('sg-enforcement', {\n    template: '\\\n      <span>\\\n        <strong>强制执行</strong>:\\\n        <span class=\"style-rule-tag\" v-html=\"humanType\"/>\\\n      </span>\\\n    ',\n    props: {\n      type: {\n        type: String,\n        required: true,\n        validate: function (value) {\n          Object.keys(enforcementTypes).indexOf(value) !== -1\n        }\n      }\n    },\n    computed: {\n      humanType: function () {\n        return enforcementTypes[this.type]\n      }\n    }\n  })\n\n  // new Vue({\n  //  el: '#main'\n  // })\n})()\n</script>\n{% endraw %}\n","date":"2020-07-16T14:01:57.659Z","updated":"2020-07-16T14:01:57.659Z","path":"doc/style-guide/index.html","comments":1,"layout":"page","_id":"ckcwngnle001z9lxkvyj2gxvj","content":"<p>这里是官方的 Vue 特有代码的风格指南。如果在工程中使用 Vue，为了回避错误、小纠结和反模式，该指南是份不错的参考。不过我们也不确信风格指南的所有内容对于所有的团队或工程都是理想的。所以根据过去的经验、周围的技术栈、个人价值观做出有意义的偏差是可取的。</p>\n<p>对于其绝大部分，我们也总体上避免就 JavaScript 或 HTML 的本身提出建议。我们不介意你是否使用分号或结尾的逗号。我们不介意你在 HTML attribute 中使用单引号还是双引号。不过当我们发现在 Vue 的情景下有帮助的特定模式时，也会存在例外。</p>\n<blockquote>\n<p><strong>不久之后，我们还会提供操作层面的技巧。</strong>有的时候你只需要遵守规则，而我们会尽可能向你展示如何使用 ESLint 及其它自动化程序把操作层面弄得更简单。</p>\n</blockquote>\n<p>最终，我们把所有的规则归为了四个大类：</p>\n<h2 id=\"规则归类\"><a href=\"#规则归类\" class=\"headerlink\" title=\"规则归类\"></a>规则归类</h2><h3 id=\"优先级-A：必要的\"><a href=\"#优先级-A：必要的\" class=\"headerlink\" title=\"优先级 A：必要的\"></a>优先级 A：必要的</h3><p>这些规则会帮你规避错误，所以学习并接受它们带来的全部代价吧。这里面可能存在例外，但应该非常少，且只有你同时精通 JavaScript 和 Vue 才可以这样做。</p>\n<h3 id=\"优先级-B：强烈推荐\"><a href=\"#优先级-B：强烈推荐\" class=\"headerlink\" title=\"优先级 B：强烈推荐\"></a>优先级 B：强烈推荐</h3><p>这些规则能够在绝大多数工程中改善可读性和开发体验。即使你违反了，代码还是能照常运行，但例外应该尽可能少且有合理的理由。</p>\n<h3 id=\"优先级-C：推荐\"><a href=\"#优先级-C：推荐\" class=\"headerlink\" title=\"优先级 C：推荐\"></a>优先级 C：推荐</h3><p>当存在多个同样好的选项，选任意一个都可以确保一致性。在这些规则里，我们描述了每个选项并建议一个默认的选择。也就是说只要保持一致且理由充分，你可以随意在你的代码库中做出不同的选择。请务必给出一个好的理由！通过接受社区的标准，你将会：</p>\n<ol>\n<li>训练你的大脑，以便更容易的处理你在社区遇到的代码；</li>\n<li>不做修改就可以直接复制粘贴社区的代码示例；</li>\n<li>能够经常招聘到和你编码习惯相同的新人，至少跟 Vue 相关的东西是这样的。</li>\n</ol>\n<h3 id=\"优先级-D：谨慎使用\"><a href=\"#优先级-D：谨慎使用\" class=\"headerlink\" title=\"优先级 D：谨慎使用\"></a>优先级 D：谨慎使用</h3><p>有些 Vue 特性的存在是为了照顾极端情况或帮助老代码的平稳迁移。当被过度使用时，这些特性会让你的代码难于维护甚至变成 bug 的来源。这些规则是为了给有潜在风险的特性敲个警钟，并说明它们什么时候不应该使用以及为什么。</p>\n<h2 id=\"优先级-A-的规则：必要的-规避错误\"><a href=\"#优先级-A-的规则：必要的-规避错误\" class=\"headerlink\" title=\"优先级 A 的规则：必要的 (规避错误)\"></a>优先级 A 的规则：必要的 (规避错误)</h2><h3 id=\"组件名为多个单词必要\"><a href=\"#组件名为多个单词必要\" class=\"headerlink\" title=\"组件名为多个单词必要\"></a>组件名为多个单词<sup data-p=\"a\">必要</sup></h3><p><strong>组件名应该始终是多个单词的，根组件 <code>App</code> 以及 <code>&lt;transition&gt;</code>、<code>&lt;component&gt;</code> 之类的 Vue 内置组件除外。</strong></p>\n<p>这样做可以避免跟现有的以及未来的 HTML 元素<a href=\"http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name\" target=\"_blank\" rel=\"noopener\">相冲突</a>，因为所有的 HTML 元素名称都是单个单词的。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例\"><a href=\"#反例\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'todo'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Todo'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子\"><a href=\"#好例子\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'todo-item'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'TodoItem'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<h3 id=\"组件数据必要\"><a href=\"#组件数据必要\" class=\"headerlink\" title=\"组件数据必要\"></a>组件数据<sup data-p=\"a\">必要</sup></h3><p><strong>组件的 <code>data</code> 必须是一个函数。</strong></p>\n<p>当在组件中使用 <code>data</code> property 的时候 (除了 <code>new Vue</code> 外的任何地方)，它的值必须是返回一个对象的函数。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>当 <code>data</code> 的值是一个对象时，它会在这个组件的所有实例之间共享。想象一下，假如一个 <code>TodoList</code> 组件的数据是这样的：</p>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">listTitle</span>: <span class=\"hljs-string\">''</span>,\n  <span class=\"hljs-attr\">todos</span>: []\n&#125;</code></pre>\n<p>我们可能希望重用这个组件，允许用户维护多个列表 (比如分为购物、心愿单、日常事务等)。这时就会产生问题。因为每个组件的实例都引用了相同的数据对象，更改其中一个列表的标题就会改变其它每一个列表的标题。增删改一个待办事项的时候也是如此。</p>\n<p>取而代之的是，我们希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了：</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">listTitle</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">todos</span>: []\n  &#125;\n&#125;</code></pre>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-1\"><a href=\"#反例-1\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'some-comp'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-1\"><a href=\"#好例子-1\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'some-comp'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// In a .vue file</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 在一个 Vue 的根实例上直接使用对象是可以的，</span>\n<span class=\"hljs-comment\">// 因为只存在一个这样的实例。</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;)</code></pre>\n</div>\n<h3 id=\"Prop-定义必要\"><a href=\"#Prop-定义必要\" class=\"headerlink\" title=\"Prop 定义必要\"></a>Prop 定义<sup data-p=\"a\">必要</sup></h3><p><strong>Prop 定义应该尽量详细。</strong></p>\n<p>在你提交的代码中，prop 的定义应该尽量详细，至少需要指定其类型。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>细致的 <a href=\"../guide/components-props.html#Prop-验证\">prop 定义</a>有两个好处：</p>\n<ul>\n<li>它们写明了组件的 API，所以很容易看懂组件的用法；</li>\n<li>在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-2\"><a href=\"#反例-2\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 这样做只有开发原型系统时可以接受</span>\n<span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'status'</span>]</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-2\"><a href=\"#好例子-2\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">status</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 更好的做法！</span>\n<span class=\"hljs-attr\">props</span>: &#123;\n  <span class=\"hljs-attr\">status</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> [\n        <span class=\"hljs-string\">'syncing'</span>,\n        <span class=\"hljs-string\">'synced'</span>,\n        <span class=\"hljs-string\">'version-conflict'</span>,\n        <span class=\"hljs-string\">'error'</span>\n      ].indexOf(value) !== <span class=\"hljs-number\">-1</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"为-v-for-设置键值必要\"><a href=\"#为-v-for-设置键值必要\" class=\"headerlink\" title=\"为 v-for 设置键值必要\"></a>为 <code>v-for</code> 设置键值<sup data-p=\"a\">必要</sup></h3><p><strong>总是用 <code>key</code> 配合 <code>v-for</code>。</strong></p>\n<p>在组件上<em>总是</em>必须用 <code>key</code> 配合 <code>v-for</code>，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的<a href=\"https://bost.ocks.org/mike/constancy/\" target=\"_blank\" rel=\"noopener\">对象固化 (object constancy)</a>，也是一种好的做法。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>假设你有一个待办事项列表：</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">todos</span>: [\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'学习使用 v-for'</span>\n      &#125;,\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>,\n        <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'学习使用 key'</span>\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n<p>然后你把它们按照字母顺序排序。在更新 DOM 的时候，Vue 将会优化渲染把可能的 DOM 变更降到最低。即可能删掉第一个待办事项元素，然后把它重新加回到列表的最末尾。</p>\n<p>这里的问题在于，不要删除仍然会留在 DOM 中的元素。比如你想使用 <code>&lt;transition-group&gt;</code> 给列表加过渡动画，或想在被渲染元素是 <code>&lt;input&gt;</code> 时保持聚焦。在这些情况下，为每一个项目添加一个唯一的键值 (比如 <code>:key=&quot;todo.id&quot;</code>) 将会让 Vue 知道如何使行为更容易预测。</p>\n<p>根据我们的经验，最好<em>始终</em>添加一个唯一的键值，以便你和你的团队永远不必担心这些极端情况。也在少数对性能有严格要求的情况下，为了避免对象固化，你可以刻意做一些非常规的处理。</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-3\"><a href=\"#反例-3\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-3\"><a href=\"#好例子-3\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"todo.id\"</span>\n  &gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"避免-v-if-和-v-for-用在一起必要\"><a href=\"#避免-v-if-和-v-for-用在一起必要\" class=\"headerlink\" title=\"避免 v-if 和 v-for 用在一起必要\"></a>避免 <code>v-if</code> 和 <code>v-for</code> 用在一起<sup data-p=\"a\">必要</sup></h3><p><strong>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上。</strong></p>\n<p>一般我们在两种常见的情况下会倾向于这样做：</p>\n<ul>\n<li><p>为了过滤一个列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。在这种情形下，请将 <code>users</code> 替换为一个计算属性 (比如 <code>activeUsers</code>)，让其返回过滤后的列表。</p>\n</li>\n<li><p>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。这种情形下，请将 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>、<code>ol</code>)。</p>\n</li>\n</ul>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>当 Vue 处理指令时，<code>v-for</code> 比 <code>v-if</code> 具有更高的优先级，所以这个模板：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"user.isActive\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>将会经过如下运算：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.users.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">user</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (user.isActive) &#123;\n    <span class=\"hljs-keyword\">return</span> user.name\n  &#125;\n&#125;)</code></pre>\n<p>因此哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。</p>\n<p>通过将其更换为在如下的一个计算属性上遍历：</p>\n<pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">activeUsers</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.users.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">user</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> user.isActive\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in activeUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>我们将会获得如下好处：</p>\n<ul>\n<li>过滤后的列表<em>只</em>会在 <code>users</code> 数组发生相关变化时才被重新运算，过滤更高效。</li>\n<li>使用 <code>v-for=&quot;user in activeUsers&quot;</code> 之后，我们在渲染的时候<em>只</em>遍历活跃用户，渲染更高效。</li>\n<li>解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。</li>\n</ul>\n<p>为了获得同样的好处，我们也可以把：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>更新为：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>通过将 <code>v-if</code> 移动到容器元素，我们不会再对列表中的<em>每个</em>用户检查 <code>shouldShowUsers</code>。取而代之的是，我们只检查它一次，且不会在 <code>shouldShowUsers</code> 为否的时候运算 <code>v-for</code>。</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-4\"><a href=\"#反例-4\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"user.isActive\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-4\"><a href=\"#好例子-4\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in activeUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"为组件样式设置作用域必要\"><a href=\"#为组件样式设置作用域必要\" class=\"headerlink\" title=\"为组件样式设置作用域必要\"></a>为组件样式设置作用域<sup data-p=\"a\">必要</sup></h3><p><strong>对于应用来说，顶级 <code>App</code> 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的。</strong></p>\n<p>这条规则只和<a href=\"../guide/single-file-components.html\">单文件组件</a>有关。你<em>不一定</em>要使用 <a href=\"https://vue-loader.vuejs.org/zh-cn/features/scoped-css.html\" target=\"_blank\" rel=\"noopener\"><code>scoped</code> attribute</a>。设置作用域也可以通过 <a href=\"https://vue-loader.vuejs.org/zh-cn/features/css-modules.html\" target=\"_blank\" rel=\"noopener\">CSS Modules</a>，那是一个基于 class 的类似 <a href=\"http://getbem.com/\" target=\"_blank\" rel=\"noopener\">BEM</a> 的策略，当然你也可以使用其它的库或约定。</p>\n<p><strong>不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 <code>scoped</code> attribute。</strong></p>\n<p>这让覆写内部样式更容易：使用了常人可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>如果你和其他开发者一起开发一个大型工程，或有时引入三方 HTML/CSS (比如来自 Auth0)，设置一致的作用域会确保你的样式只会运用在它们想要作用的组件上。</p>\n<p>不止要使用 <code>scoped</code> attribute，使用唯一的 class 名可以帮你确保那些三方库的 CSS 不会运用在你自己的 HTML 上。比如许多工程都使用了 <code>button</code>、<code>btn</code> 或 <code>icon</code> class 名，所以即便你不使用类似 BEM 的策略，添加一个 app 专属或组件专属的前缀 (比如 <code>ButtonClose-icon</code>) 也可以提供很多保护。</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-5\"><a href=\"#反例-5\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.btn-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-5\"><a href=\"#好例子-5\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"button button-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 使用 `scoped` attribute --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.button-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[$style.button, $style.buttonClose]\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 使用 CSS Modules --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">module</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.buttonClose</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"c-Button c-Button--close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 使用 BEM 约定 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.c-Button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.c-Button--close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"私有-property-名必要\"><a href=\"#私有-property-名必要\" class=\"headerlink\" title=\"私有 property 名必要\"></a>私有 property 名<sup data-p=\"a\">必要</sup></h3><p><strong>使用模块作用域保持不允许外部访问的函数的私有性。如果无法做到这一点，就始终为插件、混入等不考虑作为对外公共 API 的自定义私有 property 使用 <code>$_</code> 前缀。并附带一个命名空间以回避和其它作者的冲突 (比如 <code>$_yourPluginName_</code>)。</strong></p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>Vue 使用 <code>_</code> 前缀来定义其自身的私有 property，所以使用相同的前缀 (比如 <code>_update</code>) 有覆写实例 property 的风险。即便你检查确认 Vue 当前版本没有用到这个 property 名，也不能保证和将来的版本没有冲突。</p>\n<p>对于 <code>$</code> 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例 property，所以把它用于<em>私有</em> property 并不合适。</p>\n<p>不过，我们推荐把这两个前缀结合为 <code>$_</code>，作为一个用户定义的私有 property 的约定，以确保不会和 Vue 自身相冲突。</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-6\"><a href=\"#反例-6\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-6\"><a href=\"#好例子-6\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$_myGreatMixin_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 甚至更好！</span>\n<span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    publicMethod() &#123;\n      <span class=\"hljs-comment\">// ...</span>\n      myPrivateFunction()\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myPrivateFunction</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> myGreatMixin</code></pre>\n</div>\n<h2 id=\"优先级-B-的规则：强烈推荐-增强可读性\"><a href=\"#优先级-B-的规则：强烈推荐-增强可读性\" class=\"headerlink\" title=\"优先级 B 的规则：强烈推荐 (增强可读性)\"></a>优先级 B 的规则：强烈推荐 (增强可读性)</h2><h3 id=\"组件文件强烈推荐\"><a href=\"#组件文件强烈推荐\" class=\"headerlink\" title=\"组件文件强烈推荐\"></a>组件文件<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>只要有能够拼接文件的构建系统，就把每个组件单独分成文件。</strong></p>\n<p>当你需要编辑一个组件或查阅一个组件的用法时，可以更快速的找到它。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-7\"><a href=\"#反例-7\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoList'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)\n\nVue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-7\"><a href=\"#好例子-7\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.js\n|- TodoItem.js</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoItem.vue</code></pre>\n</div>\n<h3 id=\"单文件组件文件的大小写强烈推荐\"><a href=\"#单文件组件文件的大小写强烈推荐\" class=\"headerlink\" title=\"单文件组件文件的大小写强烈推荐\"></a>单文件组件文件的大小写<sup data-p=\"b\">强烈推荐</sup></h3><p><strong><a href=\"../guide/single-file-components.html\">单文件组件</a>的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。</strong></p>\n<p>单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-8\"><a href=\"#反例-8\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- mycomponent.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- myComponent.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-8\"><a href=\"#好例子-8\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- MyComponent.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- my-component.vue</code></pre>\n</div>\n<h3 id=\"基础组件名强烈推荐\"><a href=\"#基础组件名强烈推荐\" class=\"headerlink\" title=\"基础组件名强烈推荐\"></a>基础组件名<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 <code>Base</code>、<code>App</code> 或 <code>V</code>。</strong></p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>这些组件为你的应用奠定了一致的基础样式和行为。它们可能<strong>只</strong>包括：</p>\n<ul>\n<li>HTML 元素</li>\n<li>其它基础组件</li>\n<li>第三方 UI 组件库</li>\n</ul>\n<p>但是它们<strong>绝不会</strong>包括全局状态 (比如来自 Vuex store)。</p>\n<p>它们的名字通常包含所包裹元素的名字 (比如 <code>BaseButton</code>、<code>BaseTable</code>)，除非没有现成的对应功能的元素 (比如 <code>BaseIcon</code>)。如果你为特定的上下文构建类似的组件，那它们几乎总会消费这些组件 (比如 <code>BaseButton</code> 可能会用在 <code>ButtonSubmit</code> 上)。</p>\n<p>这样做的几个好处：</p>\n<ul>\n<li><p>当你在编辑器中以字母顺序排序时，你的应用的基础组件会全部列在一起，这样更容易识别。</p>\n</li>\n<li><p>因为组件名应该始终是多个单词，所以这样做可以避免你在包裹简单组件时随意选择前缀 (比如 <code>MyButton</code>、<code>VueButton</code>)。</p>\n</li>\n<li><p>因为这些组件会被频繁使用，所以你可能想把它们放到全局而不是在各处分别导入它们。使用相同的前缀可以让 webpack 这样工作：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> requireComponent = <span class=\"hljs-built_in\">require</span>.context(<span class=\"hljs-string\">\"./src\"</span>, <span class=\"hljs-literal\">true</span>, /Base[A-Z]\\w+\\.(vue|js)$/)\nrequireComponent.keys().forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">fileName</span>) </span>&#123;\n  <span class=\"hljs-keyword\">var</span> baseComponentConfig = requireComponent(fileName)\n  baseComponentConfig = baseComponentConfig.default || baseComponentConfig\n  <span class=\"hljs-keyword\">var</span> baseComponentName = baseComponentConfig.name || (\n    fileName\n      .replace(<span class=\"hljs-regexp\">/^.+\\//</span>, <span class=\"hljs-string\">''</span>)\n      .replace(<span class=\"hljs-regexp\">/\\.\\w+$/</span>, <span class=\"hljs-string\">''</span>)\n  )\n  Vue.component(baseComponentName, baseComponentConfig)\n&#125;)</code></pre>\n</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-9\"><a href=\"#反例-9\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- MyButton.vue\n|- VueTable.vue\n|- Icon.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-9\"><a href=\"#好例子-9\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- AppButton.vue\n|- AppTable.vue\n|- AppIcon.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- VButton.vue\n|- VTable.vue\n|- VIcon.vue</code></pre>\n</div>\n<h3 id=\"单例组件名强烈推荐\"><a href=\"#单例组件名强烈推荐\" class=\"headerlink\" title=\"单例组件名强烈推荐\"></a>单例组件名<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>只应该拥有单个活跃实例的组件应该以 <code>The</code> 前缀命名，以示其唯一性。</strong></p>\n<p>这不意味着组件只可用于一个单页面，而是<em>每个页面</em>只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，<em>只是目前</em>在每个页面里只使用一次。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-10\"><a href=\"#反例-10\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- Heading.vue\n|- MySidebar.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-10\"><a href=\"#好例子-10\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- TheHeading.vue\n|- TheSidebar.vue</code></pre>\n</div>\n<h3 id=\"紧密耦合的组件名强烈推荐\"><a href=\"#紧密耦合的组件名强烈推荐\" class=\"headerlink\" title=\"紧密耦合的组件名强烈推荐\"></a>紧密耦合的组件名<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>和父组件紧密耦合的子组件应该以父组件名作为前缀命名。</strong></p>\n<p>如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>你可以试着通过在其父组件命名的目录中嵌套子组件以解决这个问题。比如：</p>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList/\n   |- Item/\n      |- index.vue\n      |- Button.vue\n   |- index.vue</code></pre>\n<p>或：</p>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList/\n   |- Item/\n      |- Button.vue\n   |- Item.vue\n|- TodoList.vue</code></pre>\n<p>但是这种方式并不推荐，因为这会导致：</p>\n<ul>\n<li>许多文件的名字相同，使得在编辑器中快速切换文件变得困难。</li>\n<li>过多嵌套的子目录增加了在编辑器侧边栏中浏览组件所花的时间。</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-11\"><a href=\"#反例-11\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoItem.vue\n|- TodoButton.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- SearchSidebar.vue\n|- NavigationForSearchSidebar.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-11\"><a href=\"#好例子-11\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemButton.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- SearchSidebar.vue\n|- SearchSidebarNavigation.vue</code></pre>\n</div>\n<h3 id=\"组件名中的单词顺序强烈推荐\"><a href=\"#组件名中的单词顺序强烈推荐\" class=\"headerlink\" title=\"组件名中的单词顺序强烈推荐\"></a>组件名中的单词顺序<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</strong></p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>你可能会疑惑：</p>\n<blockquote>\n<p>“为什么我们给组件命名时不多遵从自然语言呢？”</p>\n</blockquote>\n<p>在自然的英文里，形容词和其它描述语通常都出现在名词之前，否则需要使用连接词。比如：</p>\n<ul>\n<li>Coffee <em>with</em> milk</li>\n<li>Soup <em>of the</em> day</li>\n<li>Visitor <em>to the</em> museum</li>\n</ul>\n<p>如果你愿意，你完全可以在组件名里包含这些连接词，但是单词的顺序很重要。</p>\n<p>同样要注意<strong>在你的应用中所谓的“高级别”是跟语境有关的</strong>。比如对于一个带搜索表单的应用来说，它可能包含这样的组件：</p>\n<pre><code class=\"hljs undefined\">components/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue</code></pre>\n<p>你可能注意到了，我们很难看出来哪些组件是针对搜索的。现在我们来根据规则给组件重新命名：</p>\n<pre><code class=\"hljs undefined\">components/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputExcludeGlob.vue\n|- SearchInputQuery.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n|- SettingsCheckboxTerms.vue</code></pre>\n<p>因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。</p>\n<p>你可能想换成多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为：</p>\n<ul>\n<li>在多级目录间找来找去，要比在单个 <code>components</code> 目录下滚动查找要花费更多的精力。</li>\n<li>存在组件重名 (比如存在多个 <code>ButtonDelete</code> 组件) 的时候在编辑器里更难快速定位。</li>\n<li>让重构变得更难，因为为一个移动了的组件更新相关引用时，查找/替换通常并不高效。</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-12\"><a href=\"#反例-12\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-12\"><a href=\"#好例子-12\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputQuery.vue\n|- SearchInputExcludeGlob.vue\n|- SettingsCheckboxTerms.vue\n|- SettingsCheckboxLaunchOnStartup.vue</code></pre>\n</div>\n<h3 id=\"自闭合组件强烈推荐\"><a href=\"#自闭合组件强烈推荐\" class=\"headerlink\" title=\"自闭合组件强烈推荐\"></a>自闭合组件<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>在<a href=\"../guide/single-file-components.html\">单文件组件</a>、字符串模板和 <a href=\"../guide/render-function.html#JSX\">JSX</a> 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。</strong></p>\n<p>自闭合组件表示它们不仅没有内容，而且<strong>刻意</strong>没有内容。其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸。而且没有了额外的闭合标签，你的代码也更简洁。</p>\n<p>不幸的是，HTML 并不支持自闭合的自定义元素——只有<a href=\"https://www.w3.org/TR/html/syntax.html#void-elements\" target=\"_blank\" rel=\"noopener\">官方的“空”元素</a>。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-13\"><a href=\"#反例-13\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MyComponent</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在 DOM 模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-13\"><a href=\"#好例子-13\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在 DOM 模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"模板中的组件名大小写强烈推荐\"><a href=\"#模板中的组件名大小写强烈推荐\" class=\"headerlink\" title=\"模板中的组件名大小写强烈推荐\"></a>模板中的组件名大小写<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>对于绝大多数项目来说，在<a href=\"../guide/single-file-components.html\">单文件组件</a>和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。</strong></p>\n<p>PascalCase 相比 kebab-case 有一些优势：</p>\n<ul>\n<li>编辑器可以在模板里自动补全组件名，因为 PascalCase 同样适用于 JavaScript。</li>\n<li><code>&lt;MyComponent&gt;</code> 视觉上比 <code>&lt;my-component&gt;</code> 更能够和单个单词的 HTML 元素区别开来，因为前者的不同之处有两个大写字母，后者只有一个横线。</li>\n<li>如果你在模板中使用任何非 Vue 的自定义元素，比如一个 Web Component，PascalCase 确保了你的 Vue 组件在视觉上仍然是易识别的。</li>\n</ul>\n<p>不幸的是，由于 HTML 是大小写不敏感的，在 DOM 模板中必须仍使用 kebab-case。</p>\n<p>还请注意，如果你已经是 kebab-case 的重度用户，那么与 HTML 保持一致的命名约定且在多个项目中保持相同的大小写规则就可能比上述优势更为重要了。在这些情况下，<strong>在所有的地方都使用 kebab-case 同样是可以接受的。</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-14\"><a href=\"#反例-14\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mycomponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">myComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在 DOM 模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MyComponent</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-14\"><a href=\"#好例子-14\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在 DOM 模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>或者</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在所有地方 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"JS-JSX-中的组件名大小写强烈推荐\"><a href=\"#JS-JSX-中的组件名大小写强烈推荐\" class=\"headerlink\" title=\"JS/JSX 中的组件名大小写强烈推荐\"></a>JS/JSX 中的组件名大小写<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>JS/<a href=\"../guide/render-function.html#JSX\">JSX</a> 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 <code>Vue.component</code> 进行全局组件注册时，可以使用 kebab-case 字符串。</strong></p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>在 JavaScript 中，PascalCase 是类和构造函数 (本质上任何可以产生多份不同实例的东西) 的命名约定。Vue 组件也有多份实例，所以同样使用 PascalCase 是有意义的。额外的好处是，在 JSX (和模板) 里使用 PascalCase 使得代码的读者更容易分辨 Vue 组件和 HTML 元素。</p>\n<p>然而，对于<strong>只</strong>通过 <code>Vue.component</code> 定义全局组件的应用来说，我们推荐 kebab-case 作为替代。原因是：</p>\n<ul>\n<li>全局组件很少被 JavaScript 引用，所以遵守 JavaScript 的命名约定意义不大。</li>\n<li>这些应用往往包含许多 DOM 内的模板，这种情况下是<a href=\"#模板中的组件名大小写-强烈推荐\"><strong>必须</strong>使用 kebab-case</a> 的。</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-15\"><a href=\"#反例-15\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'myComponent'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> myComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./MyComponent.vue'</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'myComponent'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'my-component'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-15\"><a href=\"#好例子-15\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'MyComponent'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> MyComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./MyComponent.vue'</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'MyComponent'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<h3 id=\"完整单词的组件名强烈推荐\"><a href=\"#完整单词的组件名强烈推荐\" class=\"headerlink\" title=\"完整单词的组件名强烈推荐\"></a>完整单词的组件名<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>组件名应该倾向于完整单词而不是缩写。</strong></p>\n<p>编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-16\"><a href=\"#反例-16\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- SdSettings.vue\n|- UProfOpts.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-16\"><a href=\"#好例子-16\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- StudentDashboardSettings.vue\n|- UserProfileOptions.vue</code></pre>\n</div>\n<h3 id=\"Prop-名大小写强烈推荐\"><a href=\"#Prop-名大小写强烈推荐\" class=\"headerlink\" title=\"Prop 名大小写强烈推荐\"></a>Prop 名大小写<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 <a href=\"../guide/render-function.html#JSX\">JSX</a> 中应该始终使用 kebab-case。</strong></p>\n<p>我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-17\"><a href=\"#反例-17\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-string\">'greeting-text'</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WelcomeMessage</span> <span class=\"hljs-attr\">greetingText</span>=<span class=\"hljs-string\">\"hi\"</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-17\"><a href=\"#好例子-17\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">greetingText</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WelcomeMessage</span> <span class=\"hljs-attr\">greeting-text</span>=<span class=\"hljs-string\">\"hi\"</span>/&gt;</span></code></pre>\n</div>\n<h3 id=\"多个-attribute-的元素强烈推荐\"><a href=\"#多个-attribute-的元素强烈推荐\" class=\"headerlink\" title=\"多个 attribute 的元素强烈推荐\"></a>多个 attribute 的元素<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</strong></p>\n<p>在 JavaScript 中，用多行分隔对象的多个 property 是很常见的最佳实践，因为这样更易读。模板和 <a href=\"../guide/render-function.html#JSX\">JSX</a> 值得我们做相同的考虑。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-18\"><a href=\"#反例-18\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://vuejs.org/images/logo.png\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"Vue Logo\"</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span> <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">\"a\"</span> <span class=\"hljs-attr\">bar</span>=<span class=\"hljs-string\">\"b\"</span> <span class=\"hljs-attr\">baz</span>=<span class=\"hljs-string\">\"c\"</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-18\"><a href=\"#好例子-18\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span>\n  <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://vuejs.org/images/logo.png\"</span>\n  <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"Vue Logo\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>\n  <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">\"a\"</span>\n  <span class=\"hljs-attr\">bar</span>=<span class=\"hljs-string\">\"b\"</span>\n  <span class=\"hljs-attr\">baz</span>=<span class=\"hljs-string\">\"c\"</span>\n/&gt;</span></code></pre>\n</div>\n<h3 id=\"模板中简单的表达式强烈推荐\"><a href=\"#模板中简单的表达式强烈推荐\" class=\"headerlink\" title=\"模板中简单的表达式强烈推荐\"></a>模板中简单的表达式<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</strong></p>\n<p>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的<em>是什么</em>，而非<em>如何</em>计算那个值。而且计算属性和方法使得代码可以重用。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-19\"><a href=\"#反例-19\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\">&#123;&#123;\n  fullName.split(' ').map(function (word) &#123;\n    return word[0].toUpperCase() + word.slice(1)\n  &#125;).join(' ')\n&#125;&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-19\"><a href=\"#好例子-19\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在模板中 --&gt;</span>\n&#123;&#123; normalizedFullName &#125;&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 复杂表达式已经移入一个计算属性</span>\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">normalizedFullName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.fullName.split(<span class=\"hljs-string\">' '</span>).map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">word</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> word[<span class=\"hljs-number\">0</span>].toUpperCase() + word.slice(<span class=\"hljs-number\">1</span>)\n    &#125;).join(<span class=\"hljs-string\">' '</span>)\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"简单的计算属性强烈推荐\"><a href=\"#简单的计算属性强烈推荐\" class=\"headerlink\" title=\"简单的计算属性强烈推荐\"></a>简单的计算属性<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>应该把复杂计算属性分割为尽可能多的更简单的 property。</strong></p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>更简单、命名得当的计算属性是这样的：</p>\n<ul>\n<li><p><strong>易于测试</strong></p>\n<p>当每个计算属性都包含一个非常简单且很少依赖的表达式时，撰写测试以确保其正确工作就会更加容易。</p>\n</li>\n<li><p><strong>易于阅读</strong></p>\n<p>简化计算属性要求你为每一个值都起一个描述性的名称，即便它不可复用。这使得其他开发者 (以及未来的你) 更容易专注在他们关心的代码上并搞清楚发生了什么。</p>\n</li>\n<li><p><strong>更好的“拥抱变化”</strong></p>\n<p>任何能够命名的值都可能用在视图上。举个例子，我们可能打算展示一个信息，告诉用户他们存了多少钱；也可能打算计算税费，但是可能会分开展现，而不是作为总价的一部分。</p>\n<p>小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。</p>\n</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-20\"><a href=\"#反例-20\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">price</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> basePrice = <span class=\"hljs-keyword\">this</span>.manufactureCost / (<span class=\"hljs-number\">1</span> - <span class=\"hljs-keyword\">this</span>.profitMargin)\n    <span class=\"hljs-keyword\">return</span> (\n      basePrice -\n      basePrice * (<span class=\"hljs-keyword\">this</span>.discountPercent || <span class=\"hljs-number\">0</span>)\n    )\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-20\"><a href=\"#好例子-20\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">basePrice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.manufactureCost / (<span class=\"hljs-number\">1</span> - <span class=\"hljs-keyword\">this</span>.profitMargin)\n  &#125;,\n  <span class=\"hljs-attr\">discount</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.basePrice * (<span class=\"hljs-keyword\">this</span>.discountPercent || <span class=\"hljs-number\">0</span>)\n  &#125;,\n  <span class=\"hljs-attr\">finalPrice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.basePrice - <span class=\"hljs-keyword\">this</span>.discount\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"带引号的-attribute-值强烈推荐\"><a href=\"#带引号的-attribute-值强烈推荐\" class=\"headerlink\" title=\"带引号的 attribute 值强烈推荐\"></a>带引号的 attribute 值<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>非空 HTML attribute 值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。</strong></p>\n<p>在 HTML 中不带空格的 attribute 值是可以没有引号的，但这鼓励了大家在特征值里<em>不写</em>空格，导致可读性变差。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-21\"><a href=\"#反例-21\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">text</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppSidebar</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">&#123;width:sidebarWidth+</span>'<span class=\"hljs-attr\">px</span>'&#125;&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-21\"><a href=\"#好例子-21\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppSidebar</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"&#123; width: sidebarWidth + 'px' &#125;\"</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"指令缩写强烈推荐\"><a href=\"#指令缩写强烈推荐\" class=\"headerlink\" title=\"指令缩写强烈推荐\"></a>指令缩写<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>指令缩写 (用 <code>:</code> 表示 <code>v-bind:</code>、用 <code>@</code> 表示 <code>v-on:</code> 和用 <code>#</code> 表示 <code>v-slot:</code>) 应该要么都用要么都不用。</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-22\"><a href=\"#反例-22\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  @<span class=\"hljs-attr\">focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-22\"><a href=\"#好例子-22\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">v-bind:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  @<span class=\"hljs-attr\">input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  @<span class=\"hljs-attr\">focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  <span class=\"hljs-attr\">v-on:focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n</div>\n<h2 id=\"优先级-C-的规则：推荐-将选择和认知成本最小化\"><a href=\"#优先级-C-的规则：推荐-将选择和认知成本最小化\" class=\"headerlink\" title=\"优先级 C 的规则：推荐 (将选择和认知成本最小化)\"></a>优先级 C 的规则：推荐 (将选择和认知成本最小化)</h2><h3 id=\"组件-实例的选项的顺序推荐\"><a href=\"#组件-实例的选项的顺序推荐\" class=\"headerlink\" title=\"组件/实例的选项的顺序推荐\"></a>组件/实例的选项的顺序<sup data-p=\"c\">推荐</sup></h3><p><strong>组件/实例的选项应该有统一的顺序。</strong></p>\n<p>这是我们推荐的组件选项默认顺序。它们被划分为几大类，所以你也能知道从插件里添加的新 property 应该放到哪里。</p>\n<ol>\n<li><p><strong>副作用</strong> (触发组件外的影响)</p>\n<ul>\n<li><code>el</code></li>\n</ul>\n</li>\n<li><p><strong>全局感知</strong> (要求组件以外的知识)</p>\n<ul>\n<li><code>name</code></li>\n<li><code>parent</code></li>\n</ul>\n</li>\n<li><p><strong>组件类型</strong> (更改组件的类型)</p>\n<ul>\n<li><code>functional</code></li>\n</ul>\n</li>\n<li><p><strong>模板修改器</strong> (改变模板的编译方式)</p>\n<ul>\n<li><code>delimiters</code></li>\n<li><code>comments</code></li>\n</ul>\n</li>\n<li><p><strong>模板依赖</strong> (模板内使用的资源)</p>\n<ul>\n<li><code>components</code></li>\n<li><code>directives</code></li>\n<li><code>filters</code></li>\n</ul>\n</li>\n<li><p><strong>组合</strong> (向选项里合并 property)</p>\n<ul>\n<li><code>extends</code></li>\n<li><code>mixins</code></li>\n</ul>\n</li>\n<li><p><strong>接口</strong> (组件的接口)</p>\n<ul>\n<li><code>inheritAttrs</code></li>\n<li><code>model</code></li>\n<li><code>props</code>/<code>propsData</code></li>\n</ul>\n</li>\n<li><p><strong>本地状态</strong> (本地的响应式 property)</p>\n<ul>\n<li><code>data</code></li>\n<li><code>computed</code></li>\n</ul>\n</li>\n<li><p><strong>事件</strong> (通过响应式事件触发的回调)</p>\n<ul>\n<li><code>watch</code></li>\n<li>生命周期钩子 (按照它们被调用的顺序)<ul>\n<li><code>beforeCreate</code></li>\n<li><code>created</code></li>\n<li><code>beforeMount</code></li>\n<li><code>mounted</code></li>\n<li><code>beforeUpdate</code></li>\n<li><code>updated</code></li>\n<li><code>activated</code></li>\n<li><code>deactivated</code></li>\n<li><code>beforeDestroy</code></li>\n<li><code>destroyed</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>非响应式的 property</strong> (不依赖响应系统的实例 property)</p>\n<ul>\n<li><code>methods</code></li>\n</ul>\n</li>\n<li><p><strong>渲染</strong> (组件输出的声明式描述)</p>\n<ul>\n<li><code>template</code>/<code>render</code></li>\n<li><code>renderError</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"元素-attribute-的顺序推荐\"><a href=\"#元素-attribute-的顺序推荐\" class=\"headerlink\" title=\"元素 attribute 的顺序推荐\"></a>元素 attribute 的顺序<sup data-p=\"c\">推荐</sup></h3><p><strong>元素 (包括组件) 的 attribute 应该有统一的顺序。</strong></p>\n<p>这是我们为组件选项推荐的默认顺序。它们被划分为几大类，所以你也能知道新添加的自定义 attribute 和指令应该放到哪里。</p>\n<ol>\n<li><p><strong>定义</strong> (提供组件的选项)</p>\n<ul>\n<li><code>is</code></li>\n</ul>\n</li>\n<li><p><strong>列表渲染</strong> (创建多个变化的相同元素)</p>\n<ul>\n<li><code>v-for</code></li>\n</ul>\n</li>\n<li><p><strong>条件渲染</strong> (元素是否渲染/显示)</p>\n<ul>\n<li><code>v-if</code></li>\n<li><code>v-else-if</code></li>\n<li><code>v-else</code></li>\n<li><code>v-show</code></li>\n<li><code>v-cloak</code></li>\n</ul>\n</li>\n<li><p><strong>渲染方式</strong> (改变元素的渲染方式)</p>\n<ul>\n<li><code>v-pre</code></li>\n<li><code>v-once</code></li>\n</ul>\n</li>\n<li><p><strong>全局感知</strong> (需要超越组件的知识)</p>\n<ul>\n<li><code>id</code></li>\n</ul>\n</li>\n<li><p><strong>唯一的 attribute</strong> (需要唯一值的 attribute)</p>\n<ul>\n<li><code>ref</code></li>\n<li><code>key</code></li>\n</ul>\n</li>\n<li><p><strong>双向绑定</strong> (把绑定和事件结合起来)</p>\n<ul>\n<li><code>v-model</code></li>\n</ul>\n</li>\n<li><p><strong>其它 attribute</strong> (所有普通的绑定或未绑定的 attribute)</p>\n</li>\n<li><p><strong>事件</strong> (组件事件监听器)</p>\n<ul>\n<li><code>v-on</code></li>\n</ul>\n</li>\n<li><p><strong>内容</strong> (覆写元素的内容)</p>\n<ul>\n<li><code>v-html</code></li>\n<li><code>v-text</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"组件-实例选项中的空行推荐\"><a href=\"#组件-实例选项中的空行推荐\" class=\"headerlink\" title=\"组件/实例选项中的空行推荐\"></a>组件/实例选项中的空行<sup data-p=\"c\">推荐</sup></h3><p><strong>你可能想在多个 property 之间增加一个空行，特别是在这些选项一屏放不下，需要滚动才能都看到的时候。</strong></p>\n<p>当你的组件开始觉得密集或难以阅读时，在多个 property 之间添加空行可以让其变得容易。在一些诸如 Vim 的编辑器里，这样格式化后的选项还能通过键盘被快速导航。</p>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-23\"><a href=\"#好例子-23\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">value</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">focused</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Boolean</span>,\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-literal\">false</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">label</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">icon</span>: <span class=\"hljs-built_in\">String</span>\n&#125;,\n\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">formattedValue</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">inputClasses</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 没有空行在组件易于阅读和导航时也没问题。</span>\n<span class=\"hljs-attr\">props</span>: &#123;\n  <span class=\"hljs-attr\">value</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n  &#125;,\n  <span class=\"hljs-attr\">focused</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Boolean</span>,\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-literal\">false</span>\n  &#125;,\n  <span class=\"hljs-attr\">label</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">icon</span>: <span class=\"hljs-built_in\">String</span>\n&#125;,\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">formattedValue</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;,\n  <span class=\"hljs-attr\">inputClasses</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"单文件组件的顶级元素的顺序推荐\"><a href=\"#单文件组件的顶级元素的顺序推荐\" class=\"headerlink\" title=\"单文件组件的顶级元素的顺序推荐\"></a>单文件组件的顶级元素的顺序<sup data-p=\"c\">推荐</sup></h3><p><strong><a href=\"../guide/single-file-components.html\">单文件组件</a>应该总是让 <code>&lt;script&gt;</code>、<code>&lt;template&gt;</code> 和 <code>&lt;style&gt;</code> 标签的顺序保持一致。且 <code>&lt;style&gt;</code> 要放在最后，因为另外两个标签至少要有一个。</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-23\"><a href=\"#反例-23\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-24\"><a href=\"#好例子-24\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h2 id=\"优先级-D-的规则：谨慎使用-有潜在危险的模式\"><a href=\"#优先级-D-的规则：谨慎使用-有潜在危险的模式\" class=\"headerlink\" title=\"优先级 D 的规则：谨慎使用 (有潜在危险的模式)\"></a>优先级 D 的规则：谨慎使用 (有潜在危险的模式)</h2><h3 id=\"没有在-v-if-v-else-if-v-else-中使用-key-谨慎使用\"><a href=\"#没有在-v-if-v-else-if-v-else-中使用-key-谨慎使用\" class=\"headerlink\" title=\"没有在 v-if/v-else-if/v-else 中使用 key 谨慎使用\"></a>没有在 <code>v-if</code>/<code>v-else-if</code>/<code>v-else</code> 中使用 <code>key</code> <sup data-p=\"d\">谨慎使用</sup></h3><p><strong>如果一组 <code>v-if</code> + <code>v-else</code> 的元素类型相同，最好使用 <code>key</code> (比如两个 <code>&lt;div&gt;</code> 元素)。</strong></p>\n<p>默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现<a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-priority-d-rules-unintended-consequences\" target=\"_blank\" rel=\"noopener\">意料之外的结果</a>。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-24\"><a href=\"#反例-24\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>&gt;</span>\n  错误：&#123;&#123; error &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  &#123;&#123; results &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-25\"><a href=\"#好例子-25\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n  <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>\n  <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"search-status\"</span>\n&gt;</span>\n  错误：&#123;&#123; error &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n  <span class=\"hljs-attr\">v-else</span>\n  <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"search-results\"</span>\n&gt;</span>\n  &#123;&#123; results &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"scoped-中的元素选择器谨慎使用\"><a href=\"#scoped-中的元素选择器谨慎使用\" class=\"headerlink\" title=\"scoped 中的元素选择器谨慎使用\"></a><code>scoped</code> 中的元素选择器<sup data-p=\"d\">谨慎使用</sup></h3><p><strong>元素选择器应该避免在 <code>scoped</code> 中出现。</strong></p>\n<p>在 <code>scoped</code> 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>为了给样式设置作用域，Vue 会为元素添加一个独一无二的 attribute，例如 <code>data-v-f3f3eg9</code>。然后修改选择器，使得在匹配选择器的元素中，只有带这个 attribute 才会真正生效 (比如 <code>button[data-v-f3f3eg9]</code>)。</p>\n<p>问题在于大量的<a href=\"http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=a%5Bhref%5D&amp;body=background%3A+%23CFD&amp;ne=1000\" target=\"_blank\" rel=\"noopener\">元素和 attribute 组合的选择器</a> (比如 <code>button[data-v-f3f3eg9]</code>) 会比<a href=\"http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=.class%5Bhref%5D&amp;body=background%3A+%23CFD&amp;ne=1000\" target=\"_blank\" rel=\"noopener\">类和 attribute 组合的选择器</a>慢，所以应该尽可能选用类选择器。</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-25\"><a href=\"#反例-25\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-tag\">button</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-26\"><a href=\"#好例子-26\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.btn-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"隐性的父子组件通信谨慎使用\"><a href=\"#隐性的父子组件通信谨慎使用\" class=\"headerlink\" title=\"隐性的父子组件通信谨慎使用\"></a>隐性的父子组件通信<sup data-p=\"d\">谨慎使用</sup></h3><p><strong>应该优先通过 prop 和事件进行父子组件之间的通信，而不是 <code>this.$parent</code> 或变更 prop。</strong></p>\n<p>一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 <code>this.$parent</code> 能够简化两个深度耦合的组件。</p>\n<p>问题在于，这种做法在很多<em>简单</em>的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-26\"><a href=\"#反例-26\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;input v-model=\"todo.text\"&gt;'</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    removeTodo () &#123;\n      <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">this</span>\n      vm.$parent.todos = vm.$parent.todos.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> todo.id !== vm.todo.id\n      &#125;)\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;span&gt;\n      &#123;&#123; todo.text &#125;&#125;\n      &lt;button @click=\"removeTodo\"&gt;\n        X\n      &lt;/button&gt;\n    &lt;/span&gt;\n  `</span>\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-27\"><a href=\"#好例子-27\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;input\n      :value=\"todo.text\"\n      @input=\"$emit('input', $event.target.value)\"\n    &gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;span&gt;\n      &#123;&#123; todo.text &#125;&#125;\n      &lt;button @click=\"$emit('delete')\"&gt;\n        X\n      &lt;/button&gt;\n    &lt;/span&gt;\n  `</span>\n&#125;)</code></pre>\n</div>\n<h3 id=\"非-Flux-的全局状态管理谨慎使用\"><a href=\"#非-Flux-的全局状态管理谨慎使用\" class=\"headerlink\" title=\"非 Flux 的全局状态管理谨慎使用\"></a>非 Flux 的全局状态管理<sup data-p=\"d\">谨慎使用</sup></h3><p><strong>应该优先通过 <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a> 管理全局状态，而不是通过 <code>this.$root</code> 或一个全局事件总线。</strong></p>\n<p>通过 <code>this.$root</code> 和/或<a href=\"../guide/migration.html#dispatch-和-broadcast-替换\">全局事件总线</a>管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。</p>\n<p>Vuex 是 Vue 的<a href=\"../guide/state-management.html#类-Flux-状态管理的官方实现\">官方类 flux 实现</a>，其提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。它很好地集成在了 Vue 生态系统之中 (包括完整的 <a href=\"../guide/installation.html#Vue-Devtools\">Vue DevTools</a> 支持)。</p>\n\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-27\"><a href=\"#反例-27\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">todos</span>: []\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.$on(<span class=\"hljs-string\">'remove-todo'</span>, <span class=\"hljs-keyword\">this</span>.removeTodo)\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">removeTodo</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> todoIdToRemove = todo.id\n      <span class=\"hljs-keyword\">this</span>.todos = <span class=\"hljs-keyword\">this</span>.todos.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> todo.id !== todoIdToRemove\n      &#125;)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-28\"><a href=\"#好例子-28\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// store/modules/todos.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">state</span>: &#123;\n    <span class=\"hljs-attr\">list</span>: []\n  &#125;,\n  <span class=\"hljs-attr\">mutations</span>: &#123;\n    REMOVE_TODO (state, todoId) &#123;\n      state.list = state.list.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">todo</span> =&gt;</span> todo.id !== todoId)\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">actions</span>: &#123;\n    removeTodo (&#123; commit, state &#125;, todo) &#123;\n      commit(<span class=\"hljs-string\">'REMOVE_TODO'</span>, todo.id)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- TodoItem.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"removeTodo(todo)\"</span>&gt;</span>\n      X\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> &#123; mapActions &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vuex'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: mapActions([<span class=\"hljs-string\">'removeTodo'</span>])\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n</div>\n\n<script>\n(function () {\n  var enforcementTypes = {\n    none: '<span title=\"这一规则无法强制执行\">自律</span>',\n    runtime: '运行时错误',\n    linter: '<a href=\"https://github.com/vuejs/eslint-plugin-vue#eslint-plugin-vue\" target=\"_blank\" rel=\"noopener noreferrer\">plugin:vue/recommended</a>'\n  }\n  Vue.component('sg-enforcement', {\n    template: '\\\n      <span>\\\n        <strong>强制执行</strong>:\\\n        <span class=\"style-rule-tag\" v-html=\"humanType\"/>\\\n      </span>\\\n    ',\n    props: {\n      type: {\n        type: String,\n        required: true,\n        validate: function (value) {\n          Object.keys(enforcementTypes).indexOf(value) !== -1\n        }\n      }\n    },\n    computed: {\n      humanType: function () {\n        return enforcementTypes[this.type]\n      }\n    }\n  })\n\n  // new Vue({\n  //  el: '#main'\n  // })\n})()\n</script>\n\n","site":{"data":{}},"excerpt":"","more":"<p>这里是官方的 Vue 特有代码的风格指南。如果在工程中使用 Vue，为了回避错误、小纠结和反模式，该指南是份不错的参考。不过我们也不确信风格指南的所有内容对于所有的团队或工程都是理想的。所以根据过去的经验、周围的技术栈、个人价值观做出有意义的偏差是可取的。</p>\n<p>对于其绝大部分，我们也总体上避免就 JavaScript 或 HTML 的本身提出建议。我们不介意你是否使用分号或结尾的逗号。我们不介意你在 HTML attribute 中使用单引号还是双引号。不过当我们发现在 Vue 的情景下有帮助的特定模式时，也会存在例外。</p>\n<blockquote>\n<p><strong>不久之后，我们还会提供操作层面的技巧。</strong>有的时候你只需要遵守规则，而我们会尽可能向你展示如何使用 ESLint 及其它自动化程序把操作层面弄得更简单。</p>\n</blockquote>\n<p>最终，我们把所有的规则归为了四个大类：</p>\n<h2 id=\"规则归类\"><a href=\"#规则归类\" class=\"headerlink\" title=\"规则归类\"></a>规则归类</h2><h3 id=\"优先级-A：必要的\"><a href=\"#优先级-A：必要的\" class=\"headerlink\" title=\"优先级 A：必要的\"></a>优先级 A：必要的</h3><p>这些规则会帮你规避错误，所以学习并接受它们带来的全部代价吧。这里面可能存在例外，但应该非常少，且只有你同时精通 JavaScript 和 Vue 才可以这样做。</p>\n<h3 id=\"优先级-B：强烈推荐\"><a href=\"#优先级-B：强烈推荐\" class=\"headerlink\" title=\"优先级 B：强烈推荐\"></a>优先级 B：强烈推荐</h3><p>这些规则能够在绝大多数工程中改善可读性和开发体验。即使你违反了，代码还是能照常运行，但例外应该尽可能少且有合理的理由。</p>\n<h3 id=\"优先级-C：推荐\"><a href=\"#优先级-C：推荐\" class=\"headerlink\" title=\"优先级 C：推荐\"></a>优先级 C：推荐</h3><p>当存在多个同样好的选项，选任意一个都可以确保一致性。在这些规则里，我们描述了每个选项并建议一个默认的选择。也就是说只要保持一致且理由充分，你可以随意在你的代码库中做出不同的选择。请务必给出一个好的理由！通过接受社区的标准，你将会：</p>\n<ol>\n<li>训练你的大脑，以便更容易的处理你在社区遇到的代码；</li>\n<li>不做修改就可以直接复制粘贴社区的代码示例；</li>\n<li>能够经常招聘到和你编码习惯相同的新人，至少跟 Vue 相关的东西是这样的。</li>\n</ol>\n<h3 id=\"优先级-D：谨慎使用\"><a href=\"#优先级-D：谨慎使用\" class=\"headerlink\" title=\"优先级 D：谨慎使用\"></a>优先级 D：谨慎使用</h3><p>有些 Vue 特性的存在是为了照顾极端情况或帮助老代码的平稳迁移。当被过度使用时，这些特性会让你的代码难于维护甚至变成 bug 的来源。这些规则是为了给有潜在风险的特性敲个警钟，并说明它们什么时候不应该使用以及为什么。</p>\n<h2 id=\"优先级-A-的规则：必要的-规避错误\"><a href=\"#优先级-A-的规则：必要的-规避错误\" class=\"headerlink\" title=\"优先级 A 的规则：必要的 (规避错误)\"></a>优先级 A 的规则：必要的 (规避错误)</h2><h3 id=\"组件名为多个单词必要\"><a href=\"#组件名为多个单词必要\" class=\"headerlink\" title=\"组件名为多个单词必要\"></a>组件名为多个单词<sup data-p=\"a\">必要</sup></h3><p><strong>组件名应该始终是多个单词的，根组件 <code>App</code> 以及 <code>&lt;transition&gt;</code>、<code>&lt;component&gt;</code> 之类的 Vue 内置组件除外。</strong></p>\n<p>这样做可以避免跟现有的以及未来的 HTML 元素<a href=\"http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name\" target=\"_blank\" rel=\"noopener\">相冲突</a>，因为所有的 HTML 元素名称都是单个单词的。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例\"><a href=\"#反例\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'todo'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Todo'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子\"><a href=\"#好例子\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'todo-item'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'TodoItem'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<h3 id=\"组件数据必要\"><a href=\"#组件数据必要\" class=\"headerlink\" title=\"组件数据必要\"></a>组件数据<sup data-p=\"a\">必要</sup></h3><p><strong>组件的 <code>data</code> 必须是一个函数。</strong></p>\n<p>当在组件中使用 <code>data</code> property 的时候 (除了 <code>new Vue</code> 外的任何地方)，它的值必须是返回一个对象的函数。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>当 <code>data</code> 的值是一个对象时，它会在这个组件的所有实例之间共享。想象一下，假如一个 <code>TodoList</code> 组件的数据是这样的：</p>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">listTitle</span>: <span class=\"hljs-string\">''</span>,\n  <span class=\"hljs-attr\">todos</span>: []\n&#125;</code></pre>\n<p>我们可能希望重用这个组件，允许用户维护多个列表 (比如分为购物、心愿单、日常事务等)。这时就会产生问题。因为每个组件的实例都引用了相同的数据对象，更改其中一个列表的标题就会改变其它每一个列表的标题。增删改一个待办事项的时候也是如此。</p>\n<p>取而代之的是，我们希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了：</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">listTitle</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">todos</span>: []\n  &#125;\n&#125;</code></pre>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-1\"><a href=\"#反例-1\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'some-comp'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-1\"><a href=\"#好例子-1\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'some-comp'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// In a .vue file</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 在一个 Vue 的根实例上直接使用对象是可以的，</span>\n<span class=\"hljs-comment\">// 因为只存在一个这样的实例。</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;)</code></pre>\n</div>\n<h3 id=\"Prop-定义必要\"><a href=\"#Prop-定义必要\" class=\"headerlink\" title=\"Prop 定义必要\"></a>Prop 定义<sup data-p=\"a\">必要</sup></h3><p><strong>Prop 定义应该尽量详细。</strong></p>\n<p>在你提交的代码中，prop 的定义应该尽量详细，至少需要指定其类型。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>细致的 <a href=\"../guide/components-props.html#Prop-验证\">prop 定义</a>有两个好处：</p>\n<ul>\n<li>它们写明了组件的 API，所以很容易看懂组件的用法；</li>\n<li>在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-2\"><a href=\"#反例-2\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 这样做只有开发原型系统时可以接受</span>\n<span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'status'</span>]</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-2\"><a href=\"#好例子-2\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">status</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 更好的做法！</span>\n<span class=\"hljs-attr\">props</span>: &#123;\n  <span class=\"hljs-attr\">status</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> [\n        <span class=\"hljs-string\">'syncing'</span>,\n        <span class=\"hljs-string\">'synced'</span>,\n        <span class=\"hljs-string\">'version-conflict'</span>,\n        <span class=\"hljs-string\">'error'</span>\n      ].indexOf(value) !== <span class=\"hljs-number\">-1</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"为-v-for-设置键值必要\"><a href=\"#为-v-for-设置键值必要\" class=\"headerlink\" title=\"为 v-for 设置键值必要\"></a>为 <code>v-for</code> 设置键值<sup data-p=\"a\">必要</sup></h3><p><strong>总是用 <code>key</code> 配合 <code>v-for</code>。</strong></p>\n<p>在组件上<em>总是</em>必须用 <code>key</code> 配合 <code>v-for</code>，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的<a href=\"https://bost.ocks.org/mike/constancy/\" target=\"_blank\" rel=\"noopener\">对象固化 (object constancy)</a>，也是一种好的做法。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>假设你有一个待办事项列表：</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">todos</span>: [\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'学习使用 v-for'</span>\n      &#125;,\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>,\n        <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'学习使用 key'</span>\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n<p>然后你把它们按照字母顺序排序。在更新 DOM 的时候，Vue 将会优化渲染把可能的 DOM 变更降到最低。即可能删掉第一个待办事项元素，然后把它重新加回到列表的最末尾。</p>\n<p>这里的问题在于，不要删除仍然会留在 DOM 中的元素。比如你想使用 <code>&lt;transition-group&gt;</code> 给列表加过渡动画，或想在被渲染元素是 <code>&lt;input&gt;</code> 时保持聚焦。在这些情况下，为每一个项目添加一个唯一的键值 (比如 <code>:key=&quot;todo.id&quot;</code>) 将会让 Vue 知道如何使行为更容易预测。</p>\n<p>根据我们的经验，最好<em>始终</em>添加一个唯一的键值，以便你和你的团队永远不必担心这些极端情况。也在少数对性能有严格要求的情况下，为了避免对象固化，你可以刻意做一些非常规的处理。</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-3\"><a href=\"#反例-3\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-3\"><a href=\"#好例子-3\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"todo.id\"</span>\n  &gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"避免-v-if-和-v-for-用在一起必要\"><a href=\"#避免-v-if-和-v-for-用在一起必要\" class=\"headerlink\" title=\"避免 v-if 和 v-for 用在一起必要\"></a>避免 <code>v-if</code> 和 <code>v-for</code> 用在一起<sup data-p=\"a\">必要</sup></h3><p><strong>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上。</strong></p>\n<p>一般我们在两种常见的情况下会倾向于这样做：</p>\n<ul>\n<li><p>为了过滤一个列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。在这种情形下，请将 <code>users</code> 替换为一个计算属性 (比如 <code>activeUsers</code>)，让其返回过滤后的列表。</p>\n</li>\n<li><p>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。这种情形下，请将 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>、<code>ol</code>)。</p>\n</li>\n</ul>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>当 Vue 处理指令时，<code>v-for</code> 比 <code>v-if</code> 具有更高的优先级，所以这个模板：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"user.isActive\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>将会经过如下运算：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.users.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">user</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (user.isActive) &#123;\n    <span class=\"hljs-keyword\">return</span> user.name\n  &#125;\n&#125;)</code></pre>\n<p>因此哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。</p>\n<p>通过将其更换为在如下的一个计算属性上遍历：</p>\n<pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">activeUsers</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.users.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">user</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> user.isActive\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in activeUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>我们将会获得如下好处：</p>\n<ul>\n<li>过滤后的列表<em>只</em>会在 <code>users</code> 数组发生相关变化时才被重新运算，过滤更高效。</li>\n<li>使用 <code>v-for=&quot;user in activeUsers&quot;</code> 之后，我们在渲染的时候<em>只</em>遍历活跃用户，渲染更高效。</li>\n<li>解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。</li>\n</ul>\n<p>为了获得同样的好处，我们也可以把：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>更新为：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>通过将 <code>v-if</code> 移动到容器元素，我们不会再对列表中的<em>每个</em>用户检查 <code>shouldShowUsers</code>。取而代之的是，我们只检查它一次，且不会在 <code>shouldShowUsers</code> 为否的时候运算 <code>v-for</code>。</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-4\"><a href=\"#反例-4\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"user.isActive\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-4\"><a href=\"#好例子-4\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in activeUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"为组件样式设置作用域必要\"><a href=\"#为组件样式设置作用域必要\" class=\"headerlink\" title=\"为组件样式设置作用域必要\"></a>为组件样式设置作用域<sup data-p=\"a\">必要</sup></h3><p><strong>对于应用来说，顶级 <code>App</code> 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的。</strong></p>\n<p>这条规则只和<a href=\"../guide/single-file-components.html\">单文件组件</a>有关。你<em>不一定</em>要使用 <a href=\"https://vue-loader.vuejs.org/zh-cn/features/scoped-css.html\" target=\"_blank\" rel=\"noopener\"><code>scoped</code> attribute</a>。设置作用域也可以通过 <a href=\"https://vue-loader.vuejs.org/zh-cn/features/css-modules.html\" target=\"_blank\" rel=\"noopener\">CSS Modules</a>，那是一个基于 class 的类似 <a href=\"http://getbem.com/\" target=\"_blank\" rel=\"noopener\">BEM</a> 的策略，当然你也可以使用其它的库或约定。</p>\n<p><strong>不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 <code>scoped</code> attribute。</strong></p>\n<p>这让覆写内部样式更容易：使用了常人可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>如果你和其他开发者一起开发一个大型工程，或有时引入三方 HTML/CSS (比如来自 Auth0)，设置一致的作用域会确保你的样式只会运用在它们想要作用的组件上。</p>\n<p>不止要使用 <code>scoped</code> attribute，使用唯一的 class 名可以帮你确保那些三方库的 CSS 不会运用在你自己的 HTML 上。比如许多工程都使用了 <code>button</code>、<code>btn</code> 或 <code>icon</code> class 名，所以即便你不使用类似 BEM 的策略，添加一个 app 专属或组件专属的前缀 (比如 <code>ButtonClose-icon</code>) 也可以提供很多保护。</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-5\"><a href=\"#反例-5\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.btn-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-5\"><a href=\"#好例子-5\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"button button-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 使用 `scoped` attribute --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.button-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[$style.button, $style.buttonClose]\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 使用 CSS Modules --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">module</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.buttonClose</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"c-Button c-Button--close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 使用 BEM 约定 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.c-Button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.c-Button--close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"私有-property-名必要\"><a href=\"#私有-property-名必要\" class=\"headerlink\" title=\"私有 property 名必要\"></a>私有 property 名<sup data-p=\"a\">必要</sup></h3><p><strong>使用模块作用域保持不允许外部访问的函数的私有性。如果无法做到这一点，就始终为插件、混入等不考虑作为对外公共 API 的自定义私有 property 使用 <code>$_</code> 前缀。并附带一个命名空间以回避和其它作者的冲突 (比如 <code>$_yourPluginName_</code>)。</strong></p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>Vue 使用 <code>_</code> 前缀来定义其自身的私有 property，所以使用相同的前缀 (比如 <code>_update</code>) 有覆写实例 property 的风险。即便你检查确认 Vue 当前版本没有用到这个 property 名，也不能保证和将来的版本没有冲突。</p>\n<p>对于 <code>$</code> 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例 property，所以把它用于<em>私有</em> property 并不合适。</p>\n<p>不过，我们推荐把这两个前缀结合为 <code>$_</code>，作为一个用户定义的私有 property 的约定，以确保不会和 Vue 自身相冲突。</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-6\"><a href=\"#反例-6\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-6\"><a href=\"#好例子-6\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$_myGreatMixin_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 甚至更好！</span>\n<span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    publicMethod() &#123;\n      <span class=\"hljs-comment\">// ...</span>\n      myPrivateFunction()\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myPrivateFunction</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> myGreatMixin</code></pre>\n</div>\n<h2 id=\"优先级-B-的规则：强烈推荐-增强可读性\"><a href=\"#优先级-B-的规则：强烈推荐-增强可读性\" class=\"headerlink\" title=\"优先级 B 的规则：强烈推荐 (增强可读性)\"></a>优先级 B 的规则：强烈推荐 (增强可读性)</h2><h3 id=\"组件文件强烈推荐\"><a href=\"#组件文件强烈推荐\" class=\"headerlink\" title=\"组件文件强烈推荐\"></a>组件文件<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>只要有能够拼接文件的构建系统，就把每个组件单独分成文件。</strong></p>\n<p>当你需要编辑一个组件或查阅一个组件的用法时，可以更快速的找到它。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-7\"><a href=\"#反例-7\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoList'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)\n\nVue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-7\"><a href=\"#好例子-7\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.js\n|- TodoItem.js</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoItem.vue</code></pre>\n</div>\n<h3 id=\"单文件组件文件的大小写强烈推荐\"><a href=\"#单文件组件文件的大小写强烈推荐\" class=\"headerlink\" title=\"单文件组件文件的大小写强烈推荐\"></a>单文件组件文件的大小写<sup data-p=\"b\">强烈推荐</sup></h3><p><strong><a href=\"../guide/single-file-components.html\">单文件组件</a>的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。</strong></p>\n<p>单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-8\"><a href=\"#反例-8\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- mycomponent.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- myComponent.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-8\"><a href=\"#好例子-8\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- MyComponent.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- my-component.vue</code></pre>\n</div>\n<h3 id=\"基础组件名强烈推荐\"><a href=\"#基础组件名强烈推荐\" class=\"headerlink\" title=\"基础组件名强烈推荐\"></a>基础组件名<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 <code>Base</code>、<code>App</code> 或 <code>V</code>。</strong></p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>这些组件为你的应用奠定了一致的基础样式和行为。它们可能<strong>只</strong>包括：</p>\n<ul>\n<li>HTML 元素</li>\n<li>其它基础组件</li>\n<li>第三方 UI 组件库</li>\n</ul>\n<p>但是它们<strong>绝不会</strong>包括全局状态 (比如来自 Vuex store)。</p>\n<p>它们的名字通常包含所包裹元素的名字 (比如 <code>BaseButton</code>、<code>BaseTable</code>)，除非没有现成的对应功能的元素 (比如 <code>BaseIcon</code>)。如果你为特定的上下文构建类似的组件，那它们几乎总会消费这些组件 (比如 <code>BaseButton</code> 可能会用在 <code>ButtonSubmit</code> 上)。</p>\n<p>这样做的几个好处：</p>\n<ul>\n<li><p>当你在编辑器中以字母顺序排序时，你的应用的基础组件会全部列在一起，这样更容易识别。</p>\n</li>\n<li><p>因为组件名应该始终是多个单词，所以这样做可以避免你在包裹简单组件时随意选择前缀 (比如 <code>MyButton</code>、<code>VueButton</code>)。</p>\n</li>\n<li><p>因为这些组件会被频繁使用，所以你可能想把它们放到全局而不是在各处分别导入它们。使用相同的前缀可以让 webpack 这样工作：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> requireComponent = <span class=\"hljs-built_in\">require</span>.context(<span class=\"hljs-string\">\"./src\"</span>, <span class=\"hljs-literal\">true</span>, /Base[A-Z]\\w+\\.(vue|js)$/)\nrequireComponent.keys().forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">fileName</span>) </span>&#123;\n  <span class=\"hljs-keyword\">var</span> baseComponentConfig = requireComponent(fileName)\n  baseComponentConfig = baseComponentConfig.default || baseComponentConfig\n  <span class=\"hljs-keyword\">var</span> baseComponentName = baseComponentConfig.name || (\n    fileName\n      .replace(<span class=\"hljs-regexp\">/^.+\\//</span>, <span class=\"hljs-string\">''</span>)\n      .replace(<span class=\"hljs-regexp\">/\\.\\w+$/</span>, <span class=\"hljs-string\">''</span>)\n  )\n  Vue.component(baseComponentName, baseComponentConfig)\n&#125;)</code></pre>\n</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-9\"><a href=\"#反例-9\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- MyButton.vue\n|- VueTable.vue\n|- Icon.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-9\"><a href=\"#好例子-9\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- AppButton.vue\n|- AppTable.vue\n|- AppIcon.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- VButton.vue\n|- VTable.vue\n|- VIcon.vue</code></pre>\n</div>\n<h3 id=\"单例组件名强烈推荐\"><a href=\"#单例组件名强烈推荐\" class=\"headerlink\" title=\"单例组件名强烈推荐\"></a>单例组件名<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>只应该拥有单个活跃实例的组件应该以 <code>The</code> 前缀命名，以示其唯一性。</strong></p>\n<p>这不意味着组件只可用于一个单页面，而是<em>每个页面</em>只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，<em>只是目前</em>在每个页面里只使用一次。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-10\"><a href=\"#反例-10\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- Heading.vue\n|- MySidebar.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-10\"><a href=\"#好例子-10\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- TheHeading.vue\n|- TheSidebar.vue</code></pre>\n</div>\n<h3 id=\"紧密耦合的组件名强烈推荐\"><a href=\"#紧密耦合的组件名强烈推荐\" class=\"headerlink\" title=\"紧密耦合的组件名强烈推荐\"></a>紧密耦合的组件名<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>和父组件紧密耦合的子组件应该以父组件名作为前缀命名。</strong></p>\n<p>如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>你可以试着通过在其父组件命名的目录中嵌套子组件以解决这个问题。比如：</p>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList/\n   |- Item/\n      |- index.vue\n      |- Button.vue\n   |- index.vue</code></pre>\n<p>或：</p>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList/\n   |- Item/\n      |- Button.vue\n   |- Item.vue\n|- TodoList.vue</code></pre>\n<p>但是这种方式并不推荐，因为这会导致：</p>\n<ul>\n<li>许多文件的名字相同，使得在编辑器中快速切换文件变得困难。</li>\n<li>过多嵌套的子目录增加了在编辑器侧边栏中浏览组件所花的时间。</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-11\"><a href=\"#反例-11\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoItem.vue\n|- TodoButton.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- SearchSidebar.vue\n|- NavigationForSearchSidebar.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-11\"><a href=\"#好例子-11\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemButton.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- SearchSidebar.vue\n|- SearchSidebarNavigation.vue</code></pre>\n</div>\n<h3 id=\"组件名中的单词顺序强烈推荐\"><a href=\"#组件名中的单词顺序强烈推荐\" class=\"headerlink\" title=\"组件名中的单词顺序强烈推荐\"></a>组件名中的单词顺序<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</strong></p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>你可能会疑惑：</p>\n<blockquote>\n<p>“为什么我们给组件命名时不多遵从自然语言呢？”</p>\n</blockquote>\n<p>在自然的英文里，形容词和其它描述语通常都出现在名词之前，否则需要使用连接词。比如：</p>\n<ul>\n<li>Coffee <em>with</em> milk</li>\n<li>Soup <em>of the</em> day</li>\n<li>Visitor <em>to the</em> museum</li>\n</ul>\n<p>如果你愿意，你完全可以在组件名里包含这些连接词，但是单词的顺序很重要。</p>\n<p>同样要注意<strong>在你的应用中所谓的“高级别”是跟语境有关的</strong>。比如对于一个带搜索表单的应用来说，它可能包含这样的组件：</p>\n<pre><code class=\"hljs undefined\">components/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue</code></pre>\n<p>你可能注意到了，我们很难看出来哪些组件是针对搜索的。现在我们来根据规则给组件重新命名：</p>\n<pre><code class=\"hljs undefined\">components/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputExcludeGlob.vue\n|- SearchInputQuery.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n|- SettingsCheckboxTerms.vue</code></pre>\n<p>因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。</p>\n<p>你可能想换成多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为：</p>\n<ul>\n<li>在多级目录间找来找去，要比在单个 <code>components</code> 目录下滚动查找要花费更多的精力。</li>\n<li>存在组件重名 (比如存在多个 <code>ButtonDelete</code> 组件) 的时候在编辑器里更难快速定位。</li>\n<li>让重构变得更难，因为为一个移动了的组件更新相关引用时，查找/替换通常并不高效。</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-12\"><a href=\"#反例-12\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-12\"><a href=\"#好例子-12\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputQuery.vue\n|- SearchInputExcludeGlob.vue\n|- SettingsCheckboxTerms.vue\n|- SettingsCheckboxLaunchOnStartup.vue</code></pre>\n</div>\n<h3 id=\"自闭合组件强烈推荐\"><a href=\"#自闭合组件强烈推荐\" class=\"headerlink\" title=\"自闭合组件强烈推荐\"></a>自闭合组件<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>在<a href=\"../guide/single-file-components.html\">单文件组件</a>、字符串模板和 <a href=\"../guide/render-function.html#JSX\">JSX</a> 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。</strong></p>\n<p>自闭合组件表示它们不仅没有内容，而且<strong>刻意</strong>没有内容。其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸。而且没有了额外的闭合标签，你的代码也更简洁。</p>\n<p>不幸的是，HTML 并不支持自闭合的自定义元素——只有<a href=\"https://www.w3.org/TR/html/syntax.html#void-elements\" target=\"_blank\" rel=\"noopener\">官方的“空”元素</a>。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-13\"><a href=\"#反例-13\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MyComponent</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在 DOM 模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-13\"><a href=\"#好例子-13\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在 DOM 模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"模板中的组件名大小写强烈推荐\"><a href=\"#模板中的组件名大小写强烈推荐\" class=\"headerlink\" title=\"模板中的组件名大小写强烈推荐\"></a>模板中的组件名大小写<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>对于绝大多数项目来说，在<a href=\"../guide/single-file-components.html\">单文件组件</a>和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。</strong></p>\n<p>PascalCase 相比 kebab-case 有一些优势：</p>\n<ul>\n<li>编辑器可以在模板里自动补全组件名，因为 PascalCase 同样适用于 JavaScript。</li>\n<li><code>&lt;MyComponent&gt;</code> 视觉上比 <code>&lt;my-component&gt;</code> 更能够和单个单词的 HTML 元素区别开来，因为前者的不同之处有两个大写字母，后者只有一个横线。</li>\n<li>如果你在模板中使用任何非 Vue 的自定义元素，比如一个 Web Component，PascalCase 确保了你的 Vue 组件在视觉上仍然是易识别的。</li>\n</ul>\n<p>不幸的是，由于 HTML 是大小写不敏感的，在 DOM 模板中必须仍使用 kebab-case。</p>\n<p>还请注意，如果你已经是 kebab-case 的重度用户，那么与 HTML 保持一致的命名约定且在多个项目中保持相同的大小写规则就可能比上述优势更为重要了。在这些情况下，<strong>在所有的地方都使用 kebab-case 同样是可以接受的。</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-14\"><a href=\"#反例-14\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mycomponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">myComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在 DOM 模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MyComponent</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-14\"><a href=\"#好例子-14\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在 DOM 模板中 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>或者</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在所有地方 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"JS-JSX-中的组件名大小写强烈推荐\"><a href=\"#JS-JSX-中的组件名大小写强烈推荐\" class=\"headerlink\" title=\"JS/JSX 中的组件名大小写强烈推荐\"></a>JS/JSX 中的组件名大小写<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>JS/<a href=\"../guide/render-function.html#JSX\">JSX</a> 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 <code>Vue.component</code> 进行全局组件注册时，可以使用 kebab-case 字符串。</strong></p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>在 JavaScript 中，PascalCase 是类和构造函数 (本质上任何可以产生多份不同实例的东西) 的命名约定。Vue 组件也有多份实例，所以同样使用 PascalCase 是有意义的。额外的好处是，在 JSX (和模板) 里使用 PascalCase 使得代码的读者更容易分辨 Vue 组件和 HTML 元素。</p>\n<p>然而，对于<strong>只</strong>通过 <code>Vue.component</code> 定义全局组件的应用来说，我们推荐 kebab-case 作为替代。原因是：</p>\n<ul>\n<li>全局组件很少被 JavaScript 引用，所以遵守 JavaScript 的命名约定意义不大。</li>\n<li>这些应用往往包含许多 DOM 内的模板，这种情况下是<a href=\"#模板中的组件名大小写-强烈推荐\"><strong>必须</strong>使用 kebab-case</a> 的。</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-15\"><a href=\"#反例-15\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'myComponent'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> myComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./MyComponent.vue'</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'myComponent'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'my-component'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-15\"><a href=\"#好例子-15\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'MyComponent'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> MyComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./MyComponent.vue'</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'MyComponent'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<h3 id=\"完整单词的组件名强烈推荐\"><a href=\"#完整单词的组件名强烈推荐\" class=\"headerlink\" title=\"完整单词的组件名强烈推荐\"></a>完整单词的组件名<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>组件名应该倾向于完整单词而不是缩写。</strong></p>\n<p>编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-16\"><a href=\"#反例-16\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs undefined\">components/\n|- SdSettings.vue\n|- UProfOpts.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-16\"><a href=\"#好例子-16\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs undefined\">components/\n|- StudentDashboardSettings.vue\n|- UserProfileOptions.vue</code></pre>\n</div>\n<h3 id=\"Prop-名大小写强烈推荐\"><a href=\"#Prop-名大小写强烈推荐\" class=\"headerlink\" title=\"Prop 名大小写强烈推荐\"></a>Prop 名大小写<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 <a href=\"../guide/render-function.html#JSX\">JSX</a> 中应该始终使用 kebab-case。</strong></p>\n<p>我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-17\"><a href=\"#反例-17\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-string\">'greeting-text'</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WelcomeMessage</span> <span class=\"hljs-attr\">greetingText</span>=<span class=\"hljs-string\">\"hi\"</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-17\"><a href=\"#好例子-17\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">greetingText</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WelcomeMessage</span> <span class=\"hljs-attr\">greeting-text</span>=<span class=\"hljs-string\">\"hi\"</span>/&gt;</span></code></pre>\n</div>\n<h3 id=\"多个-attribute-的元素强烈推荐\"><a href=\"#多个-attribute-的元素强烈推荐\" class=\"headerlink\" title=\"多个 attribute 的元素强烈推荐\"></a>多个 attribute 的元素<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</strong></p>\n<p>在 JavaScript 中，用多行分隔对象的多个 property 是很常见的最佳实践，因为这样更易读。模板和 <a href=\"../guide/render-function.html#JSX\">JSX</a> 值得我们做相同的考虑。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-18\"><a href=\"#反例-18\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://vuejs.org/images/logo.png\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"Vue Logo\"</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span> <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">\"a\"</span> <span class=\"hljs-attr\">bar</span>=<span class=\"hljs-string\">\"b\"</span> <span class=\"hljs-attr\">baz</span>=<span class=\"hljs-string\">\"c\"</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-18\"><a href=\"#好例子-18\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span>\n  <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://vuejs.org/images/logo.png\"</span>\n  <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"Vue Logo\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>\n  <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">\"a\"</span>\n  <span class=\"hljs-attr\">bar</span>=<span class=\"hljs-string\">\"b\"</span>\n  <span class=\"hljs-attr\">baz</span>=<span class=\"hljs-string\">\"c\"</span>\n/&gt;</span></code></pre>\n</div>\n<h3 id=\"模板中简单的表达式强烈推荐\"><a href=\"#模板中简单的表达式强烈推荐\" class=\"headerlink\" title=\"模板中简单的表达式强烈推荐\"></a>模板中简单的表达式<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</strong></p>\n<p>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的<em>是什么</em>，而非<em>如何</em>计算那个值。而且计算属性和方法使得代码可以重用。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-19\"><a href=\"#反例-19\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\">&#123;&#123;\n  fullName.split(' ').map(function (word) &#123;\n    return word[0].toUpperCase() + word.slice(1)\n  &#125;).join(' ')\n&#125;&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-19\"><a href=\"#好例子-19\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 在模板中 --&gt;</span>\n&#123;&#123; normalizedFullName &#125;&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 复杂表达式已经移入一个计算属性</span>\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">normalizedFullName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.fullName.split(<span class=\"hljs-string\">' '</span>).map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">word</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> word[<span class=\"hljs-number\">0</span>].toUpperCase() + word.slice(<span class=\"hljs-number\">1</span>)\n    &#125;).join(<span class=\"hljs-string\">' '</span>)\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"简单的计算属性强烈推荐\"><a href=\"#简单的计算属性强烈推荐\" class=\"headerlink\" title=\"简单的计算属性强烈推荐\"></a>简单的计算属性<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>应该把复杂计算属性分割为尽可能多的更简单的 property。</strong></p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>更简单、命名得当的计算属性是这样的：</p>\n<ul>\n<li><p><strong>易于测试</strong></p>\n<p>当每个计算属性都包含一个非常简单且很少依赖的表达式时，撰写测试以确保其正确工作就会更加容易。</p>\n</li>\n<li><p><strong>易于阅读</strong></p>\n<p>简化计算属性要求你为每一个值都起一个描述性的名称，即便它不可复用。这使得其他开发者 (以及未来的你) 更容易专注在他们关心的代码上并搞清楚发生了什么。</p>\n</li>\n<li><p><strong>更好的“拥抱变化”</strong></p>\n<p>任何能够命名的值都可能用在视图上。举个例子，我们可能打算展示一个信息，告诉用户他们存了多少钱；也可能打算计算税费，但是可能会分开展现，而不是作为总价的一部分。</p>\n<p>小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。</p>\n</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-20\"><a href=\"#反例-20\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">price</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> basePrice = <span class=\"hljs-keyword\">this</span>.manufactureCost / (<span class=\"hljs-number\">1</span> - <span class=\"hljs-keyword\">this</span>.profitMargin)\n    <span class=\"hljs-keyword\">return</span> (\n      basePrice -\n      basePrice * (<span class=\"hljs-keyword\">this</span>.discountPercent || <span class=\"hljs-number\">0</span>)\n    )\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-20\"><a href=\"#好例子-20\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">basePrice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.manufactureCost / (<span class=\"hljs-number\">1</span> - <span class=\"hljs-keyword\">this</span>.profitMargin)\n  &#125;,\n  <span class=\"hljs-attr\">discount</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.basePrice * (<span class=\"hljs-keyword\">this</span>.discountPercent || <span class=\"hljs-number\">0</span>)\n  &#125;,\n  <span class=\"hljs-attr\">finalPrice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.basePrice - <span class=\"hljs-keyword\">this</span>.discount\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"带引号的-attribute-值强烈推荐\"><a href=\"#带引号的-attribute-值强烈推荐\" class=\"headerlink\" title=\"带引号的 attribute 值强烈推荐\"></a>带引号的 attribute 值<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>非空 HTML attribute 值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。</strong></p>\n<p>在 HTML 中不带空格的 attribute 值是可以没有引号的，但这鼓励了大家在特征值里<em>不写</em>空格，导致可读性变差。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-21\"><a href=\"#反例-21\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">text</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppSidebar</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">&#123;width:sidebarWidth+</span>'<span class=\"hljs-attr\">px</span>'&#125;&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-21\"><a href=\"#好例子-21\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppSidebar</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"&#123; width: sidebarWidth + 'px' &#125;\"</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"指令缩写强烈推荐\"><a href=\"#指令缩写强烈推荐\" class=\"headerlink\" title=\"指令缩写强烈推荐\"></a>指令缩写<sup data-p=\"b\">强烈推荐</sup></h3><p><strong>指令缩写 (用 <code>:</code> 表示 <code>v-bind:</code>、用 <code>@</code> 表示 <code>v-on:</code> 和用 <code>#</code> 表示 <code>v-slot:</code>) 应该要么都用要么都不用。</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-22\"><a href=\"#反例-22\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  @<span class=\"hljs-attr\">focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-22\"><a href=\"#好例子-22\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">v-bind:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  @<span class=\"hljs-attr\">input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  @<span class=\"hljs-attr\">focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  <span class=\"hljs-attr\">v-on:focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n</div>\n<h2 id=\"优先级-C-的规则：推荐-将选择和认知成本最小化\"><a href=\"#优先级-C-的规则：推荐-将选择和认知成本最小化\" class=\"headerlink\" title=\"优先级 C 的规则：推荐 (将选择和认知成本最小化)\"></a>优先级 C 的规则：推荐 (将选择和认知成本最小化)</h2><h3 id=\"组件-实例的选项的顺序推荐\"><a href=\"#组件-实例的选项的顺序推荐\" class=\"headerlink\" title=\"组件/实例的选项的顺序推荐\"></a>组件/实例的选项的顺序<sup data-p=\"c\">推荐</sup></h3><p><strong>组件/实例的选项应该有统一的顺序。</strong></p>\n<p>这是我们推荐的组件选项默认顺序。它们被划分为几大类，所以你也能知道从插件里添加的新 property 应该放到哪里。</p>\n<ol>\n<li><p><strong>副作用</strong> (触发组件外的影响)</p>\n<ul>\n<li><code>el</code></li>\n</ul>\n</li>\n<li><p><strong>全局感知</strong> (要求组件以外的知识)</p>\n<ul>\n<li><code>name</code></li>\n<li><code>parent</code></li>\n</ul>\n</li>\n<li><p><strong>组件类型</strong> (更改组件的类型)</p>\n<ul>\n<li><code>functional</code></li>\n</ul>\n</li>\n<li><p><strong>模板修改器</strong> (改变模板的编译方式)</p>\n<ul>\n<li><code>delimiters</code></li>\n<li><code>comments</code></li>\n</ul>\n</li>\n<li><p><strong>模板依赖</strong> (模板内使用的资源)</p>\n<ul>\n<li><code>components</code></li>\n<li><code>directives</code></li>\n<li><code>filters</code></li>\n</ul>\n</li>\n<li><p><strong>组合</strong> (向选项里合并 property)</p>\n<ul>\n<li><code>extends</code></li>\n<li><code>mixins</code></li>\n</ul>\n</li>\n<li><p><strong>接口</strong> (组件的接口)</p>\n<ul>\n<li><code>inheritAttrs</code></li>\n<li><code>model</code></li>\n<li><code>props</code>/<code>propsData</code></li>\n</ul>\n</li>\n<li><p><strong>本地状态</strong> (本地的响应式 property)</p>\n<ul>\n<li><code>data</code></li>\n<li><code>computed</code></li>\n</ul>\n</li>\n<li><p><strong>事件</strong> (通过响应式事件触发的回调)</p>\n<ul>\n<li><code>watch</code></li>\n<li>生命周期钩子 (按照它们被调用的顺序)<ul>\n<li><code>beforeCreate</code></li>\n<li><code>created</code></li>\n<li><code>beforeMount</code></li>\n<li><code>mounted</code></li>\n<li><code>beforeUpdate</code></li>\n<li><code>updated</code></li>\n<li><code>activated</code></li>\n<li><code>deactivated</code></li>\n<li><code>beforeDestroy</code></li>\n<li><code>destroyed</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>非响应式的 property</strong> (不依赖响应系统的实例 property)</p>\n<ul>\n<li><code>methods</code></li>\n</ul>\n</li>\n<li><p><strong>渲染</strong> (组件输出的声明式描述)</p>\n<ul>\n<li><code>template</code>/<code>render</code></li>\n<li><code>renderError</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"元素-attribute-的顺序推荐\"><a href=\"#元素-attribute-的顺序推荐\" class=\"headerlink\" title=\"元素 attribute 的顺序推荐\"></a>元素 attribute 的顺序<sup data-p=\"c\">推荐</sup></h3><p><strong>元素 (包括组件) 的 attribute 应该有统一的顺序。</strong></p>\n<p>这是我们为组件选项推荐的默认顺序。它们被划分为几大类，所以你也能知道新添加的自定义 attribute 和指令应该放到哪里。</p>\n<ol>\n<li><p><strong>定义</strong> (提供组件的选项)</p>\n<ul>\n<li><code>is</code></li>\n</ul>\n</li>\n<li><p><strong>列表渲染</strong> (创建多个变化的相同元素)</p>\n<ul>\n<li><code>v-for</code></li>\n</ul>\n</li>\n<li><p><strong>条件渲染</strong> (元素是否渲染/显示)</p>\n<ul>\n<li><code>v-if</code></li>\n<li><code>v-else-if</code></li>\n<li><code>v-else</code></li>\n<li><code>v-show</code></li>\n<li><code>v-cloak</code></li>\n</ul>\n</li>\n<li><p><strong>渲染方式</strong> (改变元素的渲染方式)</p>\n<ul>\n<li><code>v-pre</code></li>\n<li><code>v-once</code></li>\n</ul>\n</li>\n<li><p><strong>全局感知</strong> (需要超越组件的知识)</p>\n<ul>\n<li><code>id</code></li>\n</ul>\n</li>\n<li><p><strong>唯一的 attribute</strong> (需要唯一值的 attribute)</p>\n<ul>\n<li><code>ref</code></li>\n<li><code>key</code></li>\n</ul>\n</li>\n<li><p><strong>双向绑定</strong> (把绑定和事件结合起来)</p>\n<ul>\n<li><code>v-model</code></li>\n</ul>\n</li>\n<li><p><strong>其它 attribute</strong> (所有普通的绑定或未绑定的 attribute)</p>\n</li>\n<li><p><strong>事件</strong> (组件事件监听器)</p>\n<ul>\n<li><code>v-on</code></li>\n</ul>\n</li>\n<li><p><strong>内容</strong> (覆写元素的内容)</p>\n<ul>\n<li><code>v-html</code></li>\n<li><code>v-text</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"组件-实例选项中的空行推荐\"><a href=\"#组件-实例选项中的空行推荐\" class=\"headerlink\" title=\"组件/实例选项中的空行推荐\"></a>组件/实例选项中的空行<sup data-p=\"c\">推荐</sup></h3><p><strong>你可能想在多个 property 之间增加一个空行，特别是在这些选项一屏放不下，需要滚动才能都看到的时候。</strong></p>\n<p>当你的组件开始觉得密集或难以阅读时，在多个 property 之间添加空行可以让其变得容易。在一些诸如 Vim 的编辑器里，这样格式化后的选项还能通过键盘被快速导航。</p>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-23\"><a href=\"#好例子-23\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">value</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">focused</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Boolean</span>,\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-literal\">false</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">label</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">icon</span>: <span class=\"hljs-built_in\">String</span>\n&#125;,\n\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">formattedValue</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">inputClasses</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 没有空行在组件易于阅读和导航时也没问题。</span>\n<span class=\"hljs-attr\">props</span>: &#123;\n  <span class=\"hljs-attr\">value</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n  &#125;,\n  <span class=\"hljs-attr\">focused</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Boolean</span>,\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-literal\">false</span>\n  &#125;,\n  <span class=\"hljs-attr\">label</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">icon</span>: <span class=\"hljs-built_in\">String</span>\n&#125;,\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">formattedValue</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;,\n  <span class=\"hljs-attr\">inputClasses</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"单文件组件的顶级元素的顺序推荐\"><a href=\"#单文件组件的顶级元素的顺序推荐\" class=\"headerlink\" title=\"单文件组件的顶级元素的顺序推荐\"></a>单文件组件的顶级元素的顺序<sup data-p=\"c\">推荐</sup></h3><p><strong><a href=\"../guide/single-file-components.html\">单文件组件</a>应该总是让 <code>&lt;script&gt;</code>、<code>&lt;template&gt;</code> 和 <code>&lt;style&gt;</code> 标签的顺序保持一致。且 <code>&lt;style&gt;</code> 要放在最后，因为另外两个标签至少要有一个。</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-23\"><a href=\"#反例-23\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-24\"><a href=\"#好例子-24\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h2 id=\"优先级-D-的规则：谨慎使用-有潜在危险的模式\"><a href=\"#优先级-D-的规则：谨慎使用-有潜在危险的模式\" class=\"headerlink\" title=\"优先级 D 的规则：谨慎使用 (有潜在危险的模式)\"></a>优先级 D 的规则：谨慎使用 (有潜在危险的模式)</h2><h3 id=\"没有在-v-if-v-else-if-v-else-中使用-key-谨慎使用\"><a href=\"#没有在-v-if-v-else-if-v-else-中使用-key-谨慎使用\" class=\"headerlink\" title=\"没有在 v-if/v-else-if/v-else 中使用 key 谨慎使用\"></a>没有在 <code>v-if</code>/<code>v-else-if</code>/<code>v-else</code> 中使用 <code>key</code> <sup data-p=\"d\">谨慎使用</sup></h3><p><strong>如果一组 <code>v-if</code> + <code>v-else</code> 的元素类型相同，最好使用 <code>key</code> (比如两个 <code>&lt;div&gt;</code> 元素)。</strong></p>\n<p>默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现<a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-priority-d-rules-unintended-consequences\" target=\"_blank\" rel=\"noopener\">意料之外的结果</a>。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-24\"><a href=\"#反例-24\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>&gt;</span>\n  错误：&#123;&#123; error &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  &#123;&#123; results &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-25\"><a href=\"#好例子-25\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n  <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>\n  <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"search-status\"</span>\n&gt;</span>\n  错误：&#123;&#123; error &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n  <span class=\"hljs-attr\">v-else</span>\n  <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"search-results\"</span>\n&gt;</span>\n  &#123;&#123; results &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"scoped-中的元素选择器谨慎使用\"><a href=\"#scoped-中的元素选择器谨慎使用\" class=\"headerlink\" title=\"scoped 中的元素选择器谨慎使用\"></a><code>scoped</code> 中的元素选择器<sup data-p=\"d\">谨慎使用</sup></h3><p><strong>元素选择器应该避免在 <code>scoped</code> 中出现。</strong></p>\n<p>在 <code>scoped</code> 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。</p>\n\n<details>\n<summary>\n  <h4>详解</h4>\n</summary>\n\n<p>为了给样式设置作用域，Vue 会为元素添加一个独一无二的 attribute，例如 <code>data-v-f3f3eg9</code>。然后修改选择器，使得在匹配选择器的元素中，只有带这个 attribute 才会真正生效 (比如 <code>button[data-v-f3f3eg9]</code>)。</p>\n<p>问题在于大量的<a href=\"http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=a%5Bhref%5D&amp;body=background%3A+%23CFD&amp;ne=1000\" target=\"_blank\" rel=\"noopener\">元素和 attribute 组合的选择器</a> (比如 <code>button[data-v-f3f3eg9]</code>) 会比<a href=\"http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=.class%5Bhref%5D&amp;body=background%3A+%23CFD&amp;ne=1000\" target=\"_blank\" rel=\"noopener\">类和 attribute 组合的选择器</a>慢，所以应该尽可能选用类选择器。</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-25\"><a href=\"#反例-25\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-tag\">button</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-26\"><a href=\"#好例子-26\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.btn-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"隐性的父子组件通信谨慎使用\"><a href=\"#隐性的父子组件通信谨慎使用\" class=\"headerlink\" title=\"隐性的父子组件通信谨慎使用\"></a>隐性的父子组件通信<sup data-p=\"d\">谨慎使用</sup></h3><p><strong>应该优先通过 prop 和事件进行父子组件之间的通信，而不是 <code>this.$parent</code> 或变更 prop。</strong></p>\n<p>一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 <code>this.$parent</code> 能够简化两个深度耦合的组件。</p>\n<p>问题在于，这种做法在很多<em>简单</em>的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-26\"><a href=\"#反例-26\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;input v-model=\"todo.text\"&gt;'</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    removeTodo () &#123;\n      <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">this</span>\n      vm.$parent.todos = vm.$parent.todos.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> todo.id !== vm.todo.id\n      &#125;)\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;span&gt;\n      &#123;&#123; todo.text &#125;&#125;\n      &lt;button @click=\"removeTodo\"&gt;\n        X\n      &lt;/button&gt;\n    &lt;/span&gt;\n  `</span>\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-27\"><a href=\"#好例子-27\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;input\n      :value=\"todo.text\"\n      @input=\"$emit('input', $event.target.value)\"\n    &gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;span&gt;\n      &#123;&#123; todo.text &#125;&#125;\n      &lt;button @click=\"$emit('delete')\"&gt;\n        X\n      &lt;/button&gt;\n    &lt;/span&gt;\n  `</span>\n&#125;)</code></pre>\n</div>\n<h3 id=\"非-Flux-的全局状态管理谨慎使用\"><a href=\"#非-Flux-的全局状态管理谨慎使用\" class=\"headerlink\" title=\"非 Flux 的全局状态管理谨慎使用\"></a>非 Flux 的全局状态管理<sup data-p=\"d\">谨慎使用</sup></h3><p><strong>应该优先通过 <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a> 管理全局状态，而不是通过 <code>this.$root</code> 或一个全局事件总线。</strong></p>\n<p>通过 <code>this.$root</code> 和/或<a href=\"../guide/migration.html#dispatch-和-broadcast-替换\">全局事件总线</a>管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。</p>\n<p>Vuex 是 Vue 的<a href=\"../guide/state-management.html#类-Flux-状态管理的官方实现\">官方类 flux 实现</a>，其提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。它很好地集成在了 Vue 生态系统之中 (包括完整的 <a href=\"../guide/installation.html#Vue-Devtools\">Vue DevTools</a> 支持)。</p>\n\n<div class=\"style-example example-bad\">\n<h4 id=\"反例-27\"><a href=\"#反例-27\" class=\"headerlink\" title=\"反例\"></a>反例</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">todos</span>: []\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.$on(<span class=\"hljs-string\">'remove-todo'</span>, <span class=\"hljs-keyword\">this</span>.removeTodo)\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">removeTodo</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> todoIdToRemove = todo.id\n      <span class=\"hljs-keyword\">this</span>.todos = <span class=\"hljs-keyword\">this</span>.todos.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> todo.id !== todoIdToRemove\n      &#125;)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"好例子-28\"><a href=\"#好例子-28\" class=\"headerlink\" title=\"好例子\"></a>好例子</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// store/modules/todos.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">state</span>: &#123;\n    <span class=\"hljs-attr\">list</span>: []\n  &#125;,\n  <span class=\"hljs-attr\">mutations</span>: &#123;\n    REMOVE_TODO (state, todoId) &#123;\n      state.list = state.list.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">todo</span> =&gt;</span> todo.id !== todoId)\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">actions</span>: &#123;\n    removeTodo (&#123; commit, state &#125;, todo) &#123;\n      commit(<span class=\"hljs-string\">'REMOVE_TODO'</span>, todo.id)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- TodoItem.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"removeTodo(todo)\"</span>&gt;</span>\n      X\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> &#123; mapActions &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vuex'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: mapActions([<span class=\"hljs-string\">'removeTodo'</span>])\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n</div>\n\n<script>\n(function () {\n  var enforcementTypes = {\n    none: '<span title=\"这一规则无法强制执行\">自律</span>',\n    runtime: '运行时错误',\n    linter: '<a href=\"https://github.com/vuejs/eslint-plugin-vue#eslint-plugin-vue\" target=\"_blank\" rel=\"noopener noreferrer\">plugin:vue/recommended</a>'\n  }\n  Vue.component('sg-enforcement', {\n    template: '\\\n      <span>\\\n        <strong>强制执行</strong>:\\\n        <span class=\"style-rule-tag\" v-html=\"humanType\"/>\\\n      </span>\\\n    ',\n    props: {\n      type: {\n        type: String,\n        required: true,\n        validate: function (value) {\n          Object.keys(enforcementTypes).indexOf(value) !== -1\n        }\n      }\n    },\n    computed: {\n      humanType: function () {\n        return enforcementTypes[this.type]\n      }\n    }\n  })\n\n  // new Vue({\n  //  el: '#main'\n  // })\n})()\n</script>\n\n"},{"title":"API","type":"api","_content":"\n## 全局配置\n\n`Vue.config` 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property：\n\n### silent\n\n- **类型**：`boolean`\n\n- **默认值**：`false`\n\n- **用法**：\n\n  ``` js\n  Vue.config.silent = true\n  ```\n\n  取消 Vue 所有的日志与警告。\n\n### optionMergeStrategies\n\n- **类型**：`{ [key: string]: Function }`\n\n- **默认值**：`{}`\n\n- **用法**：\n\n  ``` js\n  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {\n    return child + 1\n  }\n\n  const Profile = Vue.extend({\n    _my_option: 1\n  })\n\n  // Profile.options._my_option = 2\n  ```\n\n  自定义合并策略的选项。\n\n  合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。\n\n- **参考**[自定义选项的混入策略](../guide/mixins.html#自定义选项混入策略)\n\n### devtools\n\n- **类型**：`boolean`\n\n- **默认值**：`true` (生产版为 `false`)\n\n- **用法**：\n\n  ``` js\n  // 务必在加载 Vue 之后，立即同步设置以下内容\n  Vue.config.devtools = true\n  ```\n\n  配置是否允许 [vue-devtools](https://github.com/vuejs/vue-devtools) 检查代码。开发版本默认为 `true`，生产版本默认为 `false`。生产版本设为 `true` 可以启用检查。\n\n### errorHandler\n\n- **类型**：`Function`\n\n- **默认值**：`undefined`\n\n- **用法**：\n\n  ``` js\n  Vue.config.errorHandler = function (err, vm, info) {\n    // handle error\n    // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子\n    // 只在 2.2.0+ 可用\n  }\n  ```\n\n  指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。\n\n  > 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 `undefined` 时，被捕获的错误会通过 `console.error` 输出而避免应用崩溃。\n\n  > 从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。\n\n  > 从 2.6.0 起，这个钩子也会捕获 `v-on` DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。\n\n  > 错误追踪服务 [Sentry](https://sentry.io) 和 [Bugsnag](https://docs.bugsnag.com/platforms/browsers/vue/) 都通过此选项提供了官方支持。\n\n### warnHandler\n\n> 2.4.0 新增\n\n- **类型**：`Function`\n\n- **默认值**：`undefined`\n\n- **用法**：\n\n  ``` js\n  Vue.config.warnHandler = function (msg, vm, trace) {\n    // `trace` 是组件的继承关系追踪\n  }\n  ```\n\n  为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。\n\n### ignoredElements\n\n- **类型**：`Array<string | RegExp>`\n\n- **默认值**：`[]`\n\n- **用法**：\n\n  ``` js\n  Vue.config.ignoredElements = [\n    'my-custom-web-component',\n    'another-web-component',\n    // 用一个 `RegExp` 忽略所有“ion-”开头的元素\n    // 仅在 2.5+ 支持\n    /^ion-/\n  ]\n  ```\n\n  须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 `Unknown custom element` 的警告。\n\n### keyCodes\n\n- **类型**：`{ [key: string]: number | Array<number> }`\n\n- **默认值**：`{}`\n\n- **用法**：\n\n  ``` js\n  Vue.config.keyCodes = {\n    v: 86,\n    f1: 112,\n    // camelCase 不可用\n    mediaPlayPause: 179,\n    // 取而代之的是 kebab-case 且用双引号括起来\n    \"media-play-pause\": 179,\n    up: [38, 87]\n  }\n  ```\n\n  ```html\n  <input type=\"text\" @keyup.media-play-pause=\"method\">\n  ```\n\n  给 `v-on` 自定义键位别名。\n\n### performance\n\n> 2.2.0 新增\n\n- **类型**：`boolean`\n\n- **默认值**：`false (自 2.2.3 起)`\n\n- **用法**：\n\n  设置为 `true` 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 [`performance.mark`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark) API 的浏览器上。\n  \n### productionTip\n\n> 2.2.0 新增\n\n- **类型**：`boolean`\n\n- **默认值**：`true`\n\n- **用法**：\n\n  设置为 `false` 以阻止 vue 在启动时生成生产提示。\n\n## 全局 API\n\n### Vue.extend( options )\n\n- **参数**：\n  - `{Object} options`\n\n- **用法**：\n\n  使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。\n\n  `data` 选项是特例，需要注意 - 在 `Vue.extend()` 中它必须是函数\n\n  ``` html\n  <div id=\"mount-point\"></div>\n  ```\n\n  ``` js\n  // 创建构造器\n  var Profile = Vue.extend({\n    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',\n    data: function () {\n      return {\n        firstName: 'Walter',\n        lastName: 'White',\n        alias: 'Heisenberg'\n      }\n    }\n  })\n  // 创建 Profile 实例，并挂载到一个元素上。\n  new Profile().$mount('#mount-point')\n  ```\n\n  结果如下：\n\n  ``` html\n  <p>Walter White aka Heisenberg</p>\n  ```\n\n- **参考**：[组件](../guide/components.html)\n\n### Vue.nextTick( [callback, context] )\n\n- **参数**：\n  - `{Function} [callback]`\n  - `{Object} [context]`\n\n- **用法**：\n\n  在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n\n  ``` js\n  // 修改数据\n  vm.msg = 'Hello'\n  // DOM 还没有更新\n  Vue.nextTick(function () {\n    // DOM 更新了\n  })\n\n  // 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)\n  Vue.nextTick()\n    .then(function () {\n      // DOM 更新了\n    })\n  ```\n\n  > 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。\n\n- **参考**：[异步更新队列](../guide/reactivity.html#异步更新队列)\n\n### Vue.set( target, propertyName/index, value )\n\n- **参数**：\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n  - `{any} value`\n\n- **返回值**：设置的值。\n\n- **用法**：\n\n  向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 `this.myObject.newProperty = 'hi'`)\n\n  <p class=\"tip\">注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</p>\n\n### Vue.delete( target, propertyName/index )\n\n- **参数**：\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n\n  > 仅在 2.2.0+ 版本中支持 Array + index 用法。\n\n- **用法**：\n\n  删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。\n\n  > 在 2.2.0+ 中同样支持在数组上工作。\n\n  <p class=\"tip\">目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。</p>\n\n- **参考**：[深入响应式原理](../guide/reactivity.html)\n\n### Vue.directive( id, [definition] )\n\n- **参数**：\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **用法**：\n\n  注册或获取全局指令。\n\n  ``` js\n  // 注册\n  Vue.directive('my-directive', {\n    bind: function () {},\n    inserted: function () {},\n    update: function () {},\n    componentUpdated: function () {},\n    unbind: function () {}\n  })\n\n  // 注册 (指令函数)\n  Vue.directive('my-directive', function () {\n    // 这里将会被 `bind` 和 `update` 调用\n  })\n\n  // getter，返回已注册的指令\n  var myDirective = Vue.directive('my-directive')\n  ```\n\n- **参考**：[自定义指令](../guide/custom-directive.html)\n\n### Vue.filter( id, [definition] )\n\n- **参数**：\n  - `{string} id`\n  - `{Function} [definition]`\n\n- **用法**：\n\n  注册或获取全局过滤器。\n\n  ``` js\n  // 注册\n  Vue.filter('my-filter', function (value) {\n    // 返回处理后的值\n  })\n\n  // getter，返回已注册的过滤器\n  var myFilter = Vue.filter('my-filter')\n  ```\n\n- **参考**：[过滤器](../guide/filters.html)\n\n### Vue.component( id, [definition] )\n\n- **参数**：\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **用法**：\n\n  注册或获取全局组件。注册还会自动使用给定的 `id` 设置组件的名称\n\n  ``` js\n  // 注册组件，传入一个扩展过的构造器\n  Vue.component('my-component', Vue.extend({ /* ... */ }))\n\n  // 注册组件，传入一个选项对象 (自动调用 Vue.extend)\n  Vue.component('my-component', { /* ... */ })\n\n  // 获取注册的组件 (始终返回构造器)\n  var MyComponent = Vue.component('my-component')\n  ```\n\n- **参考**：[组件](../guide/components.html)\n\n### Vue.use( plugin )\n\n- **参数**：\n  - `{Object | Function} plugin`\n\n- **用法**：\n\n  安装 Vue.js 插件。如果插件是一个对象，必须提供 `install` 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。\n\n  该方法需要在调用 `new Vue()` 之前被调用。\n\n  当 install 方法被同一个插件多次调用，插件将只会被安装一次。\n\n- **参考**：[插件](../guide/plugins.html)\n\n### Vue.mixin( mixin )\n\n- **参数**：\n  - `{Object} mixin`\n\n- **用法**：\n\n  全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。**不推荐在应用代码中使用**。\n\n- **参考**：[全局混入](../guide/mixins.html#全局混入)\n\n### Vue.compile( template )\n\n- **参数**：\n  - `{string} template`\n\n- **用法**：\n\n  将一个模板字符串编译成 render 函数。**只在完整版时可用**。\n\n  ``` js\n  var res = Vue.compile('<div><span>{{ msg }}</span></div>')\n\n  new Vue({\n    data: {\n      msg: 'hello'\n    },\n    render: res.render,\n    staticRenderFns: res.staticRenderFns\n  })\n  ```\n\n- **参考**：[渲染函数](../guide/render-function.html)\n\n### Vue.observable( object )\n\n> 2.6.0 新增\n\n- **参数**：\n  - `{Object} object`\n\n- **用法**：\n\n  让一个对象可响应。Vue 内部会用它来处理 `data` 函数返回的对象。\n\n  返回的对象可以直接用于[渲染函数](../guide/render-function.html)和[计算属性](../guide/computed.html)内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：\n\n  ``` js\n  const state = Vue.observable({ count: 0 })\n\n  const Demo = {\n    render(h) {\n      return h('button', {\n        on: { click: () => { state.count++ }}\n      }, `count is: ${state.count}`)\n    }\n  }\n  ```\n\n  <p class=\"tip\">在 Vue 2.x 中，被传入的对象会直接被 `Vue.observable` 变更，所以如[这里展示的](../guide/instance.html#数据与方法)，它和被返回的对象是同一个对象。在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的。因此，为了向前兼容，我们推荐始终操作使用 `Vue.observable` 返回的对象，而不是传入源对象。</p>\n\n- **参考**：[深入响应式原理](../guide/reactivity.html)\n\n### Vue.version\n\n- **细节**：提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。\n\n- **用法**：\n\n  ```js\n  var version = Number(Vue.version.split('.')[0])\n\n  if (version === 2) {\n    // Vue v2.x.x\n  } else if (version === 1) {\n    // Vue v1.x.x\n  } else {\n    // Unsupported versions of Vue\n  }\n  ```\n\n## 选项 / 数据\n\n### data\n\n- **类型**：`Object | Function`\n\n- **限制**：组件的定义只接受 `function`。\n\n- **详细**：\n\n  Vue 实例的数据对象。Vue 将会递归将 data 的 property 转换为 getter/setter，从而让 data 的 property 能够响应数据变化。**对象必须是纯粹的对象 (含有零个或多个的 key/value 对)**：浏览器 API 创建的原生对象，原型上的 property 会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。\n\n  一旦观察过，你就无法在根数据对象上添加响应式 property。因此推荐在创建实例之前，就声明所有的根级响应式 property。\n\n  实例创建之后，可以通过 `vm.$data` 访问原始数据对象。Vue 实例也代理了 data 对象上所有的 property，因此访问 `vm.a` 等价于访问 `vm.$data.a`。\n\n  以 `_` 或 `$` 开头的 property **不会**被 Vue 实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突。你可以使用例如 `vm.$data._property` 的方式访问这些 property。\n\n  当一个**组件**被定义，`data` 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 `data` 仍然是一个纯粹的对象，则所有的实例将**共享引用**同一个数据对象！通过提供 `data` 函数，每次创建一个新实例后，我们能够调用 `data` 函数，从而返回初始数据的一个全新副本数据对象。\n\n 如果需要，可以通过将 `vm.$data` 传入 `JSON.parse(JSON.stringify(...))` 得到深拷贝的原始数据对象。\n\n- **示例**：\n\n  ``` js\n  var data = { a: 1 }\n\n  // 直接创建一个实例\n  var vm = new Vue({\n    data: data\n  })\n  vm.a // => 1\n  vm.$data === data // => true\n\n  // Vue.extend() 中 data 必须是函数\n  var Component = Vue.extend({\n    data: function () {\n      return { a: 1 }\n    }\n  })\n  ```\n\n  注意，如果你为 `data` property 使用了箭头函数，则 `this` 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。\n\n  ```js\n  data: vm => ({ a: vm.myProp })\n  ```\n\n- **参考**：[深入响应式原理](../guide/reactivity.html)\n\n### props\n\n- **类型**：`Array<string> | Object`\n\n- **详细**：\n\n  props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。\n\n  你可以基于对象的语法使用以下选项：\n    - `type`：可以是下列原生构造函数中的一种：`String`、`Number`、`Boolean`、`Array`、`Object`、`Date`、`Function`、`Symbol`、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的[更多信息在此](../guide/components-props.html#Prop-类型)。\n    - `default`：`any`\n    为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。\n    - `required`：`Boolean`\n    定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。\n    - `validator`：`Function`\n    自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在[这里](../guide/components-props.html#Prop-验证)查阅更多 prop 验证的相关信息。\n\n- **示例**：\n\n  ``` js\n  // 简单语法\n  Vue.component('props-demo-simple', {\n    props: ['size', 'myMessage']\n  })\n\n  // 对象语法，提供验证\n  Vue.component('props-demo-advanced', {\n    props: {\n      // 检测类型\n      height: Number,\n      // 检测类型 + 其他验证\n      age: {\n        type: Number,\n        default: 0,\n        required: true,\n        validator: function (value) {\n          return value >= 0\n        }\n      }\n    }\n  })\n  ```\n\n- **参考**：[Props](../guide/components-props.html)\n\n### propsData\n\n- **类型**：`{ [key: string]: any }`\n\n- **限制**：只用于 `new` 创建的实例中。\n\n- **详细**：\n\n  创建实例时传递 props。主要作用是方便测试。\n\n- **示例**：\n\n  ``` js\n  var Comp = Vue.extend({\n    props: ['msg'],\n    template: '<div>{{ msg }}</div>'\n  })\n\n  var vm = new Comp({\n    propsData: {\n      msg: 'hello'\n    }\n  })\n  ```\n\n### computed\n\n- **类型**：`{ [key: string]: Function | { get: Function, set: Function } }`\n\n- **详细**：\n\n  计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。\n\n  注意如果你为一个计算属性使用了箭头函数，则 `this` 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。\n\n  ```js\n  computed: {\n    aDouble: vm => vm.a * 2\n  }\n  ```\n\n  计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是**不会**被更新的。\n\n- **示例**：\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    computed: {\n      // 仅读取\n      aDouble: function () {\n        return this.a * 2\n      },\n      // 读取和设置\n      aPlus: {\n        get: function () {\n          return this.a + 1\n        },\n        set: function (v) {\n          this.a = v - 1\n        }\n      }\n    }\n  })\n  vm.aPlus   // => 2\n  vm.aPlus = 3\n  vm.a       // => 2\n  vm.aDouble // => 4\n  ```\n\n- **参考**：[计算属性](../guide/computed.html)\n\n### methods\n\n- **类型**：`{ [key: string]: Function }`\n\n- **详细**：\n\n  methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 `this` 自动绑定为 Vue 实例。\n\n  <p class=\"tip\">注意，**不应该使用箭头函数来定义 method 函数** (例如 `plus: () => this.a++`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.a` 将是 undefined。</p>\n\n- **示例**：\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    methods: {\n      plus: function () {\n        this.a++\n      }\n    }\n  })\n  vm.plus()\n  vm.a // 2\n  ```\n\n- **参考**：[事件处理器](../guide/events.html)\n\n### watch\n\n- **类型**：`{ [key: string]: string | Function | Object | Array }`\n\n- **详细**：\n\n  一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 `$watch()`，遍历 watch 对象的每一个 property。\n\n- **示例**：\n\n  ``` js\n  var vm = new Vue({\n    data: {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: {\n        f: {\n          g: 5\n        }\n      }\n    },\n    watch: {\n      a: function (val, oldVal) {\n        console.log('new: %s, old: %s', val, oldVal)\n      },\n      // 方法名\n      b: 'someMethod',\n      // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深\n      c: {\n        handler: function (val, oldVal) { /* ... */ },\n        deep: true\n      },\n      // 该回调将会在侦听开始之后被立即调用\n      d: {\n        handler: 'someMethod',\n        immediate: true\n      },\n      // 你可以传入回调数组，它们会被逐一调用\n      e: [\n        'handle1',\n        function handle2 (val, oldVal) { /* ... */ },\n        {\n          handler: function handle3 (val, oldVal) { /* ... */ },\n          /* ... */\n        }\n      ],\n      // watch vm.e.f's value: {g: 5}\n      'e.f': function (val, oldVal) { /* ... */ }\n    }\n  })\n  vm.a = 2 // => new: 2, old: 1\n  ```\n\n  <p class=\"tip\">注意，**不应该使用箭头函数来定义 watcher 函数** (例如 `searchQuery: newValue => this.updateAutocomplete(newValue)`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.updateAutocomplete` 将是 undefined。</p>\n\n- **参考**：[实例方法 / 数据 - vm.$watch](#vm-watch)\n\n## 选项 / DOM\n\n### el\n\n- **类型**：`string | Element`\n\n- **限制**：只在用 `new` 创建实例时生效。\n\n- **详细**：\n\n  提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。\n\n  在实例挂载之后，元素可以用 `vm.$el` 访问。\n\n  如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 `vm.$mount()` 手动开启编译。\n\n  <p class=\"tip\"> 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载 root 实例到 `<html>` 或者 `<body>` 上。</p>\n\n  <p class=\"tip\">如果 `render` 函数和 `template` property 都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。</p>\n\n- **参考**：\n  - [生命周期图示](../guide/instance.html#生命周期图示)\n  - [运行时 + 编译器 vs. 只包含运行时](../guide/installation.html#运行时-编译器-vs-只包含运行时)\n\n### template\n\n- **类型**：`string`\n\n- **详细**：\n\n  一个字符串模板作为 Vue 实例的标识使用。模板将会**替换**挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。\n\n  如果值以 `#` 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 `<script type=\"x-template\">` 包含模板。\n\n  <p class=\"tip\">出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。</p>\n\n  <p class=\"tip\">如果 Vue 选项中包含渲染函数，该模板将被忽略。</p>\n\n- **参考**：\n  - [生命周期图示](../guide/instance.html#生命周期图示)\n  - [通过插槽分发内容](../guide/components.html#通过插槽分发内容)\n\n### render\n\n  - **类型**：`(createElement: () => VNode) => VNode`\n\n  - **详细**：\n\n    字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 `createElement` 方法作为第一个参数用来创建 `VNode`。\n\n    如果组件是一个函数组件，渲染函数还会接收一个额外的 `context` 参数，为没有实例的函数组件提供上下文信息。\n\n    <p class=\"tip\">Vue 选项中的 `render` 函数若存在，则 Vue 构造函数不会从 `template` 选项或通过 `el` 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。</p>\n\n  - **参考**：[渲染函数](../guide/render-function.html)\n\n### renderError\n\n> 2.2.0 新增\n\n  - **类型**：`(createElement: () => VNode, error: Error) => VNode`\n\n  - **详细**：\n\n    **只在开发者环境下工作。**\n\n    当 `render` 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 `renderError`。这个功能配合 hot-reload 非常实用。\n\n  - **示例**：\n\n    ``` js\n    new Vue({\n      render (h) {\n        throw new Error('oops')\n      },\n      renderError (h, err) {\n        return h('pre', { style: { color: 'red' }}, err.stack)\n      }\n    }).$mount('#app')\n    ```\n\n  - **参考**：[渲染函数](../guide/render-function.html)\n\n## 选项 / 生命周期钩子\n\n<p class=\"tip\">所有的生命周期钩子自动绑定 `this` 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。这意味着**你不能使用箭头函数来定义一个生命周期方法** (例如 `created: () => this.fetchTodos()`)。这是因为箭头函数绑定了父上下文，因此 `this` 与你期待的 Vue 实例不同，`this.fetchTodos` 的行为未定义。</p>\n\n### beforeCreate\n\n- **类型**：`Function`\n\n- **详细**：\n\n  在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### created\n\n- **类型**：`Function`\n\n- **详细**：\n\n  在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，`$el` property 目前尚不可用。\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### beforeMount\n\n- **类型**：`Function`\n\n- **详细**：\n\n  在挂载开始之前被调用：相关的 `render` 函数首次被调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### mounted\n\n- **类型**：`Function`\n\n- **详细**：\n\n  实例被挂载后调用，这时 `el` 被新创建的 `vm.$el` 替换了。如果根实例挂载到了一个文档内的元素上，当 `mounted` 被调用时 `vm.$el` 也在文档内。\n\n  注意 `mounted` **不会**保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 `mounted` 内部使用 [vm.$nextTick](#vm-nextTick)：\n\n  ``` js\n  mounted: function () {\n    this.$nextTick(function () {\n      // Code that will run only after the\n      // entire view has been rendered\n    })\n  }\n  ```\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### beforeUpdate\n\n- **类型**：`Function`\n\n- **详细**：\n\n  数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。\n\n  **该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### updated\n\n- **类型**：`Function`\n\n- **详细**：\n\n  由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。\n\n  当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用[计算属性](#computed)或 [watcher](#watch) 取而代之。\n\n  注意 `updated` **不会**保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 `updated` 里使用 [vm.$nextTick](#vm-nextTick)：\n\n  ``` js\n  updated: function () {\n    this.$nextTick(function () {\n      // Code that will run only after the\n      // entire view has been re-rendered\n    })\n  }\n  ```\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### activated\n\n- **类型**：`Function`\n\n- **详细**：\n\n  被 keep-alive 缓存的组件激活时调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：\n  - [构建组件 - keep-alive](#keep-alive)\n  - [动态组件 - keep-alive](../guide/components-dynamic-async.html#在动态组件上使用-keep-alive)\n\n### deactivated\n\n- **类型**：`Function`\n\n- **详细**：\n\n  被 keep-alive 缓存的组件停用时调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：\n  - [构建组件 - keep-alive](#keep-alive)\n  - [动态组件 - keep-alive](../guide/components-dynamic-async.html#在动态组件上使用-keep-alive)\n\n### beforeDestroy\n\n- **类型**：`Function`\n\n- **详细**：\n\n  实例销毁之前调用。在这一步，实例仍然完全可用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### destroyed\n\n- **类型**：`Function`\n\n- **详细**：\n\n  实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### errorCaptured\n\n> 2.5.0+ 新增\n\n- **类型**：`(err: Error, vm: Component, info: string) => ?boolean`\n\n- **详细**：\n\n  当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 `false` 以阻止该错误继续向上传播。\n\n  <p class=\"tip\">你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p>\n\n  **错误传播规则**\n\n  - 默认情况下，如果全局的 `config.errorHandler` 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。\n\n  - 如果一个组件的继承或父级从属链路中存在多个 `errorCaptured` 钩子，则它们将会被相同的错误逐个唤起。\n\n  - 如果此 `errorCaptured` 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 `config.errorHandler`。\n\n  - 一个 `errorCaptured` 钩子能够返回 `false` 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 `errorCaptured` 钩子和全局的 `config.errorHandler`。\n\n## 选项 / 资源\n\n### directives\n\n- **类型**：`Object`\n\n- **详细**：\n\n包含 Vue 实例可用指令的哈希表。\n\n- **参考**：[自定义指令](../guide/custom-directive.html)\n\n### filters\n\n- **类型**：`Object`\n\n- **详细**：\n\n包含 Vue 实例可用过滤器的哈希表。\n\n- **参考**：[`Vue.filter`](#Vue-filter)\n\n### components\n\n- **类型**：`Object`\n\n- **详细**：\n\n包含 Vue 实例可用组件的哈希表。\n\n- **参考**：[组件](../guide/components.html)\n\n## 选项 / 组合\n\n### parent\n\n- **类型**：`Vue instance`\n\n- **详细**：\n\n  指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 `this.$parent` 访问父实例，子实例被推入父实例的 `$children` 数组中。\n\n  <p class=\"tip\">节制地使用 `$parent` 和 `$children` - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信</p>\n\n### mixins\n\n- **类型**：`Array<Object>`\n\n- **详细**：\n\n  `mixins` 选项接收一个混入对象的数组。这些混入对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用的是和 `Vue.extend()` 一样的选项合并逻辑。也就是说，如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。\n\n  Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。\n\n- **示例**：\n\n  ``` js\n  var mixin = {\n    created: function () { console.log(1) }\n  }\n  var vm = new Vue({\n    created: function () { console.log(2) },\n    mixins: [mixin]\n  })\n  // => 1\n  // => 2\n  ```\n\n- **参考**：[混入](../guide/mixins.html)\n\n### extends\n\n- **类型**：`Object | Function`\n\n- **详细**：\n\n  允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 `Vue.extend`。这主要是为了便于扩展单文件组件。\n\n  这和 `mixins` 类似。\n\n- **示例**：\n\n  ``` js\n  var CompA = { ... }\n\n  // 在没有调用 `Vue.extend` 时候继承 CompA\n  var CompB = {\n    extends: CompA,\n    ...\n  }\n  ```\n\n### provide / inject\n\n> 2.2.0 新增\n\n- **类型**：\n  - **provide**：`Object | () => Object`\n  - **inject**：`Array<string> | { [key: string]: string | Symbol | Object }`\n\n- **详细**：\n\n  <p class=\"tip\">`provide` 和 `inject` 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。</p>\n\n  这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。\n\n  `provide` 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 `Symbol` 和 `Reflect.ownKeys` 的环境下可工作。\n\n  `inject` 选项应该是：\n  - 一个字符串数组，或\n  - 一个对象，对象的 key 是本地的绑定名，value 是：\n    - 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或\n    - 一个对象，该对象的：\n      - `from` property 是在可用的注入内容中搜索用的 key (字符串或 Symbol)\n      - `default` property 是降级情况下使用的 value\n\n  > 提示：`provide` 和 `inject` 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。\n\n- **示例**：\n\n  ``` js\n  // 父级组件提供 'foo'\n  var Provider = {\n    provide: {\n      foo: 'bar'\n    },\n    // ...\n  }\n\n  // 子组件注入 'foo'\n  var Child = {\n    inject: ['foo'],\n    created () {\n      console.log(this.foo) // => \"bar\"\n    }\n    // ...\n  }\n  ```\n\n  利用 ES2015 Symbols、函数 `provide` 和对象 `inject`：\n\n  ``` js\n  const s = Symbol()\n\n  const Provider = {\n    provide () {\n      return {\n        [s]: 'foo'\n      }\n    }\n  }\n\n  const Child = {\n    inject: { s },\n    // ...\n  }\n  ```\n\n  > 接下来 2 个例子只工作在 Vue 2.2.1 或更高版本。低于这个版本时，注入的值会在 `props` 和 `data` 初始化之后得到。\n\n  使用一个注入的值作为一个 property 的默认值：\n\n  ```js\n  const Child = {\n    inject: ['foo'],\n    props: {\n      bar: {\n        default () {\n          return this.foo\n        }\n      }\n    }\n  }\n  ```\n\n  使用一个注入的值作为数据入口：\n\n  ```js\n  const Child = {\n    inject: ['foo'],\n    data () {\n      return {\n        bar: this.foo\n      }\n    }\n  }\n  ```\n\n  > 在 2.5.0+ 的注入可以通过设置默认值使其变成可选项：\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: { default: 'foo' }\n    }\n  }\n  ```\n\n  如果它需要从一个不同名字的 property 注入，则使用 `from` 来表示其源 property：\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: {\n        from: 'bar',\n        default: 'foo'\n      }\n    }\n  }\n  ```\n\n  与 prop 的默认值类似，你需要对非原始值使用一个工厂方法：\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: {\n        from: 'bar',\n        default: () => [1, 2, 3]\n      }\n    }\n  }\n  ```\n\n## 选项 / 其它\n\n### name\n\n- **类型**：`string`\n\n- **限制**：只有作为组件选项时起作用。\n\n- **详细**：\n\n  允许组件模板递归地调用自身。注意，组件在全局用 `Vue.component()` 注册时，全局 ID 自动作为组件的 name。\n\n  指定 `name` 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 [vue-devtools](https://github.com/vuejs/vue-devtools)，未命名组件将显示成 `<AnonymousComponent>`，这很没有语义。通过提供 `name` 选项，可以获得更有语义信息的组件树。\n\n### delimiters\n\n- **类型**：`Array<string>`\n\n- **默认值**：`{% raw %}[\"{{\", \"}}\"]{% endraw %}`\n\n- **限制**：这个选项只在完整构建版本中的浏览器内编译时可用。\n\n- **详细**：\n\n 改变纯文本插入分隔符。\n\n- **示例**：\n\n  ``` js\n  new Vue({\n    delimiters: ['${', '}']\n  })\n\n  // 分隔符变成了 ES6 模板字符串的风格\n  ```\n\n### functional\n\n- **类型**：`boolean`\n\n- **详细**：\n\n  使组件无状态 (没有 `data`) 和无实例 (没有 `this` 上下文)。他们用一个简单的 `render` 函数返回虚拟节点使它们渲染的代价更小。\n\n- **参考**：[函数式组件](../guide/render-function.html#函数式组件)\n\n### model\n\n> 2.2.0 新增\n\n- **类型**：`{ prop?: string, event?: string }`\n\n- **详细**：\n\n  允许一个自定义组件在使用 `v-model` 时定制 prop 和 event。默认情况下，一个组件上的 `v-model` 会把 `value` 用作 prop 且把 `input` 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 `value` prop 来达到不同的目的。使用 `model` 选项可以回避这些情况产生的冲突。\n\n- **Example**：\n\n  ``` js\n  Vue.component('my-checkbox', {\n    model: {\n      prop: 'checked',\n      event: 'change'\n    },\n    props: {\n      // this allows using the `value` prop for a different purpose\n      value: String,\n      // use `checked` as the prop which take the place of `value`\n      checked: {\n        type: Number,\n        default: 0\n      }\n    },\n    // ...\n  })\n  ```\n\n  ``` html\n  <my-checkbox v-model=\"foo\" value=\"some value\"></my-checkbox>\n  ```\n\n  上述代码相当于：\n\n  ``` html\n  <my-checkbox\n    :checked=\"foo\"\n    @change=\"val => { foo = val }\"\n    value=\"some value\">\n  </my-checkbox>\n  ```\n\n### inheritAttrs\n\n> 2.4.0 新增\n\n- **类型**：`boolean`\n\n- **默认值**：`true`\n\n- **详细**：\n\n  默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 `inheritAttrs` 到 `false`，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例 property `$attrs` 可以让这些 attribute 生效，且可以通过 `v-bind` 显性的绑定到非根元素上。\n\n  注意：这个选项**不影响** `class` 和 `style` 绑定。\n\n### comments\n\n> 2.4.0 新增\n\n- **类型**：`boolean`\n\n- **默认值**：`false`\n\n- **限制**：这个选项只在完整构建版本中的浏览器内编译时可用。\n\n- **详细**：\n\n  当设为 `true` 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。\n\n## 实例 property\n\n### vm.$data\n\n- **类型**：`Object`\n\n- **详细**：\n\n  Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象 property 的访问。\n\n- **参考**：[选项 / 数据 - data](#data)\n\n### vm.$props\n\n> 2.2.0 新增\n\n- **类型**：`Object`\n\n- **详细**：\n\n  当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象 property 的访问。\n\n### vm.$el\n\n- **类型**：`Element`\n\n- **只读**\n\n- **详细**：\n\n  Vue 实例使用的根 DOM 元素。\n\n### vm.$options\n\n- **类型**：`Object`\n\n- **只读**\n\n- **详细**：\n\n  用于当前 Vue 实例的初始化选项。需要在选项中包含自定义 property 时会有用处：\n\n  ``` js\n  new Vue({\n    customOption: 'foo',\n    created: function () {\n      console.log(this.$options.customOption) // => 'foo'\n    }\n  })\n  ```\n\n### vm.$parent\n\n- **类型**：`Vue instance`\n\n- **只读**\n\n- **详细**：\n\n  父实例，如果当前实例有的话。\n\n### vm.$root\n\n- **类型**：`Vue instance`\n\n- **只读**\n\n- **详细**：\n\n  当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。\n\n### vm.$children\n\n- **类型**：`Array<Vue instance>`\n\n- **只读**\n\n- **详细**：\n\n  当前实例的直接子组件。**需要注意 `$children` 并不保证顺序，也不是响应式的。**如果你发现自己正在尝试使用 `$children` 来进行数据绑定，考虑使用一个数组配合 `v-for` 来生成子组件，并且使用 Array 作为真正的来源。\n\n### vm.$slots\n\n- **类型**：`{ [name: string]: ?Array<VNode> }`\n\n- **只读**\n\n- **详细**：\n\n  用来访问被[插槽分发](../guide/components.html#通过插槽分发内容)的内容。每个[具名插槽](../guide/components-slots.html#具名插槽)有其相应的 property (例如：`v-slot:foo` 中的内容将会在 `vm.$slots.foo` 中被找到)。`default` property 包括了所有没有被包含在具名插槽中的节点，或 `v-slot:default` 的内容。\n\n  **注意：**`v-slot:foo` 在 2.6 以上的版本才支持。对于之前的版本，你可以使用[废弃了的语法](../guide/components-slots.html#废弃了的语法)。\n\n  在使用[渲染函数](../guide/render-function.html)书写一个组件时，访问 `vm.$slots` 最有帮助。\n\n- **示例**：\n\n  ```html\n  <blog-post>\n    <template v-slot:header>\n      <h1>About Me</h1>\n    </template>\n\n    <p>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.</p>\n\n    <template v-slot:footer>\n      <p>Copyright 2016 Evan You</p>\n    </template>\n\n    <p>If I have some content down here, it will also be included in vm.$slots.default.</p>.\n  </blog-post>\n  ```\n\n  ```js\n  Vue.component('blog-post', {\n    render: function (createElement) {\n      var header = this.$slots.header\n      var body   = this.$slots.default\n      var footer = this.$slots.footer\n      return createElement('div', [\n        createElement('header', header),\n        createElement('main', body),\n        createElement('footer', footer)\n      ])\n    }\n  })\n  ```\n\n- **参考**：\n  - [`<slot>` 组件](#slot)\n  - [通过插槽分发内容](../guide/components.html#通过插槽分发内容)\n  - [渲染函数 - 插槽](../guide/render-function.html#插槽)\n\n### vm.$scopedSlots\n\n> 2.1.0 新增\n\n- **类型**：`{ [name: string]: props => Array<VNode> | undefined }`\n\n- **只读**\n\n- **详细**：\n\n  用来访问[作用域插槽](../guide/components-slots.html#作用域插槽)。对于包括 `默认 slot` 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。\n\n  `vm.$scopedSlots` 在使用[渲染函数](../guide/render-function.html)开发一个组件时特别有用。\n\n  **注意**：从 2.6.0 开始，这个 property 有两个变化：\n\n  1. 作用域插槽函数现在保证返回一个 VNode 数组，除非在返回值无效的情况下返回 `undefined`。\n\n  2. 所有的 `$slots` 现在都会作为函数暴露在 `$scopedSlots` 中。如果你在使用渲染函数，不论当前插槽是否带有作用域，我们都推荐始终通过 `$scopedSlots` 访问它们。这不仅仅使得在未来添加作用域变得简单，也可以让你最终轻松迁移到所有插槽都是函数的 Vue 3。\n\n- **参考**：\n  - [`<slot>` 组件](#slot)\n  - [作用域插槽](../guide/components-slots.html#作用域插槽)\n  - [渲染函数 - 插槽](../guide/render-function.html#插槽)\n\n### vm.$refs\n\n- **类型**：`Object`\n\n- **只读**\n\n- **详细**：\n\n  一个对象，持有注册过 [`ref` attribute](#ref) 的所有 DOM 元素和组件实例。\n\n- **参考**：\n  - [子组件 ref](../guide/components-edge-cases.html#访问子组件实例或子元素)\n  - [特殊 attribute - ref](#ref)\n\n### vm.$isServer\n\n- **类型**：`boolean`\n\n- **只读**\n\n- **详细**：\n\n  当前 Vue 实例是否运行于服务器。\n\n- **参考**：[服务端渲染](../guide/ssr.html)\n\n### vm.$attrs\n\n> 2.4.0 新增\n\n- **类型**：`{ [key: string]: string }`\n\n- **只读**\n\n- **详细**：\n\n  包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (`class` 和 `style` 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (`class` 和 `style` 除外)，并且可以通过 `v-bind=\"$attrs\"` 传入内部组件——在创建高级别的组件时非常有用。\n\n### vm.$listeners\n\n> 2.4.0 新增\n\n- **类型**：`{ [key: string]: Function | Array<Function> }`\n\n- **只读**\n\n- **详细**：\n\n  包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on=\"$listeners\"` 传入内部组件——在创建更高层次的组件时非常有用。\n\n## 实例方法 / 数据\n\n### vm.$watch( expOrFn, callback, [options] )\n\n- **参数**：\n  - `{string | Function} expOrFn`\n  - `{Function | Object} callback`\n  - `{Object} [options]`\n    - `{boolean} deep`\n    - `{boolean} immediate`\n\n- **返回值**：`{Function} unwatch`\n\n- **用法**：\n\n  观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代。\n\n  <p class=\"tip\">注意：在变更 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变更之前值的副本。</p>\n\n- **示例**：\n\n  ``` js\n  // 键路径\n  vm.$watch('a.b.c', function (newVal, oldVal) {\n    // 做点什么\n  })\n\n  // 函数\n  vm.$watch(\n    function () {\n      // 表达式 `this.a + this.b` 每次得出一个不同的结果时\n      // 处理函数都会被调用。\n      // 这就像监听一个未被定义的计算属性\n      return this.a + this.b\n    },\n    function (newVal, oldVal) {\n      // 做点什么\n    }\n  )\n  ```\n\n  `vm.$watch` 返回一个取消观察函数，用来停止触发回调：\n\n  ``` js\n  var unwatch = vm.$watch('a', cb)\n  // 之后取消观察\n  unwatch()\n  ```\n\n- **选项：deep**\n\n  为了发现对象内部值的变化，可以在选项参数中指定 `deep: true`。注意监听数组的变更不需要这么做。\n\n  ``` js\n  vm.$watch('someObject', callback, {\n    deep: true\n  })\n  vm.someObject.nestedValue = 123\n  // callback is fired\n  ```\n\n- **选项：immediate**\n\n  在选项参数中指定 `immediate: true` 将立即以表达式的当前值触发回调：\n\n  ``` js\n  vm.$watch('a', callback, {\n    immediate: true\n  })\n  // 立即以 `a` 的当前值触发回调\n  ```\n\n  注意在带有 `immediate` 选项时，你不能在第一次回调时取消侦听给定的 property。\n\n  ``` js\n  // 这会导致报错\n  var unwatch = vm.$watch(\n    'value',\n    function () {\n      doSomething()\n      unwatch()\n    },\n    { immediate: true }\n  )\n  ```\n\n  如果你仍然希望在回调内部调用一个取消侦听的函数，你应该先检查其函数的可用性：\n\n  ``` js\n  var unwatch = vm.$watch(\n    'value',\n    function () {\n      doSomething()\n      if (unwatch) {\n        unwatch()\n      }\n    },\n    { immediate: true }\n  )\n  ```\n\n### vm.$set( target, propertyName/index, value )\n\n- **参数**：\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n  - `{any} value`\n\n- **返回值**：设置的值。\n\n- **用法**：\n\n  这是全局 `Vue.set` 的**别名**。\n\n- **参考**：[Vue.set](#Vue-set)\n\n### vm.$delete( target, propertyName/index )\n\n- **参数**：\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n\n- **用法**：\n\n  这是全局 `Vue.delete` 的**别名**。\n\n- **参考**：[Vue.delete](#Vue-delete)\n\n## 实例方法 / 事件\n\n### vm.$on( event, callback )\n\n- **参数**：\n  - `{string | Array<string>} event` (数组只在 2.2.0+ 中支持)\n  - `{Function} callback`\n\n- **用法**：\n\n  监听当前实例上的自定义事件。事件可以由 `vm.$emit` 触发。回调函数会接收所有传入事件触发函数的额外参数。\n\n- **示例**：\n\n  ``` js\n  vm.$on('test', function (msg) {\n    console.log(msg)\n  })\n  vm.$emit('test', 'hi')\n  // => \"hi\"\n  ```\n\n### vm.$once( event, callback )\n\n- **参数**：\n  - `{string} event`\n  - `{Function} callback`\n\n- **用法**：\n\n  监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。\n\n### vm.$off( [event, callback] )\n\n- **参数**：\n  - `{string | Array<string>} event` (只在 2.2.2+ 支持数组)\n  - `{Function} [callback]`\n\n- **用法**：\n\n  移除自定义事件监听器。\n\n  - 如果没有提供参数，则移除所有的事件监听器；\n\n  - 如果只提供了事件，则移除该事件所有的监听器；\n\n  - 如果同时提供了事件与回调，则只移除这个回调的监听器。\n\n### vm.$emit( eventName, [...args] )\n\n- **参数**：\n  - `{string} eventName`\n  - `[...args]`\n\n  触发当前实例上的事件。附加参数都会传给监听器回调。\n\n- **示例：**\n\n  只配合一个事件名使用 `$emit`：\n\n  ```js\n  Vue.component('welcome-button', {\n    template: `\n      <button v-on:click=\"$emit('welcome')\">\n        Click me to be welcomed\n      </button>\n    `\n  })\n  ```\n\n  ```html\n  <div id=\"emit-example-simple\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  ```\n\n  ```js\n  new Vue({\n    el: '#emit-example-simple',\n    methods: {\n      sayHi: function () {\n        alert('Hi!')\n      }\n    }\n  })\n  ```\n\n  {% raw %}\n  <div id=\"emit-example-simple\" class=\"demo\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  <script>\n    Vue.component('welcome-button', {\n      template: `\n        <button v-on:click=\"$emit('welcome')\">\n          Click me to be welcomed\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-simple',\n      methods: {\n        sayHi: function () {\n          alert('Hi!')\n        }\n      }\n    })\n  </script>\n  {% endraw %}\n\n  配合额外的参数使用 `$emit`：\n\n  ```js\n  Vue.component('magic-eight-ball', {\n    data: function () {\n      return {\n        possibleAdvice: ['Yes', 'No', 'Maybe']\n      }\n    },\n    methods: {\n      giveAdvice: function () {\n        var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n        this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n      }\n    },\n    template: `\n      <button v-on:click=\"giveAdvice\">\n        Click me for advice\n      </button>\n    `\n  })\n  ```\n\n  ```html\n  <div id=\"emit-example-argument\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  ```\n\n  ```js\n  new Vue({\n    el: '#emit-example-argument',\n    methods: {\n      showAdvice: function (advice) {\n        alert(advice)\n      }\n    }\n  })\n  ```\n\n  {% raw %}\n  <div id=\"emit-example-argument\" class=\"demo\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  <script>\n    Vue.component('magic-eight-ball', {\n      data: function () {\n        return {\n          possibleAdvice: ['Yes', 'No', 'Maybe']\n        }\n      },\n      methods: {\n        giveAdvice: function () {\n          var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n          this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n        }\n      },\n      template: `\n        <button v-on:click=\"giveAdvice\">\n          Click me for advice\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-argument',\n      methods: {\n        showAdvice: function (advice) {\n          alert(advice)\n        }\n      }\n    })\n  </script>\n  {% endraw %}\n\n## 实例方法 / 生命周期\n\n### vm.$mount( [elementOrSelector] )\n\n- **参数**：\n  - `{Element | string} [elementOrSelector]`\n  - `{boolean} [hydrating]`\n\n- **返回值**：`vm` - 实例自身\n\n- **用法**：\n\n  如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 `vm.$mount()` 手动地挂载一个未挂载的实例。\n\n  如果没有提供 `elementOrSelector` 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。\n\n  这个方法返回实例自身，因而可以链式调用其它实例方法。\n\n- **示例**：\n\n  ``` js\n  var MyComponent = Vue.extend({\n    template: '<div>Hello!</div>'\n  })\n\n  // 创建并挂载到 #app (会替换 #app)\n  new MyComponent().$mount('#app')\n\n  // 同上\n  new MyComponent({ el: '#app' })\n\n  // 或者，在文档之外渲染并且随后挂载\n  var component = new MyComponent().$mount()\n  document.getElementById('app').appendChild(component.$el)\n  ```\n\n- **参考**：\n  - [生命周期图示](../guide/instance.html#生命周期图示)\n  - [服务端渲染](../guide/ssr.html)\n\n### vm.$forceUpdate()\n\n- **示例**：\n\n  迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。\n\n### vm.$nextTick( [callback] )\n\n- **参数**：\n  - `{Function} [callback]`\n\n- **用法**：\n\n  将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 `Vue.nextTick` 一样，不同的是回调的 `this` 自动绑定到调用它的实例上。\n\n  > 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise (IE：你们都看我干嘛)，你得自行 polyfill。\n\n- **示例**：\n\n  ``` js\n  new Vue({\n    // ...\n    methods: {\n      // ...\n      example: function () {\n        // 修改数据\n        this.message = 'changed'\n        // DOM 还没有更新\n        this.$nextTick(function () {\n          // DOM 现在更新了\n          // `this` 绑定到当前实例\n          this.doSomethingElse()\n        })\n      }\n    }\n  })\n  ```\n\n- **参考**\n  - [Vue.nextTick](#Vue-nextTick)\n  - [异步更新队列](../guide/reactivity.html#异步更新队列)\n\n### vm.$destroy()\n\n- **用法**：\n\n  完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。\n\n  触发 `beforeDestroy` 和 `destroyed` 的钩子。\n\n  <p class=\"tip\">在大多数场景中你不应该调用这个方法。最好使用 `v-if` 和 `v-for` 指令以数据驱动的方式控制子组件的生命周期。</p>\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n## 指令\n\n### v-text\n\n- **预期**：`string`\n\n- **详细**：\n\n  更新元素的 `textContent`。如果要更新部分的 `textContent`，需要使用 `{% raw %}{{ Mustache }}{% endraw %}` 插值。\n\n- **示例**：\n\n  ```html\n  <span v-text=\"msg\"></span>\n  <!-- 和下面的一样 -->\n  <span>{{msg}}</span>\n  ```\n\n- **参考**：[数据绑定语法 - 插值](../guide/syntax.html#插值)\n\n### v-html\n\n- **预期**：`string`\n\n- **详细**：\n\n  更新元素的 `innerHTML`。**注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译**。如果试图使用 `v-html` 组合模板，可以重新考虑是否通过使用组件来替代。\n\n  <p class=\"tip\">在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。只在可信内容上使用 `v-html`，**永不**用在用户提交的内容上。</p>\n\n  <p class=\"tip\">在[单文件组件](../guide/single-file-components.html)里，`scoped` 的样式不会应用在 `v-html` 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 `v-html` 的内容设置带作用域的 CSS，你可以替换为 [CSS Modules](https://vue-loader.vuejs.org/en/features/css-modules.html) 或用一个额外的全局 `<style>` 元素手动设置类似 BEM 的作用域策略。</p>\n\n- **示例**：\n\n  ```html\n  <div v-html=\"html\"></div>\n  ```\n\n- **参考**：[数据绑定语法 - 插值](../guide/syntax.html#纯-HTML)\n\n### v-show\n\n- **预期**：`any`\n\n- **用法**：\n\n  根据表达式之真假值，切换元素的 `display` CSS property。\n\n  当条件变化时该指令触发过渡效果。\n\n- **参考**：[条件渲染 - v-show](../guide/conditional.html#v-show)\n\n### v-if\n\n- **预期**：`any`\n\n- **用法**：\n\n  根据表达式的值的 [truthiness](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy) 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 `<template>`，将提出它的内容作为条件块。\n\n  当条件变化时该指令触发过渡效果。\n\n  <p class=\"tip\">当和 `v-if` 一起使用时，`v-for` 的优先级比 `v-if` 更高。详见[列表渲染教程](../guide/list.html#v-for-with-v-if)</p>\n\n- **参考**：[条件渲染 - v-if](../guide/conditional.html)\n\n### v-else\n\n- **不需要表达式**\n\n- **限制**：前一兄弟元素必须有 `v-if` 或 `v-else-if`。\n\n- **用法**：\n\n  为 `v-if` 或者 `v-else-if` 添加“else 块”。\n\n  ```html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **参考**：[条件渲染 - v-else](../guide/conditional.html#v-else)\n\n### v-else-if\n\n> 2.1.0 新增\n\n- **类型**：`any`\n\n- **限制**：前一兄弟元素必须有 `v-if` 或 `v-else-if`。\n\n- **用法**：\n\n  表示 `v-if` 的“else if 块”。可以链式调用。\n\n  ```html\n  <div v-if=\"type === 'A'\">\n    A\n  </div>\n  <div v-else-if=\"type === 'B'\">\n    B\n  </div>\n  <div v-else-if=\"type === 'C'\">\n    C\n  </div>\n  <div v-else>\n    Not A/B/C\n  </div>\n  ```\n\n- **参考**：[条件渲染 - v-else-if](../guide/conditional.html#v-else-if)\n\n### v-for\n\n- **预期**：`Array | Object | number | string | Iterable (2.6 新增)`\n\n- **用法**：\n\n  基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 `alias in expression`，为当前遍历的元素提供别名：\n\n  ``` html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  另外也可以为数组索引指定别名 (或者用于对象的键)：\n\n  ``` html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(val, key) in object\"></div>\n  <div v-for=\"(val, name, index) in object\"></div>\n  ```\n\n  `v-for` 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute `key` 来提供一个排序提示：\n\n  ``` html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  从 2.6 起，`v-for` 也可以在实现了[可迭代协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#可迭代协议)的值上使用，包括原生的 `Map` 和 `Set`。不过应该注意的是 Vue 2.x 目前并不支持可响应的 `Map` 和 `Set` 值，所以无法自动探测变更。\n\n  <p class=\"tip\">当和 `v-if` 一起使用时，`v-for` 的优先级比 `v-if` 更高。详见[列表渲染教程](../guide/list.html#v-for-with-v-if)</p>\n\n  `v-for` 的详细用法可以通过以下链接查看教程详细说明。\n\n- **参考**：\n  - [列表渲染](../guide/list.html)\n  - [key](../guide/list.html#key)\n\n### v-on\n\n- **缩写**：`@`\n\n- **预期**：`Function | Inline Statement | Object`\n\n- **参数**：`event`\n\n- **修饰符**：\n  - `.stop` - 调用 `event.stopPropagation()`。\n  - `.prevent` - 调用 `event.preventDefault()`。\n  - `.capture` - 添加事件侦听器时使用 capture 模式。\n  - `.self` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\n  - `.{keyCode | keyAlias}` - 只当事件是从特定键触发时才触发回调。\n  - `.native` - 监听组件根元素的原生事件。\n  - `.once` - 只触发一次回调。\n  - `.left` - (2.2.0) 只当点击鼠标左键时触发。\n  - `.right` - (2.2.0) 只当点击鼠标右键时触发。\n  - `.middle` - (2.2.0) 只当点击鼠标中键时触发。\n  - `.passive` - (2.3.0) 以 `{ passive: true }` 模式添加侦听器\n\n- **用法**：\n\n  绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。\n\n  用在普通元素上时，只能监听[**原生 DOM 事件**](https://developer.mozilla.org/zh-CN/docs/Web/Events)。用在自定义元素组件上时，也可以监听子组件触发的**自定义事件**。\n\n  在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 `$event` property：`v-on:click=\"handle('ok', $event)\"`。\n\n  从 `2.4.0` 开始，`v-on` 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。\n\n- **示例**：\n\n  ```html\n  <!-- 方法处理器 -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- 动态事件 (2.6.0+) -->\n  <button v-on:[event]=\"doThis\"></button>\n\n  <!-- 内联语句 -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- 缩写 -->\n  <button @click=\"doThis\"></button>\n\n  <!-- 动态事件缩写 (2.6.0+) -->\n  <button @[event]=\"doThis\"></button>\n\n  <!-- 停止冒泡 -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- 阻止默认行为 -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- 阻止默认行为，没有表达式 -->\n  <form @submit.prevent></form>\n\n  <!--  串联修饰符 -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- 键修饰符，键别名 -->\n  <input @keyup.enter=\"onEnter\">\n\n  <!-- 键修饰符，键代码 -->\n  <input @keyup.13=\"onEnter\">\n\n  <!-- 点击回调只会触发一次 -->\n  <button v-on:click.once=\"doThis\"></button>\n\n  <!-- 对象语法 (2.4.0+) -->\n  <button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button>\n  ```\n\n  在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：\n\n  ```html\n  <my-component @my-event=\"handleThis\"></my-component>\n\n  <!-- 内联语句 -->\n  <my-component @my-event=\"handleThis(123, $event)\"></my-component>\n\n  <!-- 组件中的原生事件 -->\n  <my-component @click.native=\"onClick\"></my-component>\n  ```\n\n- **参考**：\n  - [事件处理器](../guide/events.html)\n  - [组件 - 自定义事件](../guide/components.html#监听子组件事件)\n\n### v-bind\n\n- **缩写**：`:`\n\n- **预期**：`any (with argument) | Object (without argument)`\n\n- **参数**：`attrOrProp (optional)`\n\n- **修饰符**：\n  - `.prop` - 作为一个 DOM property 绑定而不是作为 attribute 绑定。([差别在哪里？](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028))\n  - `.camel` - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)\n  - `.sync` (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 `v-on` 侦听器。\n\n- **用法**：\n\n  动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。\n\n  在绑定 `class` 或 `style` attribute 时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。\n\n  在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。\n\n  没有参数时，可以绑定到一个包含键值对的对象。注意此时 `class` 和 `style` 绑定不支持数组和对象。\n\n- **示例**：\n\n  ```html\n  <!-- 绑定一个 attribute -->\n  <img v-bind:src=\"imageSrc\">\n\n  <!-- 动态 attribute 名 (2.6.0+) -->\n  <button v-bind:[key]=\"value\"></button>\n\n  <!-- 缩写 -->\n  <img :src=\"imageSrc\">\n\n  <!-- 动态 attribute 名缩写 (2.6.0+) -->\n  <button :[key]=\"value\"></button>\n\n  <!-- 内联字符串拼接 -->\n  <img :src=\"'/path/to/images/' + fileName\">\n\n  <!-- class 绑定 -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\">\n\n  <!-- style 绑定 -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- 绑定一个全是 attribute 的对象 -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- 通过 prop 修饰符绑定 DOM attribute -->\n  <div v-bind:text-content.prop=\"text\"></div>\n\n  <!-- prop 绑定。“prop”必须在 my-component 中声明。-->\n  <my-component :prop=\"someThing\"></my-component>\n\n  <!-- 通过 $props 将父组件的 props 一起传给子组件 -->\n  <child-component v-bind=\"$props\"></child-component>\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n  `.camel` 修饰符允许在使用 DOM 模板时将 `v-bind` property 名称驼峰化，例如 SVG 的 `viewBox` property：\n\n  ``` html\n  <svg :view-box.camel=\"viewBox\"></svg>\n  ```\n\n  在使用字符串模板或通过 `vue-loader`/`vueify` 编译时，无需使用 `.camel`。\n\n- **参考**：\n  - [Class 与 Style 绑定](../guide/class-and-style.html)\n  - [组件 - Props](../guide/components.html#通过-Prop-向子组件传递数据)\n  - [组件 - `.sync` 修饰符](../guide/components-custom-events.html#sync-修饰符)\n\n### v-model\n\n- **预期**：随表单控件类型不同而不同。\n\n- **限制**：\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **修饰符**：\n  - [`.lazy`](../guide/forms.html#lazy) - 取代 `input` 监听 `change` 事件\n  - [`.number`](../guide/forms.html#number) - 输入字符串转为有效的数字\n  - [`.trim`](../guide/forms.html#trim) - 输入首尾空格过滤\n\n- **用法**：\n\n  在表单控件或者组件上创建双向绑定。细节请看下面的教程链接。\n\n- **参考**：\n  - [表单控件绑定](../guide/forms.html)\n  - [组件 - 在输入组件上使用自定义事件](../guide/components-custom-events.html#将原生事件绑定到组件)\n\n### v-slot\n\n- **缩写**：`#`\n\n- **预期**：可放置在函数参数位置的 JavaScript 表达式 (在[支持的环境下](../guide/components-slots.html#解构插槽-Props)可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。\n\n- **参数**：插槽名 (可选，默认值是 `default`)\n\n- **限用于**\n  - `<template>`\n  - [组件](../guide/components-slots.html#独占默认插槽的缩写语法) (对于一个单独的带 prop 的默认插槽)\n\n- **用法**：\n\n  提供具名插槽或需要接收 prop 的插槽。\n\n- **示例**：\n\n  ```html\n  <!-- 具名插槽 -->\n  <base-layout>\n    <template v-slot:header>\n      Header content\n    </template>\n\n    Default slot content\n\n    <template v-slot:footer>\n      Footer content\n    </template>\n  </base-layout>\n\n  <!-- 接收 prop 的具名插槽 -->\n  <infinite-scroll>\n    <template v-slot:item=\"slotProps\">\n      <div class=\"item\">\n        {{ slotProps.item.text }}\n      </div>\n    </template>\n  </infinite-scroll>\n\n  <!-- 接收 prop 的默认插槽，使用了解构 -->\n  <mouse-position v-slot=\"{ x, y }\">\n    Mouse position: {{ x }}, {{ y }}\n  </mouse-position>\n  ```\n\n  更多细节请查阅以下链接。\n\n- **参考**：\n  - [组件 - 插槽](../guide/components-slots.html)\n  - [RFC-0001](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md)\n\n### v-pre\n\n- **不需要表达式**\n\n- **用法**：\n\n  跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。\n\n- **示例**：\n\n  ```html\n  <span v-pre>{{ this will not be compiled }}</span>\n   ```\n\n### v-cloak\n\n- **不需要表达式**\n\n- **用法**：\n\n  这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 `[v-cloak] { display: none }` 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。\n\n- **示例**：\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  <div> 不会显示，直到编译结束。\n\n### v-once\n\n- **不需要表达式**\n\n- **详细**：\n\n  只渲染元素和组件**一次**。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。\n\n  ```html\n  <!-- 单个元素 -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- 有子元素 -->\n  <div v-once>\n    <h1>comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- 组件 -->\n  <my-component v-once :comment=\"msg\"></my-component>\n  <!-- `v-for` 指令-->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n- **参考**：\n  - [数据绑定语法- 插值](../guide/syntax.html#插值)\n  - [组件 - 对低开销的静态组件使用 `v-once`](../guide/components-edge-cases.html#通过-v-once-创建低开销的静态组件)\n\n## 特殊 attribute\n\n### key\n\n- **预期**：`number | string`\n\n  `key` 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。\n\n  有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误。\n\n  最常见的用例是结合 `v-for`：\n\n  ``` html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：\n\n  - 完整地触发组件的生命周期钩子\n  - 触发过渡\n\n  例如：\n\n  ``` html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  当 `text` 发生改变时，`<span>` 总是会被替换而不是被修改，因此会触发过渡。\n\n### ref\n\n- **预期**：`string`\n\n  `ref` 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 `$refs` 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：\n\n  ``` html\n  <!-- `vm.$refs.p` will be the DOM node -->\n  <p ref=\"p\">hello</p>\n\n  <!-- `vm.$refs.child` will be the child component instance -->\n  <child-component ref=\"child\"></child-component>\n  ```\n\n  当 `v-for` 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。\n\n  关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！`$refs` 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。\n\n- **参考**：[子组件 ref](../guide/components-edge-cases.html#访问子组件实例或子元素)\n\n### is\n\n- **预期**：`string | Object (组件的选项对象)`\n\n  用于[动态组件](../guide/components.html#动态组件)且基于 [DOM 内模板的限制](../guide/components.html#解析-DOM-模板时的注意事项)来工作。\n\n  示例：\n\n  ``` html\n  <!-- 当 `currentView` 改变时，组件也跟着改变 -->\n  <component v-bind:is=\"currentView\"></component>\n\n  <!-- 这样做是有必要的，因为 `<my-row>` 放在一个 -->\n  <!-- `<table>` 内可能无效且被放置到外面 -->\n  <table>\n    <tr is=\"my-row\"></tr>\n  </table>\n  ```\n\n  更多的使用细节，请移步至下面的链接。\n\n- **See also**：\n  - [动态组件](../guide/components.html#动态组件)\n  - [DOM 模板解析说明](../guide/components.html#解析-DOM-模板时的注意事项)\n\n### slot <sup style=\"color:#c92222\">废弃</sup>\n\n**推荐 2.6.0 新增的 [v-slot](#v-slot)。**\n\n- **预期**：`string`\n\n  用于标记往哪个具名插槽中插入子组件内容。\n\n- **参考**：[具名插槽](../guide/components-slots.html#具名插槽)\n\n### slot-scope <sup style=\"color:#c92222\">废弃</sup>\n\n**推荐 2.6.0 新增的 [v-slot](#v-slot)。**\n\n- **预期**：`function argument expression`\n\n- **用法**：\n\n  用于将元素或组件表示为作用域插槽。attribute 的值应该是可以出现在函数签名的参数位置的合法的 JavaScript 表达式。这意味着在支持的环境中，你还可以在表达式中使用 ES2015 解构。它在 2.5.0+ 中替代了 [`scope`](#scope-replaced)。\n\n  此 attribute 不支持动态绑定。\n\n- **参考**：[作用域插槽](../guide/components-slots.html#作用域插槽)\n\n### scope <sup style=\"color:#c92222\">移除</sup>\n\n**被 2.5.0 新增的 [slot-scope](#slot-scope) 取代。推荐 2.6.0 新增的 [v-slot](#v-slot)。**\n\n用于表示一个作为带作用域的插槽的 `<template>` 元素，它在 2.5.0+ 中被 [`slot-scope`](#slot-scope) 替代。\n\n- **用法：**\n\n  除了 `scope` 只可以用于 `<template>` 元素，其它和 [`slot-scope`](#slot-scope) 都相同。\n\n## 内置的组件\n\n### component\n\n- **Props**：\n  - `is` - string | ComponentDefinition | ComponentConstructor\n  - `inline-template` - boolean\n\n- **用法**：\n\n  渲染一个“元组件”为动态组件。依 `is` 的值，来决定哪个组件被渲染。\n\n  ```html\n  <!-- 动态组件由 vm 实例的 `componentId` property 控制 -->\n  <component :is=\"componentId\"></component>\n\n  <!-- 也能够渲染注册过的组件或 prop 传入的组件 -->\n  <component :is=\"$options.components.child\"></component>\n  ```\n\n- **参考**：[动态组件](../guide/components.html#动态组件)\n\n### transition\n\n- **Props**：\n  - `name` - string，用于自动生成 CSS 过渡类名。例如：`name: 'fade'` 将自动拓展为 `.fade-enter`，`.fade-enter-active` 等。默认类名为 `\"v\"`\n  - `appear` - boolean，是否在初始渲染时使用过渡。默认为 `false`。\n  - `css` - boolean，是否使用 CSS 过渡类。默认为 `true`。如果设置为 `false`，将只通过组件事件触发注册的 JavaScript 钩子。\n  - `type` - string，指定过渡事件类型，侦听过渡何时结束。有效值为 `\"transition\"` 和 `\"animation\"`。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。\n  - `mode` - string，控制离开/进入过渡的时间序列。有效的模式有 `\"out-in\"` 和 `\"in-out\"`；默认同时进行。\n  - `duration` - number | { `enter`: number, `leave`: number } 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 `transitionend` 或 `animationend` 事件。\n  - `enter-class` - string\n  - `leave-class` - string\n  - `appear-class` - string\n  - `enter-to-class` - string\n  - `leave-to-class` - string\n  - `appear-to-class` - string\n  - `enter-active-class` - string\n  - `leave-active-class` - string\n  - `appear-active-class` - string\n\n- **事件**：\n  - `before-enter`\n  - `before-leave`\n  - `before-appear`\n  - `enter`\n  - `leave`\n  - `appear`\n  - `after-enter`\n  - `after-leave`\n  - `after-appear`\n  - `enter-cancelled`\n  - `leave-cancelled` (`v-show` only)\n  - `appear-cancelled`\n\n- **用法**：\n\n  `<transition>` 元素作为**单个**元素/组件的过渡效果。`<transition>` 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。\n\n  ```html\n  <!-- 简单元素 -->\n  <transition>\n    <div v-if=\"ok\">toggled content</div>\n  </transition>\n\n  <!-- 动态组件 -->\n  <transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </transition>\n\n  <!-- 事件钩子 -->\n  <div id=\"transition-demo\">\n    <transition @after-enter=\"transitionComplete\">\n      <div v-show=\"ok\">toggled content</div>\n    </transition>\n  </div>\n  ```\n\n  ``` js\n  new Vue({\n    ...\n    methods: {\n      transitionComplete: function (el) {\n        // 传入 'el' 这个 DOM 元素作为参数。\n      }\n    }\n    ...\n  }).$mount('#transition-demo')\n  ```\n\n- **参考**：[过渡：进入，离开和列表](../guide/transitions.html)\n\n### transition-group\n\n- **Props**：\n  - `tag` - string，默认为 `span`\n  - `move-class` - 覆盖移动过渡期间应用的 CSS 类。\n  - 除了 `mode`，其他 attribute 和 `<transition>` 相同。\n\n- **事件**：\n  - 事件和 `<transition>` 相同。\n\n- **用法**：\n\n  `<transition-group>` 元素作为多个元素/组件的过渡效果。`<transition-group>` 渲染一个真实的 DOM 元素。默认渲染 `<span>`，可以通过 `tag` attribute 配置哪个元素应该被渲染。\n\n  注意，每个 `<transition-group>` 的子节点必须有**独立的 key**，动画才能正常工作\n\n  `<transition-group>` 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它会被应用一个移动中的 CSS 类 (通过 `name` attribute 或配置 `move-class` attribute 自动生成)。如果 CSS `transform` property 是“可过渡”property，当应用移动类时，将会使用 [FLIP 技术](https://aerotwist.com/blog/flip-your-animations/)使元素流畅地到达动画终点。\n\n  ```html\n  <transition-group tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </transition-group>\n  ```\n\n- **参考**：[过渡：进入，离开和列表](../guide/transitions.html)\n\n### keep-alive\n\n- **Props**：\n  - `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存。\n  - `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。\n  - `max` - 数字。最多可以缓存多少组件实例。\n\n- **用法**：\n\n  `<keep-alive>` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 `<transition>` 相似，`<keep-alive>` 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。\n\n  当组件在 `<keep-alive>` 内被切换，它的 `activated` 和 `deactivated` 这两个生命周期钩子函数将会被对应执行。\n\n  > 在 2.2.0 及其更高版本中，`activated` 和 `deactivated` 将会在 `<keep-alive>` 树内的所有嵌套组件中触发。\n\n  主要用于保留组件状态或避免重新渲染。\n\n  ```html\n  <!-- 基本 -->\n  <keep-alive>\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- 多个条件判断的子组件 -->\n  <keep-alive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </keep-alive>\n\n  <!-- 和 `<transition>` 一起使用 -->\n  <transition>\n    <keep-alive>\n      <component :is=\"view\"></component>\n    </keep-alive>\n  </transition>\n  ```\n\n  注意，`<keep-alive>` 是用在其一个直属的子组件被开关的情形。如果你在其中有 `v-for` 则不会工作。如果有上述的多个条件性的子元素，`<keep-alive>` 要求同时只有一个子元素被渲染。\n\n- **`include` and `exclude`**\n\n  > 2.1.0 新增\n\n  `include` 和 `exclude` prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：\n\n  ``` html\n  <!-- 逗号分隔字符串 -->\n  <keep-alive include=\"a,b\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- 正则表达式 (使用 `v-bind`) -->\n  <keep-alive :include=\"/a|b/\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- 数组 (使用 `v-bind`) -->\n  <keep-alive :include=\"['a', 'b']\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n  ```\n\n  匹配首先检查组件自身的 `name` 选项，如果 `name` 选项不可用，则匹配它的局部注册名称 (父组件 `components` 选项的键值)。匿名组件不能被匹配。\n\n- **`max`**\n\n  > 2.5.0 新增\n\n  最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。\n\n  ``` html\n  <keep-alive :max=\"10\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n  ```\n\n  <p class=\"tip\">`<keep-alive>` 不会在函数式组件中正常工作，因为它们没有缓存实例。</p>\n\n- **参考**：[动态组件 - keep-alive](../guide/components-dynamic-async.html#在动态组件上使用-keep-alive)\n\n### slot\n\n- **Props**：\n  - `name` - string，用于命名插槽。\n\n- **Usage**：\n\n  `<slot>` 元素作为组件模板之中的内容分发插槽。`<slot>` 元素自身将被替换。\n\n  详细用法，请参考下面教程的链接。\n\n- **参考**：[通过插槽分发内容](../guide/components.html#通过插槽分发内容)\n\n## VNode 接口\n\n- 请参考 [VNode class declaration](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js)。\n\n## 服务端渲染\n\n- 请参考 [vue-server-renderer package documentation](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer)。\n\n<!-- zhlint ignore: { `enter`: number, `leave`: number } -->\n<!-- zhlint ignore: ( , ) -->\n<!-- zhlint ignore: vm.$destroy() -->\n<!-- zhlint ignore: vm.$forceUpdate() -->\n","source":"doc/api/index.md","raw":"---\ntitle: API\ntype: api\n---\n\n## 全局配置\n\n`Vue.config` 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property：\n\n### silent\n\n- **类型**：`boolean`\n\n- **默认值**：`false`\n\n- **用法**：\n\n  ``` js\n  Vue.config.silent = true\n  ```\n\n  取消 Vue 所有的日志与警告。\n\n### optionMergeStrategies\n\n- **类型**：`{ [key: string]: Function }`\n\n- **默认值**：`{}`\n\n- **用法**：\n\n  ``` js\n  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {\n    return child + 1\n  }\n\n  const Profile = Vue.extend({\n    _my_option: 1\n  })\n\n  // Profile.options._my_option = 2\n  ```\n\n  自定义合并策略的选项。\n\n  合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。\n\n- **参考**[自定义选项的混入策略](../guide/mixins.html#自定义选项混入策略)\n\n### devtools\n\n- **类型**：`boolean`\n\n- **默认值**：`true` (生产版为 `false`)\n\n- **用法**：\n\n  ``` js\n  // 务必在加载 Vue 之后，立即同步设置以下内容\n  Vue.config.devtools = true\n  ```\n\n  配置是否允许 [vue-devtools](https://github.com/vuejs/vue-devtools) 检查代码。开发版本默认为 `true`，生产版本默认为 `false`。生产版本设为 `true` 可以启用检查。\n\n### errorHandler\n\n- **类型**：`Function`\n\n- **默认值**：`undefined`\n\n- **用法**：\n\n  ``` js\n  Vue.config.errorHandler = function (err, vm, info) {\n    // handle error\n    // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子\n    // 只在 2.2.0+ 可用\n  }\n  ```\n\n  指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。\n\n  > 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 `undefined` 时，被捕获的错误会通过 `console.error` 输出而避免应用崩溃。\n\n  > 从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。\n\n  > 从 2.6.0 起，这个钩子也会捕获 `v-on` DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。\n\n  > 错误追踪服务 [Sentry](https://sentry.io) 和 [Bugsnag](https://docs.bugsnag.com/platforms/browsers/vue/) 都通过此选项提供了官方支持。\n\n### warnHandler\n\n> 2.4.0 新增\n\n- **类型**：`Function`\n\n- **默认值**：`undefined`\n\n- **用法**：\n\n  ``` js\n  Vue.config.warnHandler = function (msg, vm, trace) {\n    // `trace` 是组件的继承关系追踪\n  }\n  ```\n\n  为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。\n\n### ignoredElements\n\n- **类型**：`Array<string | RegExp>`\n\n- **默认值**：`[]`\n\n- **用法**：\n\n  ``` js\n  Vue.config.ignoredElements = [\n    'my-custom-web-component',\n    'another-web-component',\n    // 用一个 `RegExp` 忽略所有“ion-”开头的元素\n    // 仅在 2.5+ 支持\n    /^ion-/\n  ]\n  ```\n\n  须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 `Unknown custom element` 的警告。\n\n### keyCodes\n\n- **类型**：`{ [key: string]: number | Array<number> }`\n\n- **默认值**：`{}`\n\n- **用法**：\n\n  ``` js\n  Vue.config.keyCodes = {\n    v: 86,\n    f1: 112,\n    // camelCase 不可用\n    mediaPlayPause: 179,\n    // 取而代之的是 kebab-case 且用双引号括起来\n    \"media-play-pause\": 179,\n    up: [38, 87]\n  }\n  ```\n\n  ```html\n  <input type=\"text\" @keyup.media-play-pause=\"method\">\n  ```\n\n  给 `v-on` 自定义键位别名。\n\n### performance\n\n> 2.2.0 新增\n\n- **类型**：`boolean`\n\n- **默认值**：`false (自 2.2.3 起)`\n\n- **用法**：\n\n  设置为 `true` 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 [`performance.mark`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark) API 的浏览器上。\n  \n### productionTip\n\n> 2.2.0 新增\n\n- **类型**：`boolean`\n\n- **默认值**：`true`\n\n- **用法**：\n\n  设置为 `false` 以阻止 vue 在启动时生成生产提示。\n\n## 全局 API\n\n### Vue.extend( options )\n\n- **参数**：\n  - `{Object} options`\n\n- **用法**：\n\n  使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。\n\n  `data` 选项是特例，需要注意 - 在 `Vue.extend()` 中它必须是函数\n\n  ``` html\n  <div id=\"mount-point\"></div>\n  ```\n\n  ``` js\n  // 创建构造器\n  var Profile = Vue.extend({\n    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',\n    data: function () {\n      return {\n        firstName: 'Walter',\n        lastName: 'White',\n        alias: 'Heisenberg'\n      }\n    }\n  })\n  // 创建 Profile 实例，并挂载到一个元素上。\n  new Profile().$mount('#mount-point')\n  ```\n\n  结果如下：\n\n  ``` html\n  <p>Walter White aka Heisenberg</p>\n  ```\n\n- **参考**：[组件](../guide/components.html)\n\n### Vue.nextTick( [callback, context] )\n\n- **参数**：\n  - `{Function} [callback]`\n  - `{Object} [context]`\n\n- **用法**：\n\n  在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n\n  ``` js\n  // 修改数据\n  vm.msg = 'Hello'\n  // DOM 还没有更新\n  Vue.nextTick(function () {\n    // DOM 更新了\n  })\n\n  // 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)\n  Vue.nextTick()\n    .then(function () {\n      // DOM 更新了\n    })\n  ```\n\n  > 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。\n\n- **参考**：[异步更新队列](../guide/reactivity.html#异步更新队列)\n\n### Vue.set( target, propertyName/index, value )\n\n- **参数**：\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n  - `{any} value`\n\n- **返回值**：设置的值。\n\n- **用法**：\n\n  向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 `this.myObject.newProperty = 'hi'`)\n\n  <p class=\"tip\">注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</p>\n\n### Vue.delete( target, propertyName/index )\n\n- **参数**：\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n\n  > 仅在 2.2.0+ 版本中支持 Array + index 用法。\n\n- **用法**：\n\n  删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。\n\n  > 在 2.2.0+ 中同样支持在数组上工作。\n\n  <p class=\"tip\">目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。</p>\n\n- **参考**：[深入响应式原理](../guide/reactivity.html)\n\n### Vue.directive( id, [definition] )\n\n- **参数**：\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **用法**：\n\n  注册或获取全局指令。\n\n  ``` js\n  // 注册\n  Vue.directive('my-directive', {\n    bind: function () {},\n    inserted: function () {},\n    update: function () {},\n    componentUpdated: function () {},\n    unbind: function () {}\n  })\n\n  // 注册 (指令函数)\n  Vue.directive('my-directive', function () {\n    // 这里将会被 `bind` 和 `update` 调用\n  })\n\n  // getter，返回已注册的指令\n  var myDirective = Vue.directive('my-directive')\n  ```\n\n- **参考**：[自定义指令](../guide/custom-directive.html)\n\n### Vue.filter( id, [definition] )\n\n- **参数**：\n  - `{string} id`\n  - `{Function} [definition]`\n\n- **用法**：\n\n  注册或获取全局过滤器。\n\n  ``` js\n  // 注册\n  Vue.filter('my-filter', function (value) {\n    // 返回处理后的值\n  })\n\n  // getter，返回已注册的过滤器\n  var myFilter = Vue.filter('my-filter')\n  ```\n\n- **参考**：[过滤器](../guide/filters.html)\n\n### Vue.component( id, [definition] )\n\n- **参数**：\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **用法**：\n\n  注册或获取全局组件。注册还会自动使用给定的 `id` 设置组件的名称\n\n  ``` js\n  // 注册组件，传入一个扩展过的构造器\n  Vue.component('my-component', Vue.extend({ /* ... */ }))\n\n  // 注册组件，传入一个选项对象 (自动调用 Vue.extend)\n  Vue.component('my-component', { /* ... */ })\n\n  // 获取注册的组件 (始终返回构造器)\n  var MyComponent = Vue.component('my-component')\n  ```\n\n- **参考**：[组件](../guide/components.html)\n\n### Vue.use( plugin )\n\n- **参数**：\n  - `{Object | Function} plugin`\n\n- **用法**：\n\n  安装 Vue.js 插件。如果插件是一个对象，必须提供 `install` 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。\n\n  该方法需要在调用 `new Vue()` 之前被调用。\n\n  当 install 方法被同一个插件多次调用，插件将只会被安装一次。\n\n- **参考**：[插件](../guide/plugins.html)\n\n### Vue.mixin( mixin )\n\n- **参数**：\n  - `{Object} mixin`\n\n- **用法**：\n\n  全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。**不推荐在应用代码中使用**。\n\n- **参考**：[全局混入](../guide/mixins.html#全局混入)\n\n### Vue.compile( template )\n\n- **参数**：\n  - `{string} template`\n\n- **用法**：\n\n  将一个模板字符串编译成 render 函数。**只在完整版时可用**。\n\n  ``` js\n  var res = Vue.compile('<div><span>{{ msg }}</span></div>')\n\n  new Vue({\n    data: {\n      msg: 'hello'\n    },\n    render: res.render,\n    staticRenderFns: res.staticRenderFns\n  })\n  ```\n\n- **参考**：[渲染函数](../guide/render-function.html)\n\n### Vue.observable( object )\n\n> 2.6.0 新增\n\n- **参数**：\n  - `{Object} object`\n\n- **用法**：\n\n  让一个对象可响应。Vue 内部会用它来处理 `data` 函数返回的对象。\n\n  返回的对象可以直接用于[渲染函数](../guide/render-function.html)和[计算属性](../guide/computed.html)内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：\n\n  ``` js\n  const state = Vue.observable({ count: 0 })\n\n  const Demo = {\n    render(h) {\n      return h('button', {\n        on: { click: () => { state.count++ }}\n      }, `count is: ${state.count}`)\n    }\n  }\n  ```\n\n  <p class=\"tip\">在 Vue 2.x 中，被传入的对象会直接被 `Vue.observable` 变更，所以如[这里展示的](../guide/instance.html#数据与方法)，它和被返回的对象是同一个对象。在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的。因此，为了向前兼容，我们推荐始终操作使用 `Vue.observable` 返回的对象，而不是传入源对象。</p>\n\n- **参考**：[深入响应式原理](../guide/reactivity.html)\n\n### Vue.version\n\n- **细节**：提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。\n\n- **用法**：\n\n  ```js\n  var version = Number(Vue.version.split('.')[0])\n\n  if (version === 2) {\n    // Vue v2.x.x\n  } else if (version === 1) {\n    // Vue v1.x.x\n  } else {\n    // Unsupported versions of Vue\n  }\n  ```\n\n## 选项 / 数据\n\n### data\n\n- **类型**：`Object | Function`\n\n- **限制**：组件的定义只接受 `function`。\n\n- **详细**：\n\n  Vue 实例的数据对象。Vue 将会递归将 data 的 property 转换为 getter/setter，从而让 data 的 property 能够响应数据变化。**对象必须是纯粹的对象 (含有零个或多个的 key/value 对)**：浏览器 API 创建的原生对象，原型上的 property 会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。\n\n  一旦观察过，你就无法在根数据对象上添加响应式 property。因此推荐在创建实例之前，就声明所有的根级响应式 property。\n\n  实例创建之后，可以通过 `vm.$data` 访问原始数据对象。Vue 实例也代理了 data 对象上所有的 property，因此访问 `vm.a` 等价于访问 `vm.$data.a`。\n\n  以 `_` 或 `$` 开头的 property **不会**被 Vue 实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突。你可以使用例如 `vm.$data._property` 的方式访问这些 property。\n\n  当一个**组件**被定义，`data` 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 `data` 仍然是一个纯粹的对象，则所有的实例将**共享引用**同一个数据对象！通过提供 `data` 函数，每次创建一个新实例后，我们能够调用 `data` 函数，从而返回初始数据的一个全新副本数据对象。\n\n 如果需要，可以通过将 `vm.$data` 传入 `JSON.parse(JSON.stringify(...))` 得到深拷贝的原始数据对象。\n\n- **示例**：\n\n  ``` js\n  var data = { a: 1 }\n\n  // 直接创建一个实例\n  var vm = new Vue({\n    data: data\n  })\n  vm.a // => 1\n  vm.$data === data // => true\n\n  // Vue.extend() 中 data 必须是函数\n  var Component = Vue.extend({\n    data: function () {\n      return { a: 1 }\n    }\n  })\n  ```\n\n  注意，如果你为 `data` property 使用了箭头函数，则 `this` 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。\n\n  ```js\n  data: vm => ({ a: vm.myProp })\n  ```\n\n- **参考**：[深入响应式原理](../guide/reactivity.html)\n\n### props\n\n- **类型**：`Array<string> | Object`\n\n- **详细**：\n\n  props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。\n\n  你可以基于对象的语法使用以下选项：\n    - `type`：可以是下列原生构造函数中的一种：`String`、`Number`、`Boolean`、`Array`、`Object`、`Date`、`Function`、`Symbol`、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的[更多信息在此](../guide/components-props.html#Prop-类型)。\n    - `default`：`any`\n    为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。\n    - `required`：`Boolean`\n    定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。\n    - `validator`：`Function`\n    自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在[这里](../guide/components-props.html#Prop-验证)查阅更多 prop 验证的相关信息。\n\n- **示例**：\n\n  ``` js\n  // 简单语法\n  Vue.component('props-demo-simple', {\n    props: ['size', 'myMessage']\n  })\n\n  // 对象语法，提供验证\n  Vue.component('props-demo-advanced', {\n    props: {\n      // 检测类型\n      height: Number,\n      // 检测类型 + 其他验证\n      age: {\n        type: Number,\n        default: 0,\n        required: true,\n        validator: function (value) {\n          return value >= 0\n        }\n      }\n    }\n  })\n  ```\n\n- **参考**：[Props](../guide/components-props.html)\n\n### propsData\n\n- **类型**：`{ [key: string]: any }`\n\n- **限制**：只用于 `new` 创建的实例中。\n\n- **详细**：\n\n  创建实例时传递 props。主要作用是方便测试。\n\n- **示例**：\n\n  ``` js\n  var Comp = Vue.extend({\n    props: ['msg'],\n    template: '<div>{{ msg }}</div>'\n  })\n\n  var vm = new Comp({\n    propsData: {\n      msg: 'hello'\n    }\n  })\n  ```\n\n### computed\n\n- **类型**：`{ [key: string]: Function | { get: Function, set: Function } }`\n\n- **详细**：\n\n  计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。\n\n  注意如果你为一个计算属性使用了箭头函数，则 `this` 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。\n\n  ```js\n  computed: {\n    aDouble: vm => vm.a * 2\n  }\n  ```\n\n  计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是**不会**被更新的。\n\n- **示例**：\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    computed: {\n      // 仅读取\n      aDouble: function () {\n        return this.a * 2\n      },\n      // 读取和设置\n      aPlus: {\n        get: function () {\n          return this.a + 1\n        },\n        set: function (v) {\n          this.a = v - 1\n        }\n      }\n    }\n  })\n  vm.aPlus   // => 2\n  vm.aPlus = 3\n  vm.a       // => 2\n  vm.aDouble // => 4\n  ```\n\n- **参考**：[计算属性](../guide/computed.html)\n\n### methods\n\n- **类型**：`{ [key: string]: Function }`\n\n- **详细**：\n\n  methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 `this` 自动绑定为 Vue 实例。\n\n  <p class=\"tip\">注意，**不应该使用箭头函数来定义 method 函数** (例如 `plus: () => this.a++`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.a` 将是 undefined。</p>\n\n- **示例**：\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    methods: {\n      plus: function () {\n        this.a++\n      }\n    }\n  })\n  vm.plus()\n  vm.a // 2\n  ```\n\n- **参考**：[事件处理器](../guide/events.html)\n\n### watch\n\n- **类型**：`{ [key: string]: string | Function | Object | Array }`\n\n- **详细**：\n\n  一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 `$watch()`，遍历 watch 对象的每一个 property。\n\n- **示例**：\n\n  ``` js\n  var vm = new Vue({\n    data: {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: {\n        f: {\n          g: 5\n        }\n      }\n    },\n    watch: {\n      a: function (val, oldVal) {\n        console.log('new: %s, old: %s', val, oldVal)\n      },\n      // 方法名\n      b: 'someMethod',\n      // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深\n      c: {\n        handler: function (val, oldVal) { /* ... */ },\n        deep: true\n      },\n      // 该回调将会在侦听开始之后被立即调用\n      d: {\n        handler: 'someMethod',\n        immediate: true\n      },\n      // 你可以传入回调数组，它们会被逐一调用\n      e: [\n        'handle1',\n        function handle2 (val, oldVal) { /* ... */ },\n        {\n          handler: function handle3 (val, oldVal) { /* ... */ },\n          /* ... */\n        }\n      ],\n      // watch vm.e.f's value: {g: 5}\n      'e.f': function (val, oldVal) { /* ... */ }\n    }\n  })\n  vm.a = 2 // => new: 2, old: 1\n  ```\n\n  <p class=\"tip\">注意，**不应该使用箭头函数来定义 watcher 函数** (例如 `searchQuery: newValue => this.updateAutocomplete(newValue)`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.updateAutocomplete` 将是 undefined。</p>\n\n- **参考**：[实例方法 / 数据 - vm.$watch](#vm-watch)\n\n## 选项 / DOM\n\n### el\n\n- **类型**：`string | Element`\n\n- **限制**：只在用 `new` 创建实例时生效。\n\n- **详细**：\n\n  提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。\n\n  在实例挂载之后，元素可以用 `vm.$el` 访问。\n\n  如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 `vm.$mount()` 手动开启编译。\n\n  <p class=\"tip\"> 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载 root 实例到 `<html>` 或者 `<body>` 上。</p>\n\n  <p class=\"tip\">如果 `render` 函数和 `template` property 都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。</p>\n\n- **参考**：\n  - [生命周期图示](../guide/instance.html#生命周期图示)\n  - [运行时 + 编译器 vs. 只包含运行时](../guide/installation.html#运行时-编译器-vs-只包含运行时)\n\n### template\n\n- **类型**：`string`\n\n- **详细**：\n\n  一个字符串模板作为 Vue 实例的标识使用。模板将会**替换**挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。\n\n  如果值以 `#` 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 `<script type=\"x-template\">` 包含模板。\n\n  <p class=\"tip\">出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。</p>\n\n  <p class=\"tip\">如果 Vue 选项中包含渲染函数，该模板将被忽略。</p>\n\n- **参考**：\n  - [生命周期图示](../guide/instance.html#生命周期图示)\n  - [通过插槽分发内容](../guide/components.html#通过插槽分发内容)\n\n### render\n\n  - **类型**：`(createElement: () => VNode) => VNode`\n\n  - **详细**：\n\n    字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 `createElement` 方法作为第一个参数用来创建 `VNode`。\n\n    如果组件是一个函数组件，渲染函数还会接收一个额外的 `context` 参数，为没有实例的函数组件提供上下文信息。\n\n    <p class=\"tip\">Vue 选项中的 `render` 函数若存在，则 Vue 构造函数不会从 `template` 选项或通过 `el` 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。</p>\n\n  - **参考**：[渲染函数](../guide/render-function.html)\n\n### renderError\n\n> 2.2.0 新增\n\n  - **类型**：`(createElement: () => VNode, error: Error) => VNode`\n\n  - **详细**：\n\n    **只在开发者环境下工作。**\n\n    当 `render` 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 `renderError`。这个功能配合 hot-reload 非常实用。\n\n  - **示例**：\n\n    ``` js\n    new Vue({\n      render (h) {\n        throw new Error('oops')\n      },\n      renderError (h, err) {\n        return h('pre', { style: { color: 'red' }}, err.stack)\n      }\n    }).$mount('#app')\n    ```\n\n  - **参考**：[渲染函数](../guide/render-function.html)\n\n## 选项 / 生命周期钩子\n\n<p class=\"tip\">所有的生命周期钩子自动绑定 `this` 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。这意味着**你不能使用箭头函数来定义一个生命周期方法** (例如 `created: () => this.fetchTodos()`)。这是因为箭头函数绑定了父上下文，因此 `this` 与你期待的 Vue 实例不同，`this.fetchTodos` 的行为未定义。</p>\n\n### beforeCreate\n\n- **类型**：`Function`\n\n- **详细**：\n\n  在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### created\n\n- **类型**：`Function`\n\n- **详细**：\n\n  在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，`$el` property 目前尚不可用。\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### beforeMount\n\n- **类型**：`Function`\n\n- **详细**：\n\n  在挂载开始之前被调用：相关的 `render` 函数首次被调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### mounted\n\n- **类型**：`Function`\n\n- **详细**：\n\n  实例被挂载后调用，这时 `el` 被新创建的 `vm.$el` 替换了。如果根实例挂载到了一个文档内的元素上，当 `mounted` 被调用时 `vm.$el` 也在文档内。\n\n  注意 `mounted` **不会**保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 `mounted` 内部使用 [vm.$nextTick](#vm-nextTick)：\n\n  ``` js\n  mounted: function () {\n    this.$nextTick(function () {\n      // Code that will run only after the\n      // entire view has been rendered\n    })\n  }\n  ```\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### beforeUpdate\n\n- **类型**：`Function`\n\n- **详细**：\n\n  数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。\n\n  **该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### updated\n\n- **类型**：`Function`\n\n- **详细**：\n\n  由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。\n\n  当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用[计算属性](#computed)或 [watcher](#watch) 取而代之。\n\n  注意 `updated` **不会**保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 `updated` 里使用 [vm.$nextTick](#vm-nextTick)：\n\n  ``` js\n  updated: function () {\n    this.$nextTick(function () {\n      // Code that will run only after the\n      // entire view has been re-rendered\n    })\n  }\n  ```\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### activated\n\n- **类型**：`Function`\n\n- **详细**：\n\n  被 keep-alive 缓存的组件激活时调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：\n  - [构建组件 - keep-alive](#keep-alive)\n  - [动态组件 - keep-alive](../guide/components-dynamic-async.html#在动态组件上使用-keep-alive)\n\n### deactivated\n\n- **类型**：`Function`\n\n- **详细**：\n\n  被 keep-alive 缓存的组件停用时调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：\n  - [构建组件 - keep-alive](#keep-alive)\n  - [动态组件 - keep-alive](../guide/components-dynamic-async.html#在动态组件上使用-keep-alive)\n\n### beforeDestroy\n\n- **类型**：`Function`\n\n- **详细**：\n\n  实例销毁之前调用。在这一步，实例仍然完全可用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### destroyed\n\n- **类型**：`Function`\n\n- **详细**：\n\n  实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。\n\n  **该钩子在服务器端渲染期间不被调用。**\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n### errorCaptured\n\n> 2.5.0+ 新增\n\n- **类型**：`(err: Error, vm: Component, info: string) => ?boolean`\n\n- **详细**：\n\n  当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 `false` 以阻止该错误继续向上传播。\n\n  <p class=\"tip\">你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p>\n\n  **错误传播规则**\n\n  - 默认情况下，如果全局的 `config.errorHandler` 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。\n\n  - 如果一个组件的继承或父级从属链路中存在多个 `errorCaptured` 钩子，则它们将会被相同的错误逐个唤起。\n\n  - 如果此 `errorCaptured` 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 `config.errorHandler`。\n\n  - 一个 `errorCaptured` 钩子能够返回 `false` 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 `errorCaptured` 钩子和全局的 `config.errorHandler`。\n\n## 选项 / 资源\n\n### directives\n\n- **类型**：`Object`\n\n- **详细**：\n\n包含 Vue 实例可用指令的哈希表。\n\n- **参考**：[自定义指令](../guide/custom-directive.html)\n\n### filters\n\n- **类型**：`Object`\n\n- **详细**：\n\n包含 Vue 实例可用过滤器的哈希表。\n\n- **参考**：[`Vue.filter`](#Vue-filter)\n\n### components\n\n- **类型**：`Object`\n\n- **详细**：\n\n包含 Vue 实例可用组件的哈希表。\n\n- **参考**：[组件](../guide/components.html)\n\n## 选项 / 组合\n\n### parent\n\n- **类型**：`Vue instance`\n\n- **详细**：\n\n  指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 `this.$parent` 访问父实例，子实例被推入父实例的 `$children` 数组中。\n\n  <p class=\"tip\">节制地使用 `$parent` 和 `$children` - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信</p>\n\n### mixins\n\n- **类型**：`Array<Object>`\n\n- **详细**：\n\n  `mixins` 选项接收一个混入对象的数组。这些混入对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用的是和 `Vue.extend()` 一样的选项合并逻辑。也就是说，如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。\n\n  Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。\n\n- **示例**：\n\n  ``` js\n  var mixin = {\n    created: function () { console.log(1) }\n  }\n  var vm = new Vue({\n    created: function () { console.log(2) },\n    mixins: [mixin]\n  })\n  // => 1\n  // => 2\n  ```\n\n- **参考**：[混入](../guide/mixins.html)\n\n### extends\n\n- **类型**：`Object | Function`\n\n- **详细**：\n\n  允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 `Vue.extend`。这主要是为了便于扩展单文件组件。\n\n  这和 `mixins` 类似。\n\n- **示例**：\n\n  ``` js\n  var CompA = { ... }\n\n  // 在没有调用 `Vue.extend` 时候继承 CompA\n  var CompB = {\n    extends: CompA,\n    ...\n  }\n  ```\n\n### provide / inject\n\n> 2.2.0 新增\n\n- **类型**：\n  - **provide**：`Object | () => Object`\n  - **inject**：`Array<string> | { [key: string]: string | Symbol | Object }`\n\n- **详细**：\n\n  <p class=\"tip\">`provide` 和 `inject` 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。</p>\n\n  这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。\n\n  `provide` 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 `Symbol` 和 `Reflect.ownKeys` 的环境下可工作。\n\n  `inject` 选项应该是：\n  - 一个字符串数组，或\n  - 一个对象，对象的 key 是本地的绑定名，value 是：\n    - 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或\n    - 一个对象，该对象的：\n      - `from` property 是在可用的注入内容中搜索用的 key (字符串或 Symbol)\n      - `default` property 是降级情况下使用的 value\n\n  > 提示：`provide` 和 `inject` 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。\n\n- **示例**：\n\n  ``` js\n  // 父级组件提供 'foo'\n  var Provider = {\n    provide: {\n      foo: 'bar'\n    },\n    // ...\n  }\n\n  // 子组件注入 'foo'\n  var Child = {\n    inject: ['foo'],\n    created () {\n      console.log(this.foo) // => \"bar\"\n    }\n    // ...\n  }\n  ```\n\n  利用 ES2015 Symbols、函数 `provide` 和对象 `inject`：\n\n  ``` js\n  const s = Symbol()\n\n  const Provider = {\n    provide () {\n      return {\n        [s]: 'foo'\n      }\n    }\n  }\n\n  const Child = {\n    inject: { s },\n    // ...\n  }\n  ```\n\n  > 接下来 2 个例子只工作在 Vue 2.2.1 或更高版本。低于这个版本时，注入的值会在 `props` 和 `data` 初始化之后得到。\n\n  使用一个注入的值作为一个 property 的默认值：\n\n  ```js\n  const Child = {\n    inject: ['foo'],\n    props: {\n      bar: {\n        default () {\n          return this.foo\n        }\n      }\n    }\n  }\n  ```\n\n  使用一个注入的值作为数据入口：\n\n  ```js\n  const Child = {\n    inject: ['foo'],\n    data () {\n      return {\n        bar: this.foo\n      }\n    }\n  }\n  ```\n\n  > 在 2.5.0+ 的注入可以通过设置默认值使其变成可选项：\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: { default: 'foo' }\n    }\n  }\n  ```\n\n  如果它需要从一个不同名字的 property 注入，则使用 `from` 来表示其源 property：\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: {\n        from: 'bar',\n        default: 'foo'\n      }\n    }\n  }\n  ```\n\n  与 prop 的默认值类似，你需要对非原始值使用一个工厂方法：\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: {\n        from: 'bar',\n        default: () => [1, 2, 3]\n      }\n    }\n  }\n  ```\n\n## 选项 / 其它\n\n### name\n\n- **类型**：`string`\n\n- **限制**：只有作为组件选项时起作用。\n\n- **详细**：\n\n  允许组件模板递归地调用自身。注意，组件在全局用 `Vue.component()` 注册时，全局 ID 自动作为组件的 name。\n\n  指定 `name` 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 [vue-devtools](https://github.com/vuejs/vue-devtools)，未命名组件将显示成 `<AnonymousComponent>`，这很没有语义。通过提供 `name` 选项，可以获得更有语义信息的组件树。\n\n### delimiters\n\n- **类型**：`Array<string>`\n\n- **默认值**：`{% raw %}[\"{{\", \"}}\"]{% endraw %}`\n\n- **限制**：这个选项只在完整构建版本中的浏览器内编译时可用。\n\n- **详细**：\n\n 改变纯文本插入分隔符。\n\n- **示例**：\n\n  ``` js\n  new Vue({\n    delimiters: ['${', '}']\n  })\n\n  // 分隔符变成了 ES6 模板字符串的风格\n  ```\n\n### functional\n\n- **类型**：`boolean`\n\n- **详细**：\n\n  使组件无状态 (没有 `data`) 和无实例 (没有 `this` 上下文)。他们用一个简单的 `render` 函数返回虚拟节点使它们渲染的代价更小。\n\n- **参考**：[函数式组件](../guide/render-function.html#函数式组件)\n\n### model\n\n> 2.2.0 新增\n\n- **类型**：`{ prop?: string, event?: string }`\n\n- **详细**：\n\n  允许一个自定义组件在使用 `v-model` 时定制 prop 和 event。默认情况下，一个组件上的 `v-model` 会把 `value` 用作 prop 且把 `input` 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 `value` prop 来达到不同的目的。使用 `model` 选项可以回避这些情况产生的冲突。\n\n- **Example**：\n\n  ``` js\n  Vue.component('my-checkbox', {\n    model: {\n      prop: 'checked',\n      event: 'change'\n    },\n    props: {\n      // this allows using the `value` prop for a different purpose\n      value: String,\n      // use `checked` as the prop which take the place of `value`\n      checked: {\n        type: Number,\n        default: 0\n      }\n    },\n    // ...\n  })\n  ```\n\n  ``` html\n  <my-checkbox v-model=\"foo\" value=\"some value\"></my-checkbox>\n  ```\n\n  上述代码相当于：\n\n  ``` html\n  <my-checkbox\n    :checked=\"foo\"\n    @change=\"val => { foo = val }\"\n    value=\"some value\">\n  </my-checkbox>\n  ```\n\n### inheritAttrs\n\n> 2.4.0 新增\n\n- **类型**：`boolean`\n\n- **默认值**：`true`\n\n- **详细**：\n\n  默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 `inheritAttrs` 到 `false`，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例 property `$attrs` 可以让这些 attribute 生效，且可以通过 `v-bind` 显性的绑定到非根元素上。\n\n  注意：这个选项**不影响** `class` 和 `style` 绑定。\n\n### comments\n\n> 2.4.0 新增\n\n- **类型**：`boolean`\n\n- **默认值**：`false`\n\n- **限制**：这个选项只在完整构建版本中的浏览器内编译时可用。\n\n- **详细**：\n\n  当设为 `true` 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。\n\n## 实例 property\n\n### vm.$data\n\n- **类型**：`Object`\n\n- **详细**：\n\n  Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象 property 的访问。\n\n- **参考**：[选项 / 数据 - data](#data)\n\n### vm.$props\n\n> 2.2.0 新增\n\n- **类型**：`Object`\n\n- **详细**：\n\n  当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象 property 的访问。\n\n### vm.$el\n\n- **类型**：`Element`\n\n- **只读**\n\n- **详细**：\n\n  Vue 实例使用的根 DOM 元素。\n\n### vm.$options\n\n- **类型**：`Object`\n\n- **只读**\n\n- **详细**：\n\n  用于当前 Vue 实例的初始化选项。需要在选项中包含自定义 property 时会有用处：\n\n  ``` js\n  new Vue({\n    customOption: 'foo',\n    created: function () {\n      console.log(this.$options.customOption) // => 'foo'\n    }\n  })\n  ```\n\n### vm.$parent\n\n- **类型**：`Vue instance`\n\n- **只读**\n\n- **详细**：\n\n  父实例，如果当前实例有的话。\n\n### vm.$root\n\n- **类型**：`Vue instance`\n\n- **只读**\n\n- **详细**：\n\n  当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。\n\n### vm.$children\n\n- **类型**：`Array<Vue instance>`\n\n- **只读**\n\n- **详细**：\n\n  当前实例的直接子组件。**需要注意 `$children` 并不保证顺序，也不是响应式的。**如果你发现自己正在尝试使用 `$children` 来进行数据绑定，考虑使用一个数组配合 `v-for` 来生成子组件，并且使用 Array 作为真正的来源。\n\n### vm.$slots\n\n- **类型**：`{ [name: string]: ?Array<VNode> }`\n\n- **只读**\n\n- **详细**：\n\n  用来访问被[插槽分发](../guide/components.html#通过插槽分发内容)的内容。每个[具名插槽](../guide/components-slots.html#具名插槽)有其相应的 property (例如：`v-slot:foo` 中的内容将会在 `vm.$slots.foo` 中被找到)。`default` property 包括了所有没有被包含在具名插槽中的节点，或 `v-slot:default` 的内容。\n\n  **注意：**`v-slot:foo` 在 2.6 以上的版本才支持。对于之前的版本，你可以使用[废弃了的语法](../guide/components-slots.html#废弃了的语法)。\n\n  在使用[渲染函数](../guide/render-function.html)书写一个组件时，访问 `vm.$slots` 最有帮助。\n\n- **示例**：\n\n  ```html\n  <blog-post>\n    <template v-slot:header>\n      <h1>About Me</h1>\n    </template>\n\n    <p>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.</p>\n\n    <template v-slot:footer>\n      <p>Copyright 2016 Evan You</p>\n    </template>\n\n    <p>If I have some content down here, it will also be included in vm.$slots.default.</p>.\n  </blog-post>\n  ```\n\n  ```js\n  Vue.component('blog-post', {\n    render: function (createElement) {\n      var header = this.$slots.header\n      var body   = this.$slots.default\n      var footer = this.$slots.footer\n      return createElement('div', [\n        createElement('header', header),\n        createElement('main', body),\n        createElement('footer', footer)\n      ])\n    }\n  })\n  ```\n\n- **参考**：\n  - [`<slot>` 组件](#slot)\n  - [通过插槽分发内容](../guide/components.html#通过插槽分发内容)\n  - [渲染函数 - 插槽](../guide/render-function.html#插槽)\n\n### vm.$scopedSlots\n\n> 2.1.0 新增\n\n- **类型**：`{ [name: string]: props => Array<VNode> | undefined }`\n\n- **只读**\n\n- **详细**：\n\n  用来访问[作用域插槽](../guide/components-slots.html#作用域插槽)。对于包括 `默认 slot` 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。\n\n  `vm.$scopedSlots` 在使用[渲染函数](../guide/render-function.html)开发一个组件时特别有用。\n\n  **注意**：从 2.6.0 开始，这个 property 有两个变化：\n\n  1. 作用域插槽函数现在保证返回一个 VNode 数组，除非在返回值无效的情况下返回 `undefined`。\n\n  2. 所有的 `$slots` 现在都会作为函数暴露在 `$scopedSlots` 中。如果你在使用渲染函数，不论当前插槽是否带有作用域，我们都推荐始终通过 `$scopedSlots` 访问它们。这不仅仅使得在未来添加作用域变得简单，也可以让你最终轻松迁移到所有插槽都是函数的 Vue 3。\n\n- **参考**：\n  - [`<slot>` 组件](#slot)\n  - [作用域插槽](../guide/components-slots.html#作用域插槽)\n  - [渲染函数 - 插槽](../guide/render-function.html#插槽)\n\n### vm.$refs\n\n- **类型**：`Object`\n\n- **只读**\n\n- **详细**：\n\n  一个对象，持有注册过 [`ref` attribute](#ref) 的所有 DOM 元素和组件实例。\n\n- **参考**：\n  - [子组件 ref](../guide/components-edge-cases.html#访问子组件实例或子元素)\n  - [特殊 attribute - ref](#ref)\n\n### vm.$isServer\n\n- **类型**：`boolean`\n\n- **只读**\n\n- **详细**：\n\n  当前 Vue 实例是否运行于服务器。\n\n- **参考**：[服务端渲染](../guide/ssr.html)\n\n### vm.$attrs\n\n> 2.4.0 新增\n\n- **类型**：`{ [key: string]: string }`\n\n- **只读**\n\n- **详细**：\n\n  包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (`class` 和 `style` 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (`class` 和 `style` 除外)，并且可以通过 `v-bind=\"$attrs\"` 传入内部组件——在创建高级别的组件时非常有用。\n\n### vm.$listeners\n\n> 2.4.0 新增\n\n- **类型**：`{ [key: string]: Function | Array<Function> }`\n\n- **只读**\n\n- **详细**：\n\n  包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on=\"$listeners\"` 传入内部组件——在创建更高层次的组件时非常有用。\n\n## 实例方法 / 数据\n\n### vm.$watch( expOrFn, callback, [options] )\n\n- **参数**：\n  - `{string | Function} expOrFn`\n  - `{Function | Object} callback`\n  - `{Object} [options]`\n    - `{boolean} deep`\n    - `{boolean} immediate`\n\n- **返回值**：`{Function} unwatch`\n\n- **用法**：\n\n  观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代。\n\n  <p class=\"tip\">注意：在变更 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变更之前值的副本。</p>\n\n- **示例**：\n\n  ``` js\n  // 键路径\n  vm.$watch('a.b.c', function (newVal, oldVal) {\n    // 做点什么\n  })\n\n  // 函数\n  vm.$watch(\n    function () {\n      // 表达式 `this.a + this.b` 每次得出一个不同的结果时\n      // 处理函数都会被调用。\n      // 这就像监听一个未被定义的计算属性\n      return this.a + this.b\n    },\n    function (newVal, oldVal) {\n      // 做点什么\n    }\n  )\n  ```\n\n  `vm.$watch` 返回一个取消观察函数，用来停止触发回调：\n\n  ``` js\n  var unwatch = vm.$watch('a', cb)\n  // 之后取消观察\n  unwatch()\n  ```\n\n- **选项：deep**\n\n  为了发现对象内部值的变化，可以在选项参数中指定 `deep: true`。注意监听数组的变更不需要这么做。\n\n  ``` js\n  vm.$watch('someObject', callback, {\n    deep: true\n  })\n  vm.someObject.nestedValue = 123\n  // callback is fired\n  ```\n\n- **选项：immediate**\n\n  在选项参数中指定 `immediate: true` 将立即以表达式的当前值触发回调：\n\n  ``` js\n  vm.$watch('a', callback, {\n    immediate: true\n  })\n  // 立即以 `a` 的当前值触发回调\n  ```\n\n  注意在带有 `immediate` 选项时，你不能在第一次回调时取消侦听给定的 property。\n\n  ``` js\n  // 这会导致报错\n  var unwatch = vm.$watch(\n    'value',\n    function () {\n      doSomething()\n      unwatch()\n    },\n    { immediate: true }\n  )\n  ```\n\n  如果你仍然希望在回调内部调用一个取消侦听的函数，你应该先检查其函数的可用性：\n\n  ``` js\n  var unwatch = vm.$watch(\n    'value',\n    function () {\n      doSomething()\n      if (unwatch) {\n        unwatch()\n      }\n    },\n    { immediate: true }\n  )\n  ```\n\n### vm.$set( target, propertyName/index, value )\n\n- **参数**：\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n  - `{any} value`\n\n- **返回值**：设置的值。\n\n- **用法**：\n\n  这是全局 `Vue.set` 的**别名**。\n\n- **参考**：[Vue.set](#Vue-set)\n\n### vm.$delete( target, propertyName/index )\n\n- **参数**：\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n\n- **用法**：\n\n  这是全局 `Vue.delete` 的**别名**。\n\n- **参考**：[Vue.delete](#Vue-delete)\n\n## 实例方法 / 事件\n\n### vm.$on( event, callback )\n\n- **参数**：\n  - `{string | Array<string>} event` (数组只在 2.2.0+ 中支持)\n  - `{Function} callback`\n\n- **用法**：\n\n  监听当前实例上的自定义事件。事件可以由 `vm.$emit` 触发。回调函数会接收所有传入事件触发函数的额外参数。\n\n- **示例**：\n\n  ``` js\n  vm.$on('test', function (msg) {\n    console.log(msg)\n  })\n  vm.$emit('test', 'hi')\n  // => \"hi\"\n  ```\n\n### vm.$once( event, callback )\n\n- **参数**：\n  - `{string} event`\n  - `{Function} callback`\n\n- **用法**：\n\n  监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。\n\n### vm.$off( [event, callback] )\n\n- **参数**：\n  - `{string | Array<string>} event` (只在 2.2.2+ 支持数组)\n  - `{Function} [callback]`\n\n- **用法**：\n\n  移除自定义事件监听器。\n\n  - 如果没有提供参数，则移除所有的事件监听器；\n\n  - 如果只提供了事件，则移除该事件所有的监听器；\n\n  - 如果同时提供了事件与回调，则只移除这个回调的监听器。\n\n### vm.$emit( eventName, [...args] )\n\n- **参数**：\n  - `{string} eventName`\n  - `[...args]`\n\n  触发当前实例上的事件。附加参数都会传给监听器回调。\n\n- **示例：**\n\n  只配合一个事件名使用 `$emit`：\n\n  ```js\n  Vue.component('welcome-button', {\n    template: `\n      <button v-on:click=\"$emit('welcome')\">\n        Click me to be welcomed\n      </button>\n    `\n  })\n  ```\n\n  ```html\n  <div id=\"emit-example-simple\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  ```\n\n  ```js\n  new Vue({\n    el: '#emit-example-simple',\n    methods: {\n      sayHi: function () {\n        alert('Hi!')\n      }\n    }\n  })\n  ```\n\n  {% raw %}\n  <div id=\"emit-example-simple\" class=\"demo\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  <script>\n    Vue.component('welcome-button', {\n      template: `\n        <button v-on:click=\"$emit('welcome')\">\n          Click me to be welcomed\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-simple',\n      methods: {\n        sayHi: function () {\n          alert('Hi!')\n        }\n      }\n    })\n  </script>\n  {% endraw %}\n\n  配合额外的参数使用 `$emit`：\n\n  ```js\n  Vue.component('magic-eight-ball', {\n    data: function () {\n      return {\n        possibleAdvice: ['Yes', 'No', 'Maybe']\n      }\n    },\n    methods: {\n      giveAdvice: function () {\n        var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n        this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n      }\n    },\n    template: `\n      <button v-on:click=\"giveAdvice\">\n        Click me for advice\n      </button>\n    `\n  })\n  ```\n\n  ```html\n  <div id=\"emit-example-argument\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  ```\n\n  ```js\n  new Vue({\n    el: '#emit-example-argument',\n    methods: {\n      showAdvice: function (advice) {\n        alert(advice)\n      }\n    }\n  })\n  ```\n\n  {% raw %}\n  <div id=\"emit-example-argument\" class=\"demo\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  <script>\n    Vue.component('magic-eight-ball', {\n      data: function () {\n        return {\n          possibleAdvice: ['Yes', 'No', 'Maybe']\n        }\n      },\n      methods: {\n        giveAdvice: function () {\n          var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n          this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n        }\n      },\n      template: `\n        <button v-on:click=\"giveAdvice\">\n          Click me for advice\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-argument',\n      methods: {\n        showAdvice: function (advice) {\n          alert(advice)\n        }\n      }\n    })\n  </script>\n  {% endraw %}\n\n## 实例方法 / 生命周期\n\n### vm.$mount( [elementOrSelector] )\n\n- **参数**：\n  - `{Element | string} [elementOrSelector]`\n  - `{boolean} [hydrating]`\n\n- **返回值**：`vm` - 实例自身\n\n- **用法**：\n\n  如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 `vm.$mount()` 手动地挂载一个未挂载的实例。\n\n  如果没有提供 `elementOrSelector` 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。\n\n  这个方法返回实例自身，因而可以链式调用其它实例方法。\n\n- **示例**：\n\n  ``` js\n  var MyComponent = Vue.extend({\n    template: '<div>Hello!</div>'\n  })\n\n  // 创建并挂载到 #app (会替换 #app)\n  new MyComponent().$mount('#app')\n\n  // 同上\n  new MyComponent({ el: '#app' })\n\n  // 或者，在文档之外渲染并且随后挂载\n  var component = new MyComponent().$mount()\n  document.getElementById('app').appendChild(component.$el)\n  ```\n\n- **参考**：\n  - [生命周期图示](../guide/instance.html#生命周期图示)\n  - [服务端渲染](../guide/ssr.html)\n\n### vm.$forceUpdate()\n\n- **示例**：\n\n  迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。\n\n### vm.$nextTick( [callback] )\n\n- **参数**：\n  - `{Function} [callback]`\n\n- **用法**：\n\n  将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 `Vue.nextTick` 一样，不同的是回调的 `this` 自动绑定到调用它的实例上。\n\n  > 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise (IE：你们都看我干嘛)，你得自行 polyfill。\n\n- **示例**：\n\n  ``` js\n  new Vue({\n    // ...\n    methods: {\n      // ...\n      example: function () {\n        // 修改数据\n        this.message = 'changed'\n        // DOM 还没有更新\n        this.$nextTick(function () {\n          // DOM 现在更新了\n          // `this` 绑定到当前实例\n          this.doSomethingElse()\n        })\n      }\n    }\n  })\n  ```\n\n- **参考**\n  - [Vue.nextTick](#Vue-nextTick)\n  - [异步更新队列](../guide/reactivity.html#异步更新队列)\n\n### vm.$destroy()\n\n- **用法**：\n\n  完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。\n\n  触发 `beforeDestroy` 和 `destroyed` 的钩子。\n\n  <p class=\"tip\">在大多数场景中你不应该调用这个方法。最好使用 `v-if` 和 `v-for` 指令以数据驱动的方式控制子组件的生命周期。</p>\n\n- **参考**：[生命周期图示](../guide/instance.html#生命周期图示)\n\n## 指令\n\n### v-text\n\n- **预期**：`string`\n\n- **详细**：\n\n  更新元素的 `textContent`。如果要更新部分的 `textContent`，需要使用 `{% raw %}{{ Mustache }}{% endraw %}` 插值。\n\n- **示例**：\n\n  ```html\n  <span v-text=\"msg\"></span>\n  <!-- 和下面的一样 -->\n  <span>{{msg}}</span>\n  ```\n\n- **参考**：[数据绑定语法 - 插值](../guide/syntax.html#插值)\n\n### v-html\n\n- **预期**：`string`\n\n- **详细**：\n\n  更新元素的 `innerHTML`。**注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译**。如果试图使用 `v-html` 组合模板，可以重新考虑是否通过使用组件来替代。\n\n  <p class=\"tip\">在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。只在可信内容上使用 `v-html`，**永不**用在用户提交的内容上。</p>\n\n  <p class=\"tip\">在[单文件组件](../guide/single-file-components.html)里，`scoped` 的样式不会应用在 `v-html` 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 `v-html` 的内容设置带作用域的 CSS，你可以替换为 [CSS Modules](https://vue-loader.vuejs.org/en/features/css-modules.html) 或用一个额外的全局 `<style>` 元素手动设置类似 BEM 的作用域策略。</p>\n\n- **示例**：\n\n  ```html\n  <div v-html=\"html\"></div>\n  ```\n\n- **参考**：[数据绑定语法 - 插值](../guide/syntax.html#纯-HTML)\n\n### v-show\n\n- **预期**：`any`\n\n- **用法**：\n\n  根据表达式之真假值，切换元素的 `display` CSS property。\n\n  当条件变化时该指令触发过渡效果。\n\n- **参考**：[条件渲染 - v-show](../guide/conditional.html#v-show)\n\n### v-if\n\n- **预期**：`any`\n\n- **用法**：\n\n  根据表达式的值的 [truthiness](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy) 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 `<template>`，将提出它的内容作为条件块。\n\n  当条件变化时该指令触发过渡效果。\n\n  <p class=\"tip\">当和 `v-if` 一起使用时，`v-for` 的优先级比 `v-if` 更高。详见[列表渲染教程](../guide/list.html#v-for-with-v-if)</p>\n\n- **参考**：[条件渲染 - v-if](../guide/conditional.html)\n\n### v-else\n\n- **不需要表达式**\n\n- **限制**：前一兄弟元素必须有 `v-if` 或 `v-else-if`。\n\n- **用法**：\n\n  为 `v-if` 或者 `v-else-if` 添加“else 块”。\n\n  ```html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **参考**：[条件渲染 - v-else](../guide/conditional.html#v-else)\n\n### v-else-if\n\n> 2.1.0 新增\n\n- **类型**：`any`\n\n- **限制**：前一兄弟元素必须有 `v-if` 或 `v-else-if`。\n\n- **用法**：\n\n  表示 `v-if` 的“else if 块”。可以链式调用。\n\n  ```html\n  <div v-if=\"type === 'A'\">\n    A\n  </div>\n  <div v-else-if=\"type === 'B'\">\n    B\n  </div>\n  <div v-else-if=\"type === 'C'\">\n    C\n  </div>\n  <div v-else>\n    Not A/B/C\n  </div>\n  ```\n\n- **参考**：[条件渲染 - v-else-if](../guide/conditional.html#v-else-if)\n\n### v-for\n\n- **预期**：`Array | Object | number | string | Iterable (2.6 新增)`\n\n- **用法**：\n\n  基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 `alias in expression`，为当前遍历的元素提供别名：\n\n  ``` html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  另外也可以为数组索引指定别名 (或者用于对象的键)：\n\n  ``` html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(val, key) in object\"></div>\n  <div v-for=\"(val, name, index) in object\"></div>\n  ```\n\n  `v-for` 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute `key` 来提供一个排序提示：\n\n  ``` html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  从 2.6 起，`v-for` 也可以在实现了[可迭代协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#可迭代协议)的值上使用，包括原生的 `Map` 和 `Set`。不过应该注意的是 Vue 2.x 目前并不支持可响应的 `Map` 和 `Set` 值，所以无法自动探测变更。\n\n  <p class=\"tip\">当和 `v-if` 一起使用时，`v-for` 的优先级比 `v-if` 更高。详见[列表渲染教程](../guide/list.html#v-for-with-v-if)</p>\n\n  `v-for` 的详细用法可以通过以下链接查看教程详细说明。\n\n- **参考**：\n  - [列表渲染](../guide/list.html)\n  - [key](../guide/list.html#key)\n\n### v-on\n\n- **缩写**：`@`\n\n- **预期**：`Function | Inline Statement | Object`\n\n- **参数**：`event`\n\n- **修饰符**：\n  - `.stop` - 调用 `event.stopPropagation()`。\n  - `.prevent` - 调用 `event.preventDefault()`。\n  - `.capture` - 添加事件侦听器时使用 capture 模式。\n  - `.self` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\n  - `.{keyCode | keyAlias}` - 只当事件是从特定键触发时才触发回调。\n  - `.native` - 监听组件根元素的原生事件。\n  - `.once` - 只触发一次回调。\n  - `.left` - (2.2.0) 只当点击鼠标左键时触发。\n  - `.right` - (2.2.0) 只当点击鼠标右键时触发。\n  - `.middle` - (2.2.0) 只当点击鼠标中键时触发。\n  - `.passive` - (2.3.0) 以 `{ passive: true }` 模式添加侦听器\n\n- **用法**：\n\n  绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。\n\n  用在普通元素上时，只能监听[**原生 DOM 事件**](https://developer.mozilla.org/zh-CN/docs/Web/Events)。用在自定义元素组件上时，也可以监听子组件触发的**自定义事件**。\n\n  在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 `$event` property：`v-on:click=\"handle('ok', $event)\"`。\n\n  从 `2.4.0` 开始，`v-on` 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。\n\n- **示例**：\n\n  ```html\n  <!-- 方法处理器 -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- 动态事件 (2.6.0+) -->\n  <button v-on:[event]=\"doThis\"></button>\n\n  <!-- 内联语句 -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- 缩写 -->\n  <button @click=\"doThis\"></button>\n\n  <!-- 动态事件缩写 (2.6.0+) -->\n  <button @[event]=\"doThis\"></button>\n\n  <!-- 停止冒泡 -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- 阻止默认行为 -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- 阻止默认行为，没有表达式 -->\n  <form @submit.prevent></form>\n\n  <!--  串联修饰符 -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- 键修饰符，键别名 -->\n  <input @keyup.enter=\"onEnter\">\n\n  <!-- 键修饰符，键代码 -->\n  <input @keyup.13=\"onEnter\">\n\n  <!-- 点击回调只会触发一次 -->\n  <button v-on:click.once=\"doThis\"></button>\n\n  <!-- 对象语法 (2.4.0+) -->\n  <button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button>\n  ```\n\n  在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：\n\n  ```html\n  <my-component @my-event=\"handleThis\"></my-component>\n\n  <!-- 内联语句 -->\n  <my-component @my-event=\"handleThis(123, $event)\"></my-component>\n\n  <!-- 组件中的原生事件 -->\n  <my-component @click.native=\"onClick\"></my-component>\n  ```\n\n- **参考**：\n  - [事件处理器](../guide/events.html)\n  - [组件 - 自定义事件](../guide/components.html#监听子组件事件)\n\n### v-bind\n\n- **缩写**：`:`\n\n- **预期**：`any (with argument) | Object (without argument)`\n\n- **参数**：`attrOrProp (optional)`\n\n- **修饰符**：\n  - `.prop` - 作为一个 DOM property 绑定而不是作为 attribute 绑定。([差别在哪里？](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028))\n  - `.camel` - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)\n  - `.sync` (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 `v-on` 侦听器。\n\n- **用法**：\n\n  动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。\n\n  在绑定 `class` 或 `style` attribute 时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。\n\n  在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。\n\n  没有参数时，可以绑定到一个包含键值对的对象。注意此时 `class` 和 `style` 绑定不支持数组和对象。\n\n- **示例**：\n\n  ```html\n  <!-- 绑定一个 attribute -->\n  <img v-bind:src=\"imageSrc\">\n\n  <!-- 动态 attribute 名 (2.6.0+) -->\n  <button v-bind:[key]=\"value\"></button>\n\n  <!-- 缩写 -->\n  <img :src=\"imageSrc\">\n\n  <!-- 动态 attribute 名缩写 (2.6.0+) -->\n  <button :[key]=\"value\"></button>\n\n  <!-- 内联字符串拼接 -->\n  <img :src=\"'/path/to/images/' + fileName\">\n\n  <!-- class 绑定 -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\">\n\n  <!-- style 绑定 -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- 绑定一个全是 attribute 的对象 -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- 通过 prop 修饰符绑定 DOM attribute -->\n  <div v-bind:text-content.prop=\"text\"></div>\n\n  <!-- prop 绑定。“prop”必须在 my-component 中声明。-->\n  <my-component :prop=\"someThing\"></my-component>\n\n  <!-- 通过 $props 将父组件的 props 一起传给子组件 -->\n  <child-component v-bind=\"$props\"></child-component>\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n  `.camel` 修饰符允许在使用 DOM 模板时将 `v-bind` property 名称驼峰化，例如 SVG 的 `viewBox` property：\n\n  ``` html\n  <svg :view-box.camel=\"viewBox\"></svg>\n  ```\n\n  在使用字符串模板或通过 `vue-loader`/`vueify` 编译时，无需使用 `.camel`。\n\n- **参考**：\n  - [Class 与 Style 绑定](../guide/class-and-style.html)\n  - [组件 - Props](../guide/components.html#通过-Prop-向子组件传递数据)\n  - [组件 - `.sync` 修饰符](../guide/components-custom-events.html#sync-修饰符)\n\n### v-model\n\n- **预期**：随表单控件类型不同而不同。\n\n- **限制**：\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **修饰符**：\n  - [`.lazy`](../guide/forms.html#lazy) - 取代 `input` 监听 `change` 事件\n  - [`.number`](../guide/forms.html#number) - 输入字符串转为有效的数字\n  - [`.trim`](../guide/forms.html#trim) - 输入首尾空格过滤\n\n- **用法**：\n\n  在表单控件或者组件上创建双向绑定。细节请看下面的教程链接。\n\n- **参考**：\n  - [表单控件绑定](../guide/forms.html)\n  - [组件 - 在输入组件上使用自定义事件](../guide/components-custom-events.html#将原生事件绑定到组件)\n\n### v-slot\n\n- **缩写**：`#`\n\n- **预期**：可放置在函数参数位置的 JavaScript 表达式 (在[支持的环境下](../guide/components-slots.html#解构插槽-Props)可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。\n\n- **参数**：插槽名 (可选，默认值是 `default`)\n\n- **限用于**\n  - `<template>`\n  - [组件](../guide/components-slots.html#独占默认插槽的缩写语法) (对于一个单独的带 prop 的默认插槽)\n\n- **用法**：\n\n  提供具名插槽或需要接收 prop 的插槽。\n\n- **示例**：\n\n  ```html\n  <!-- 具名插槽 -->\n  <base-layout>\n    <template v-slot:header>\n      Header content\n    </template>\n\n    Default slot content\n\n    <template v-slot:footer>\n      Footer content\n    </template>\n  </base-layout>\n\n  <!-- 接收 prop 的具名插槽 -->\n  <infinite-scroll>\n    <template v-slot:item=\"slotProps\">\n      <div class=\"item\">\n        {{ slotProps.item.text }}\n      </div>\n    </template>\n  </infinite-scroll>\n\n  <!-- 接收 prop 的默认插槽，使用了解构 -->\n  <mouse-position v-slot=\"{ x, y }\">\n    Mouse position: {{ x }}, {{ y }}\n  </mouse-position>\n  ```\n\n  更多细节请查阅以下链接。\n\n- **参考**：\n  - [组件 - 插槽](../guide/components-slots.html)\n  - [RFC-0001](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md)\n\n### v-pre\n\n- **不需要表达式**\n\n- **用法**：\n\n  跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。\n\n- **示例**：\n\n  ```html\n  <span v-pre>{{ this will not be compiled }}</span>\n   ```\n\n### v-cloak\n\n- **不需要表达式**\n\n- **用法**：\n\n  这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 `[v-cloak] { display: none }` 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。\n\n- **示例**：\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  <div> 不会显示，直到编译结束。\n\n### v-once\n\n- **不需要表达式**\n\n- **详细**：\n\n  只渲染元素和组件**一次**。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。\n\n  ```html\n  <!-- 单个元素 -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- 有子元素 -->\n  <div v-once>\n    <h1>comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- 组件 -->\n  <my-component v-once :comment=\"msg\"></my-component>\n  <!-- `v-for` 指令-->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n- **参考**：\n  - [数据绑定语法- 插值](../guide/syntax.html#插值)\n  - [组件 - 对低开销的静态组件使用 `v-once`](../guide/components-edge-cases.html#通过-v-once-创建低开销的静态组件)\n\n## 特殊 attribute\n\n### key\n\n- **预期**：`number | string`\n\n  `key` 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。\n\n  有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误。\n\n  最常见的用例是结合 `v-for`：\n\n  ``` html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：\n\n  - 完整地触发组件的生命周期钩子\n  - 触发过渡\n\n  例如：\n\n  ``` html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  当 `text` 发生改变时，`<span>` 总是会被替换而不是被修改，因此会触发过渡。\n\n### ref\n\n- **预期**：`string`\n\n  `ref` 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 `$refs` 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：\n\n  ``` html\n  <!-- `vm.$refs.p` will be the DOM node -->\n  <p ref=\"p\">hello</p>\n\n  <!-- `vm.$refs.child` will be the child component instance -->\n  <child-component ref=\"child\"></child-component>\n  ```\n\n  当 `v-for` 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。\n\n  关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！`$refs` 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。\n\n- **参考**：[子组件 ref](../guide/components-edge-cases.html#访问子组件实例或子元素)\n\n### is\n\n- **预期**：`string | Object (组件的选项对象)`\n\n  用于[动态组件](../guide/components.html#动态组件)且基于 [DOM 内模板的限制](../guide/components.html#解析-DOM-模板时的注意事项)来工作。\n\n  示例：\n\n  ``` html\n  <!-- 当 `currentView` 改变时，组件也跟着改变 -->\n  <component v-bind:is=\"currentView\"></component>\n\n  <!-- 这样做是有必要的，因为 `<my-row>` 放在一个 -->\n  <!-- `<table>` 内可能无效且被放置到外面 -->\n  <table>\n    <tr is=\"my-row\"></tr>\n  </table>\n  ```\n\n  更多的使用细节，请移步至下面的链接。\n\n- **See also**：\n  - [动态组件](../guide/components.html#动态组件)\n  - [DOM 模板解析说明](../guide/components.html#解析-DOM-模板时的注意事项)\n\n### slot <sup style=\"color:#c92222\">废弃</sup>\n\n**推荐 2.6.0 新增的 [v-slot](#v-slot)。**\n\n- **预期**：`string`\n\n  用于标记往哪个具名插槽中插入子组件内容。\n\n- **参考**：[具名插槽](../guide/components-slots.html#具名插槽)\n\n### slot-scope <sup style=\"color:#c92222\">废弃</sup>\n\n**推荐 2.6.0 新增的 [v-slot](#v-slot)。**\n\n- **预期**：`function argument expression`\n\n- **用法**：\n\n  用于将元素或组件表示为作用域插槽。attribute 的值应该是可以出现在函数签名的参数位置的合法的 JavaScript 表达式。这意味着在支持的环境中，你还可以在表达式中使用 ES2015 解构。它在 2.5.0+ 中替代了 [`scope`](#scope-replaced)。\n\n  此 attribute 不支持动态绑定。\n\n- **参考**：[作用域插槽](../guide/components-slots.html#作用域插槽)\n\n### scope <sup style=\"color:#c92222\">移除</sup>\n\n**被 2.5.0 新增的 [slot-scope](#slot-scope) 取代。推荐 2.6.0 新增的 [v-slot](#v-slot)。**\n\n用于表示一个作为带作用域的插槽的 `<template>` 元素，它在 2.5.0+ 中被 [`slot-scope`](#slot-scope) 替代。\n\n- **用法：**\n\n  除了 `scope` 只可以用于 `<template>` 元素，其它和 [`slot-scope`](#slot-scope) 都相同。\n\n## 内置的组件\n\n### component\n\n- **Props**：\n  - `is` - string | ComponentDefinition | ComponentConstructor\n  - `inline-template` - boolean\n\n- **用法**：\n\n  渲染一个“元组件”为动态组件。依 `is` 的值，来决定哪个组件被渲染。\n\n  ```html\n  <!-- 动态组件由 vm 实例的 `componentId` property 控制 -->\n  <component :is=\"componentId\"></component>\n\n  <!-- 也能够渲染注册过的组件或 prop 传入的组件 -->\n  <component :is=\"$options.components.child\"></component>\n  ```\n\n- **参考**：[动态组件](../guide/components.html#动态组件)\n\n### transition\n\n- **Props**：\n  - `name` - string，用于自动生成 CSS 过渡类名。例如：`name: 'fade'` 将自动拓展为 `.fade-enter`，`.fade-enter-active` 等。默认类名为 `\"v\"`\n  - `appear` - boolean，是否在初始渲染时使用过渡。默认为 `false`。\n  - `css` - boolean，是否使用 CSS 过渡类。默认为 `true`。如果设置为 `false`，将只通过组件事件触发注册的 JavaScript 钩子。\n  - `type` - string，指定过渡事件类型，侦听过渡何时结束。有效值为 `\"transition\"` 和 `\"animation\"`。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。\n  - `mode` - string，控制离开/进入过渡的时间序列。有效的模式有 `\"out-in\"` 和 `\"in-out\"`；默认同时进行。\n  - `duration` - number | { `enter`: number, `leave`: number } 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 `transitionend` 或 `animationend` 事件。\n  - `enter-class` - string\n  - `leave-class` - string\n  - `appear-class` - string\n  - `enter-to-class` - string\n  - `leave-to-class` - string\n  - `appear-to-class` - string\n  - `enter-active-class` - string\n  - `leave-active-class` - string\n  - `appear-active-class` - string\n\n- **事件**：\n  - `before-enter`\n  - `before-leave`\n  - `before-appear`\n  - `enter`\n  - `leave`\n  - `appear`\n  - `after-enter`\n  - `after-leave`\n  - `after-appear`\n  - `enter-cancelled`\n  - `leave-cancelled` (`v-show` only)\n  - `appear-cancelled`\n\n- **用法**：\n\n  `<transition>` 元素作为**单个**元素/组件的过渡效果。`<transition>` 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。\n\n  ```html\n  <!-- 简单元素 -->\n  <transition>\n    <div v-if=\"ok\">toggled content</div>\n  </transition>\n\n  <!-- 动态组件 -->\n  <transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </transition>\n\n  <!-- 事件钩子 -->\n  <div id=\"transition-demo\">\n    <transition @after-enter=\"transitionComplete\">\n      <div v-show=\"ok\">toggled content</div>\n    </transition>\n  </div>\n  ```\n\n  ``` js\n  new Vue({\n    ...\n    methods: {\n      transitionComplete: function (el) {\n        // 传入 'el' 这个 DOM 元素作为参数。\n      }\n    }\n    ...\n  }).$mount('#transition-demo')\n  ```\n\n- **参考**：[过渡：进入，离开和列表](../guide/transitions.html)\n\n### transition-group\n\n- **Props**：\n  - `tag` - string，默认为 `span`\n  - `move-class` - 覆盖移动过渡期间应用的 CSS 类。\n  - 除了 `mode`，其他 attribute 和 `<transition>` 相同。\n\n- **事件**：\n  - 事件和 `<transition>` 相同。\n\n- **用法**：\n\n  `<transition-group>` 元素作为多个元素/组件的过渡效果。`<transition-group>` 渲染一个真实的 DOM 元素。默认渲染 `<span>`，可以通过 `tag` attribute 配置哪个元素应该被渲染。\n\n  注意，每个 `<transition-group>` 的子节点必须有**独立的 key**，动画才能正常工作\n\n  `<transition-group>` 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它会被应用一个移动中的 CSS 类 (通过 `name` attribute 或配置 `move-class` attribute 自动生成)。如果 CSS `transform` property 是“可过渡”property，当应用移动类时，将会使用 [FLIP 技术](https://aerotwist.com/blog/flip-your-animations/)使元素流畅地到达动画终点。\n\n  ```html\n  <transition-group tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </transition-group>\n  ```\n\n- **参考**：[过渡：进入，离开和列表](../guide/transitions.html)\n\n### keep-alive\n\n- **Props**：\n  - `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存。\n  - `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。\n  - `max` - 数字。最多可以缓存多少组件实例。\n\n- **用法**：\n\n  `<keep-alive>` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 `<transition>` 相似，`<keep-alive>` 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。\n\n  当组件在 `<keep-alive>` 内被切换，它的 `activated` 和 `deactivated` 这两个生命周期钩子函数将会被对应执行。\n\n  > 在 2.2.0 及其更高版本中，`activated` 和 `deactivated` 将会在 `<keep-alive>` 树内的所有嵌套组件中触发。\n\n  主要用于保留组件状态或避免重新渲染。\n\n  ```html\n  <!-- 基本 -->\n  <keep-alive>\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- 多个条件判断的子组件 -->\n  <keep-alive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </keep-alive>\n\n  <!-- 和 `<transition>` 一起使用 -->\n  <transition>\n    <keep-alive>\n      <component :is=\"view\"></component>\n    </keep-alive>\n  </transition>\n  ```\n\n  注意，`<keep-alive>` 是用在其一个直属的子组件被开关的情形。如果你在其中有 `v-for` 则不会工作。如果有上述的多个条件性的子元素，`<keep-alive>` 要求同时只有一个子元素被渲染。\n\n- **`include` and `exclude`**\n\n  > 2.1.0 新增\n\n  `include` 和 `exclude` prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：\n\n  ``` html\n  <!-- 逗号分隔字符串 -->\n  <keep-alive include=\"a,b\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- 正则表达式 (使用 `v-bind`) -->\n  <keep-alive :include=\"/a|b/\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- 数组 (使用 `v-bind`) -->\n  <keep-alive :include=\"['a', 'b']\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n  ```\n\n  匹配首先检查组件自身的 `name` 选项，如果 `name` 选项不可用，则匹配它的局部注册名称 (父组件 `components` 选项的键值)。匿名组件不能被匹配。\n\n- **`max`**\n\n  > 2.5.0 新增\n\n  最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。\n\n  ``` html\n  <keep-alive :max=\"10\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n  ```\n\n  <p class=\"tip\">`<keep-alive>` 不会在函数式组件中正常工作，因为它们没有缓存实例。</p>\n\n- **参考**：[动态组件 - keep-alive](../guide/components-dynamic-async.html#在动态组件上使用-keep-alive)\n\n### slot\n\n- **Props**：\n  - `name` - string，用于命名插槽。\n\n- **Usage**：\n\n  `<slot>` 元素作为组件模板之中的内容分发插槽。`<slot>` 元素自身将被替换。\n\n  详细用法，请参考下面教程的链接。\n\n- **参考**：[通过插槽分发内容](../guide/components.html#通过插槽分发内容)\n\n## VNode 接口\n\n- 请参考 [VNode class declaration](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js)。\n\n## 服务端渲染\n\n- 请参考 [vue-server-renderer package documentation](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer)。\n\n<!-- zhlint ignore: { `enter`: number, `leave`: number } -->\n<!-- zhlint ignore: ( , ) -->\n<!-- zhlint ignore: vm.$destroy() -->\n<!-- zhlint ignore: vm.$forceUpdate() -->\n","date":"2020-07-16T13:58:41.505Z","updated":"2020-07-16T13:58:41.504Z","path":"doc/api/index.html","comments":1,"layout":"page","_id":"ckcwngnlh00209lxkdndhfud9","content":"<h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><p><code>Vue.config</code> 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property：</p>\n<h3 id=\"silent\"><a href=\"#silent\" class=\"headerlink\" title=\"silent\"></a>silent</h3><ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>false</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.silent = <span class=\"hljs-literal\">true</span></code></pre>\n<p>取消 Vue 所有的日志与警告。</p>\n</li>\n</ul>\n<h3 id=\"optionMergeStrategies\"><a href=\"#optionMergeStrategies\" class=\"headerlink\" title=\"optionMergeStrategies\"></a>optionMergeStrategies</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>{}</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.optionMergeStrategies._my_option = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">parent, child, vm</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> child + <span class=\"hljs-number\">1</span>\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Profile = Vue.extend(&#123;\n  <span class=\"hljs-attr\">_my_option</span>: <span class=\"hljs-number\">1</span>\n&#125;)\n\n<span class=\"hljs-comment\">// Profile.options._my_option = 2</span></code></pre>\n<p>自定义合并策略的选项。</p>\n<p>合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。</p>\n</li>\n<li><p><strong>参考</strong><a href=\"../guide/mixins.html#自定义选项混入策略\">自定义选项的混入策略</a></p>\n</li>\n</ul>\n<h3 id=\"devtools\"><a href=\"#devtools\" class=\"headerlink\" title=\"devtools\"></a>devtools</h3><ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>true</code> (生产版为 <code>false</code>)</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 务必在加载 Vue 之后，立即同步设置以下内容</span>\nVue.config.devtools = <span class=\"hljs-literal\">true</span></code></pre>\n<p>配置是否允许 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a> 检查代码。开发版本默认为 <code>true</code>，生产版本默认为 <code>false</code>。生产版本设为 <code>true</code> 可以启用检查。</p>\n</li>\n</ul>\n<h3 id=\"errorHandler\"><a href=\"#errorHandler\" class=\"headerlink\" title=\"errorHandler\"></a>errorHandler</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>undefined</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.errorHandler = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, vm, info</span>) </span>&#123;\n  <span class=\"hljs-comment\">// handle error</span>\n  <span class=\"hljs-comment\">// `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span>\n  <span class=\"hljs-comment\">// 只在 2.2.0+ 可用</span>\n&#125;</code></pre>\n<p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p>\n<blockquote>\n<p>从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩溃。</p>\n</blockquote>\n<blockquote>\n<p>从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。</p>\n</blockquote>\n<blockquote>\n<p>从 2.6.0 起，这个钩子也会捕获 <code>v-on</code> DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。</p>\n</blockquote>\n<blockquote>\n<p>错误追踪服务 <a href=\"https://sentry.io\" target=\"_blank\" rel=\"noopener\">Sentry</a> 和 <a href=\"https://docs.bugsnag.com/platforms/browsers/vue/\" target=\"_blank\" rel=\"noopener\">Bugsnag</a> 都通过此选项提供了官方支持。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"warnHandler\"><a href=\"#warnHandler\" class=\"headerlink\" title=\"warnHandler\"></a>warnHandler</h3><blockquote>\n<p>2.4.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>undefined</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.warnHandler = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">msg, vm, trace</span>) </span>&#123;\n  <span class=\"hljs-comment\">// `trace` 是组件的继承关系追踪</span>\n&#125;</code></pre>\n<p>为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。</p>\n</li>\n</ul>\n<h3 id=\"ignoredElements\"><a href=\"#ignoredElements\" class=\"headerlink\" title=\"ignoredElements\"></a>ignoredElements</h3><ul>\n<li><p><strong>类型</strong>：<code>Array&lt;string | RegExp&gt;</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>[]</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.ignoredElements = [\n  'my-custom-web-component',\n  'another-web-component',\n  // 用一个 `RegExp` 忽略所有“ion-”开头的元素\n  // 仅在 2.5+ 支持\n  /^ion-/\n]</code></pre>\n<p>须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 <code>Unknown custom element</code> 的警告。</p>\n</li>\n</ul>\n<h3 id=\"keyCodes\"><a href=\"#keyCodes\" class=\"headerlink\" title=\"keyCodes\"></a>keyCodes</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: number | Array&lt;number&gt; }</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>{}</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.keyCodes = &#123;\n  <span class=\"hljs-attr\">v</span>: <span class=\"hljs-number\">86</span>,\n  <span class=\"hljs-attr\">f1</span>: <span class=\"hljs-number\">112</span>,\n  <span class=\"hljs-comment\">// camelCase 不可用</span>\n  <span class=\"hljs-attr\">mediaPlayPause</span>: <span class=\"hljs-number\">179</span>,\n  <span class=\"hljs-comment\">// 取而代之的是 kebab-case 且用双引号括起来</span>\n  <span class=\"hljs-string\">\"media-play-pause\"</span>: <span class=\"hljs-number\">179</span>,\n  <span class=\"hljs-attr\">up</span>: [<span class=\"hljs-number\">38</span>, <span class=\"hljs-number\">87</span>]\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> @<span class=\"hljs-attr\">keyup.media-play-pause</span>=<span class=\"hljs-string\">\"method\"</span>&gt;</span></code></pre>\n<p>给 <code>v-on</code> 自定义键位别名。</p>\n</li>\n</ul>\n<h3 id=\"performance\"><a href=\"#performance\" class=\"headerlink\" title=\"performance\"></a>performance</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>false (自 2.2.3 起)</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>设置为 <code>true</code> 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark\" target=\"_blank\" rel=\"noopener\"><code>performance.mark</code></a> API 的浏览器上。</p>\n</li>\n</ul>\n<h3 id=\"productionTip\"><a href=\"#productionTip\" class=\"headerlink\" title=\"productionTip\"></a>productionTip</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>true</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>设置为 <code>false</code> 以阻止 vue 在启动时生成生产提示。</p>\n</li>\n</ul>\n<h2 id=\"全局-API\"><a href=\"#全局-API\" class=\"headerlink\" title=\"全局 API\"></a>全局 API</h2><h3 id=\"Vue-extend-options\"><a href=\"#Vue-extend-options\" class=\"headerlink\" title=\"Vue.extend( options )\"></a>Vue.extend( options )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object} options</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>\n<p><code>data</code> 选项是特例，需要注意 - 在 <code>Vue.extend()</code> 中它必须是函数</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"mount-point\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 创建构造器</span>\n<span class=\"hljs-keyword\">var</span> Profile = Vue.extend(&#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Walter'</span>,\n      <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'White'</span>,\n      <span class=\"hljs-attr\">alias</span>: <span class=\"hljs-string\">'Heisenberg'</span>\n    &#125;\n  &#125;\n&#125;)\n<span class=\"hljs-comment\">// 创建 Profile 实例，并挂载到一个元素上。</span>\n<span class=\"hljs-keyword\">new</span> Profile().$mount(<span class=\"hljs-string\">'#mount-point'</span>)</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Walter White aka Heisenberg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components.html\">组件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-nextTick-callback-context\"><a href=\"#Vue-nextTick-callback-context\" class=\"headerlink\" title=\"Vue.nextTick( [callback, context] )\"></a>Vue.nextTick( [callback, context] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n<li><code>{Object} [context]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 修改数据</span>\nvm.msg = <span class=\"hljs-string\">'Hello'</span>\n<span class=\"hljs-comment\">// DOM 还没有更新</span>\nVue.nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// DOM 更新了</span>\n&#125;)\n\n<span class=\"hljs-comment\">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span>\nVue.nextTick()\n  .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// DOM 更新了</span>\n  &#125;)</code></pre>\n<blockquote>\n<p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。</p>\n</blockquote>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/reactivity.html#异步更新队列\">异步更新队列</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-set-target-propertyName-index-value\"><a href=\"#Vue-set-target-propertyName-index-value\" class=\"headerlink\" title=\"Vue.set( target, propertyName/index, value )\"></a>Vue.set( target, propertyName/index, value )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>返回值</strong>：设置的值。</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 <code>this.myObject.newProperty = &#39;hi&#39;</code>)</p>\n<p class=\"tip\">注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</p>\n\n</li>\n</ul>\n<h3 id=\"Vue-delete-target-propertyName-index\"><a href=\"#Vue-delete-target-propertyName-index\" class=\"headerlink\" title=\"Vue.delete( target, propertyName/index )\"></a>Vue.delete( target, propertyName/index )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n</ul>\n<blockquote>\n<p>仅在 2.2.0+ 版本中支持 Array + index 用法。</p>\n</blockquote>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。</p>\n<blockquote>\n<p>在 2.2.0+ 中同样支持在数组上工作。</p>\n</blockquote>\n<p class=\"tip\">目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-directive-id-definition\"><a href=\"#Vue-directive-id-definition\" class=\"headerlink\" title=\"Vue.directive( id, [definition] )\"></a>Vue.directive( id, [definition] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>注册或获取全局指令。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 注册</span>\nVue.directive(<span class=\"hljs-string\">'my-directive'</span>, &#123;\n  <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">componentUpdated</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">unbind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;\n&#125;)\n\n<span class=\"hljs-comment\">// 注册 (指令函数)</span>\nVue.directive(<span class=\"hljs-string\">'my-directive'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// 这里将会被 `bind` 和 `update` 调用</span>\n&#125;)\n\n<span class=\"hljs-comment\">// getter，返回已注册的指令</span>\n<span class=\"hljs-keyword\">var</span> myDirective = Vue.directive(<span class=\"hljs-string\">'my-directive'</span>)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/custom-directive.html\">自定义指令</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-filter-id-definition\"><a href=\"#Vue-filter-id-definition\" class=\"headerlink\" title=\"Vue.filter( id, [definition] )\"></a>Vue.filter( id, [definition] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>注册或获取全局过滤器。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 注册</span>\nVue.filter(<span class=\"hljs-string\">'my-filter'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-comment\">// 返回处理后的值</span>\n&#125;)\n\n<span class=\"hljs-comment\">// getter，返回已注册的过滤器</span>\n<span class=\"hljs-keyword\">var</span> myFilter = Vue.filter(<span class=\"hljs-string\">'my-filter'</span>)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/filters.html\">过滤器</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-component-id-definition\"><a href=\"#Vue-component-id-definition\" class=\"headerlink\" title=\"Vue.component( id, [definition] )\"></a>Vue.component( id, [definition] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>注册或获取全局组件。注册还会自动使用给定的 <code>id</code> 设置组件的名称</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 注册组件，传入一个扩展过的构造器</span>\nVue.component(<span class=\"hljs-string\">'my-component'</span>, Vue.extend(&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;))\n\n<span class=\"hljs-comment\">// 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span>\nVue.component(<span class=\"hljs-string\">'my-component'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)\n\n<span class=\"hljs-comment\">// 获取注册的组件 (始终返回构造器)</span>\n<span class=\"hljs-keyword\">var</span> MyComponent = Vue.component(<span class=\"hljs-string\">'my-component'</span>)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components.html\">组件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-use-plugin\"><a href=\"#Vue-use-plugin\" class=\"headerlink\" title=\"Vue.use( plugin )\"></a>Vue.use( plugin )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object | Function} plugin</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>安装 Vue.js 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。</p>\n<p>该方法需要在调用 <code>new Vue()</code> 之前被调用。</p>\n<p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/plugins.html\">插件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-mixin-mixin\"><a href=\"#Vue-mixin-mixin\" class=\"headerlink\" title=\"Vue.mixin( mixin )\"></a>Vue.mixin( mixin )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object} mixin</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。<strong>不推荐在应用代码中使用</strong>。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/mixins.html#全局混入\">全局混入</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-compile-template\"><a href=\"#Vue-compile-template\" class=\"headerlink\" title=\"Vue.compile( template )\"></a>Vue.compile( template )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} template</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>将一个模板字符串编译成 render 函数。<strong>只在完整版时可用</strong>。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> res = Vue.compile(<span class=\"hljs-string\">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'hello'</span>\n  &#125;,\n  <span class=\"hljs-attr\">render</span>: res.render,\n  <span class=\"hljs-attr\">staticRenderFns</span>: res.staticRenderFns\n&#125;)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/render-function.html\">渲染函数</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-observable-object\"><a href=\"#Vue-observable-object\" class=\"headerlink\" title=\"Vue.observable( object )\"></a>Vue.observable( object )</h3><blockquote>\n<p>2.6.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object} object</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>让一个对象可响应。Vue 内部会用它来处理 <code>data</code> 函数返回的对象。</p>\n<p>返回的对象可以直接用于<a href=\"../guide/render-function.html\">渲染函数</a>和<a href=\"../guide/computed.html\">计算属性</a>内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> state = Vue.observable(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span> &#125;)\n\n<span class=\"hljs-keyword\">const</span> Demo = &#123;\n  render(h) &#123;\n    <span class=\"hljs-keyword\">return</span> h(<span class=\"hljs-string\">'button'</span>, &#123;\n      <span class=\"hljs-attr\">on</span>: &#123; <span class=\"hljs-attr\">click</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123; state.count++ &#125;&#125;\n    &#125;, <span class=\"hljs-string\">`count is: <span class=\"hljs-subst\">$&#123;state.count&#125;</span>`</span>)\n  &#125;\n&#125;</code></pre>\n<p class=\"tip\">在 Vue 2.x 中，被传入的对象会直接被 <code>Vue.observable</code> 变更，所以如<a href=\"../guide/instance.html#数据与方法\">这里展示的</a>，它和被返回的对象是同一个对象。在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的。因此，为了向前兼容，我们推荐始终操作使用 <code>Vue.observable</code> 返回的对象，而不是传入源对象。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-version\"><a href=\"#Vue-version\" class=\"headerlink\" title=\"Vue.version\"></a>Vue.version</h3><ul>\n<li><p><strong>细节</strong>：提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> version = <span class=\"hljs-built_in\">Number</span>(Vue.version.split(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>])\n\n<span class=\"hljs-keyword\">if</span> (version === <span class=\"hljs-number\">2</span>) &#123;\n  <span class=\"hljs-comment\">// Vue v2.x.x</span>\n&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (version === <span class=\"hljs-number\">1</span>) &#123;\n  <span class=\"hljs-comment\">// Vue v1.x.x</span>\n&#125; <span class=\"hljs-keyword\">else</span> &#123;\n  <span class=\"hljs-comment\">// Unsupported versions of Vue</span>\n&#125;</code></pre>\n</li>\n</ul>\n<h2 id=\"选项-数据\"><a href=\"#选项-数据\" class=\"headerlink\" title=\"选项 / 数据\"></a>选项 / 数据</h2><h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><ul>\n<li><p><strong>类型</strong>：<code>Object | Function</code></p>\n</li>\n<li><p><strong>限制</strong>：组件的定义只接受 <code>function</code>。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>Vue 实例的数据对象。Vue 将会递归将 data 的 property 转换为 getter/setter，从而让 data 的 property 能够响应数据变化。<strong>对象必须是纯粹的对象 (含有零个或多个的 key/value 对)</strong>：浏览器 API 创建的原生对象，原型上的 property 会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。</p>\n<p>一旦观察过，你就无法在根数据对象上添加响应式 property。因此推荐在创建实例之前，就声明所有的根级响应式 property。</p>\n<p>实例创建之后，可以通过 <code>vm.$data</code> 访问原始数据对象。Vue 实例也代理了 data 对象上所有的 property，因此访问 <code>vm.a</code> 等价于访问 <code>vm.$data.a</code>。</p>\n<p>以 <code>_</code> 或 <code>$</code> 开头的 property <strong>不会</strong>被 Vue 实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些 property。</p>\n<p>当一个<strong>组件</strong>被定义，<code>data</code> 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 <code>data</code> 仍然是一个纯粹的对象，则所有的实例将<strong>共享引用</strong>同一个数据对象！通过提供 <code>data</code> 函数，每次创建一个新实例后，我们能够调用 <code>data</code> 函数，从而返回初始数据的一个全新副本数据对象。</p>\n<p>如果需要，可以通过将 <code>vm.$data</code> 传入 <code>JSON.parse(JSON.stringify(...))</code> 得到深拷贝的原始数据对象。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> data = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n\n<span class=\"hljs-comment\">// 直接创建一个实例</span>\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: data\n&#125;)\nvm.a <span class=\"hljs-comment\">// =&gt; 1</span>\nvm.$data === data <span class=\"hljs-comment\">// =&gt; true</span>\n\n<span class=\"hljs-comment\">// Vue.extend() 中 data 必须是函数</span>\n<span class=\"hljs-keyword\">var</span> Component = Vue.extend(&#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n  &#125;\n&#125;)</code></pre>\n<p>注意，如果你为 <code>data</code> property 使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-params\">vm</span> =&gt;</span> (&#123; <span class=\"hljs-attr\">a</span>: vm.myProp &#125;)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><ul>\n<li><p><strong>类型</strong>：<code>Array&lt;string&gt; | Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。</p>\n<p>你可以基于对象的语法使用以下选项：</p>\n<ul>\n<li><code>type</code>：可以是下列原生构造函数中的一种：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code>、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的<a href=\"../guide/components-props.html#Prop-类型\">更多信息在此</a>。</li>\n<li><code>default</code>：<code>any</code><br>为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。</li>\n<li><code>required</code>：<code>Boolean</code><br>定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。</li>\n<li><code>validator</code>：<code>Function</code><br>自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在<a href=\"../guide/components-props.html#Prop-验证\">这里</a>查阅更多 prop 验证的相关信息。</li>\n</ul>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 简单语法</span>\nVue.component(<span class=\"hljs-string\">'props-demo-simple'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'size'</span>, <span class=\"hljs-string\">'myMessage'</span>]\n&#125;)\n\n<span class=\"hljs-comment\">// 对象语法，提供验证</span>\nVue.component(<span class=\"hljs-string\">'props-demo-advanced'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// 检测类型</span>\n    <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">Number</span>,\n    <span class=\"hljs-comment\">// 检测类型 + 其他验证</span>\n    <span class=\"hljs-attr\">age</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> value &gt;= <span class=\"hljs-number\">0</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components-props.html\">Props</a></p>\n</li>\n</ul>\n<h3 id=\"propsData\"><a href=\"#propsData\" class=\"headerlink\" title=\"propsData\"></a>propsData</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: any }</code></p>\n</li>\n<li><p><strong>限制</strong>：只用于 <code>new</code> 创建的实例中。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>创建实例时传递 props。主要作用是方便测试。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> Comp = Vue.extend(&#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'msg'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span>\n&#125;)\n\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Comp(&#123;\n  <span class=\"hljs-attr\">propsData</span>: &#123;\n    <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'hello'</span>\n  &#125;\n&#125;)</code></pre>\n</li>\n</ul>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>\n<p>注意如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p>\n<pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">aDouble</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">vm</span> =&gt;</span> vm.a * <span class=\"hljs-number\">2</span>\n&#125;</code></pre>\n<p>计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是<strong>不会</strong>被更新的。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-comment\">// 仅读取</span>\n    <span class=\"hljs-attr\">aDouble</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a * <span class=\"hljs-number\">2</span>\n    &#125;,\n    <span class=\"hljs-comment\">// 读取和设置</span>\n    <span class=\"hljs-attr\">aPlus</span>: &#123;\n      <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a + <span class=\"hljs-number\">1</span>\n      &#125;,\n      <span class=\"hljs-attr\">set</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">v</span>) </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.a = v - <span class=\"hljs-number\">1</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;)\nvm.aPlus   <span class=\"hljs-comment\">// =&gt; 2</span>\nvm.aPlus = <span class=\"hljs-number\">3</span>\nvm.a       <span class=\"hljs-comment\">// =&gt; 2</span>\nvm.aDouble <span class=\"hljs-comment\">// =&gt; 4</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/computed.html\">计算属性</a></p>\n</li>\n</ul>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 <code>this</code> 自动绑定为 Vue 实例。</p>\n<p class=\"tip\">注意，<strong>不应该使用箭头函数来定义 method 函数</strong> (例如 <code>plus: () =&gt; this.a++</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">plus</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.a++\n    &#125;\n  &#125;\n&#125;)\nvm.plus()\nvm.a <span class=\"hljs-comment\">// 2</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/events.html\">事件处理器</a></p>\n</li>\n</ul>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: string | Function | Object | Array }</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个 property。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span>,\n    <span class=\"hljs-attr\">d</span>: <span class=\"hljs-number\">4</span>,\n    <span class=\"hljs-attr\">e</span>: &#123;\n      <span class=\"hljs-attr\">f</span>: &#123;\n        <span class=\"hljs-attr\">g</span>: <span class=\"hljs-number\">5</span>\n      &#125;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">watch</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'new: %s, old: %s'</span>, val, oldVal)\n    &#125;,\n    <span class=\"hljs-comment\">// 方法名</span>\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">'someMethod'</span>,\n    <span class=\"hljs-comment\">// 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</span>\n    <span class=\"hljs-attr\">c</span>: &#123;\n      <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n      <span class=\"hljs-attr\">deep</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-comment\">// 该回调将会在侦听开始之后被立即调用</span>\n    <span class=\"hljs-attr\">d</span>: &#123;\n      <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-string\">'someMethod'</span>,\n      <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-comment\">// 你可以传入回调数组，它们会被逐一调用</span>\n    <span class=\"hljs-attr\">e</span>: [\n      <span class=\"hljs-string\">'handle1'</span>,\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handle2</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n      &#123;\n        <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handle3</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n        <span class=\"hljs-comment\">/* ... */</span>\n      &#125;\n    ],\n    <span class=\"hljs-comment\">// watch vm.e.f's value: &#123;g: 5&#125;</span>\n    <span class=\"hljs-string\">'e.f'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n  &#125;\n&#125;)\nvm.a = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// =&gt; new: 2, old: 1</span></code></pre>\n<p class=\"tip\">注意，<strong>不应该使用箭头函数来定义 watcher 函数</strong> (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.updateAutocomplete</code> 将是 undefined。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"#vm-watch\">实例方法 / 数据 - vm.$watch</a></p>\n</li>\n</ul>\n<h2 id=\"选项-DOM\"><a href=\"#选项-DOM\" class=\"headerlink\" title=\"选项 / DOM\"></a>选项 / DOM</h2><h3 id=\"el\"><a href=\"#el\" class=\"headerlink\" title=\"el\"></a>el</h3><ul>\n<li><p><strong>类型</strong>：<code>string | Element</code></p>\n</li>\n<li><p><strong>限制</strong>：只在用 <code>new</code> 创建实例时生效。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p>\n<p>在实例挂载之后，元素可以用 <code>vm.$el</code> 访问。</p>\n<p>如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 <code>vm.$mount()</code> 手动开启编译。</p>\n<p class=\"tip\"> 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载 root 实例到 <code>&lt;html&gt;</code> 或者 <code>&lt;body&gt;</code> 上。</p>\n\n<p class=\"tip\">如果 <code>render</code> 函数和 <code>template</code> property 都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></li>\n<li><a href=\"../guide/installation.html#运行时-编译器-vs-只包含运行时\">运行时 + 编译器 vs. 只包含运行时</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h3><ul>\n<li><p><strong>类型</strong>：<code>string</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>一个字符串模板作为 Vue 实例的标识使用。模板将会<strong>替换</strong>挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</p>\n<p>如果值以 <code>#</code> 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <code>&lt;script type=&quot;x-template&quot;&gt;</code> 包含模板。</p>\n<p class=\"tip\">出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。</p>\n\n<p class=\"tip\">如果 Vue 选项中包含渲染函数，该模板将被忽略。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></li>\n<li><a href=\"../guide/components.html#通过插槽分发内容\">通过插槽分发内容</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><ul>\n<li><p><strong>类型</strong>：<code>(createElement: () =&gt; VNode) =&gt; VNode</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>。</p>\n<p>如果组件是一个函数组件，渲染函数还会接收一个额外的 <code>context</code> 参数，为没有实例的函数组件提供上下文信息。</p>\n<p class=\"tip\">Vue 选项中的 <code>render</code> 函数若存在，则 Vue 构造函数不会从 <code>template</code> 选项或通过 <code>el</code> 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/render-function.html\">渲染函数</a></p>\n</li>\n</ul>\n<h3 id=\"renderError\"><a href=\"#renderError\" class=\"headerlink\" title=\"renderError\"></a>renderError</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>(createElement: () =&gt; VNode, error: Error) =&gt; VNode</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p><strong>只在开发者环境下工作。</strong></p>\n<p>当 <code>render</code> 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 <code>renderError</code>。这个功能配合 hot-reload 非常实用。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  render (h) &#123;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'oops'</span>)\n  &#125;,\n  renderError (h, err) &#123;\n    <span class=\"hljs-keyword\">return</span> h(<span class=\"hljs-string\">'pre'</span>, &#123; <span class=\"hljs-attr\">style</span>: &#123; <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'red'</span> &#125;&#125;, err.stack)\n  &#125;\n&#125;).$mount(<span class=\"hljs-string\">'#app'</span>)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/render-function.html\">渲染函数</a></p>\n</li>\n</ul>\n<h2 id=\"选项-生命周期钩子\"><a href=\"#选项-生命周期钩子\" class=\"headerlink\" title=\"选项 / 生命周期钩子\"></a>选项 / 生命周期钩子</h2><p class=\"tip\">所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 Vue 实例不同，<code>this.fetchTodos</code> 的行为未定义。</p>\n\n<h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> property 目前尚不可用。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>\n<p>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a href=\"#vm-nextTick\">vm.$nextTick</a>：</p>\n<pre><code class=\"hljs js\">mounted: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// Code that will run only after the</span>\n    <span class=\"hljs-comment\">// entire view has been rendered</span>\n  &#125;)\n&#125;</code></pre>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>\n<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a href=\"#computed\">计算属性</a>或 <a href=\"#watch\">watcher</a> 取而代之。</p>\n<p>注意 <code>updated</code> <strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a href=\"#vm-nextTick\">vm.$nextTick</a>：</p>\n<pre><code class=\"hljs js\">updated: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// Code that will run only after the</span>\n    <span class=\"hljs-comment\">// entire view has been re-rendered</span>\n  &#125;)\n&#125;</code></pre>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>被 keep-alive 缓存的组件激活时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"#keep-alive\">构建组件 - keep-alive</a></li>\n<li><a href=\"../guide/components-dynamic-async.html#在动态组件上使用-keep-alive\">动态组件 - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>被 keep-alive 缓存的组件停用时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"#keep-alive\">构建组件 - keep-alive</a></li>\n<li><a href=\"../guide/components-dynamic-async.html#在动态组件上使用-keep-alive\">动态组件 - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"errorCaptured\"><a href=\"#errorCaptured\" class=\"headerlink\" title=\"errorCaptured\"></a>errorCaptured</h3><blockquote>\n<p>2.5.0+ 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p>\n<p class=\"tip\">你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p>\n\n<p><strong>错误传播规则</strong></p>\n<ul>\n<li><p>默认情况下，如果全局的 <code>config.errorHandler</code> 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</p>\n</li>\n<li><p>如果一个组件的继承或父级从属链路中存在多个 <code>errorCaptured</code> 钩子，则它们将会被相同的错误逐个唤起。</p>\n</li>\n<li><p>如果此 <code>errorCaptured</code> 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 <code>config.errorHandler</code>。</p>\n</li>\n<li><p>一个 <code>errorCaptured</code> 钩子能够返回 <code>false</code> 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 <code>errorCaptured</code> 钩子和全局的 <code>config.errorHandler</code>。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"选项-资源\"><a href=\"#选项-资源\" class=\"headerlink\" title=\"选项 / 资源\"></a>选项 / 资源</h2><h3 id=\"directives\"><a href=\"#directives\" class=\"headerlink\" title=\"directives\"></a>directives</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n</li>\n</ul>\n<p>包含 Vue 实例可用指令的哈希表。</p>\n<ul>\n<li><strong>参考</strong>：<a href=\"../guide/custom-directive.html\">自定义指令</a></li>\n</ul>\n<h3 id=\"filters\"><a href=\"#filters\" class=\"headerlink\" title=\"filters\"></a>filters</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n</li>\n</ul>\n<p>包含 Vue 实例可用过滤器的哈希表。</p>\n<ul>\n<li><strong>参考</strong>：<a href=\"#Vue-filter\"><code>Vue.filter</code></a></li>\n</ul>\n<h3 id=\"components\"><a href=\"#components\" class=\"headerlink\" title=\"components\"></a>components</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n</li>\n</ul>\n<p>包含 Vue 实例可用组件的哈希表。</p>\n<ul>\n<li><strong>参考</strong>：<a href=\"../guide/components.html\">组件</a></li>\n</ul>\n<h2 id=\"选项-组合\"><a href=\"#选项-组合\" class=\"headerlink\" title=\"选项 / 组合\"></a>选项 / 组合</h2><h3 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h3><ul>\n<li><p><strong>类型</strong>：<code>Vue instance</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 <code>this.$parent</code> 访问父实例，子实例被推入父实例的 <code>$children</code> 数组中。</p>\n<p class=\"tip\">节制地使用 <code>$parent</code> 和 <code>$children</code> - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信</p>\n\n</li>\n</ul>\n<h3 id=\"mixins\"><a href=\"#mixins\" class=\"headerlink\" title=\"mixins\"></a>mixins</h3><ul>\n<li><p><strong>类型</strong>：<code>Array&lt;Object&gt;</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p><code>mixins</code> 选项接收一个混入对象的数组。这些混入对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用的是和 <code>Vue.extend()</code> 一样的选项合并逻辑。也就是说，如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。</p>\n<p>Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> mixin = &#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>) &#125;\n&#125;\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>) &#125;,\n  <span class=\"hljs-attr\">mixins</span>: [mixin]\n&#125;)\n<span class=\"hljs-comment\">// =&gt; 1</span>\n<span class=\"hljs-comment\">// =&gt; 2</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/mixins.html\">混入</a></p>\n</li>\n</ul>\n<h3 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h3><ul>\n<li><p><strong>类型</strong>：<code>Object | Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 <code>Vue.extend</code>。这主要是为了便于扩展单文件组件。</p>\n<p>这和 <code>mixins</code> 类似。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> CompA = &#123; ... &#125;\n\n<span class=\"hljs-comment\">// 在没有调用 `Vue.extend` 时候继承 CompA</span>\n<span class=\"hljs-keyword\">var</span> CompB = &#123;\n  <span class=\"hljs-attr\">extends</span>: CompA,\n  ...\n&#125;</code></pre>\n</li>\n</ul>\n<h3 id=\"provide-inject\"><a href=\"#provide-inject\" class=\"headerlink\" title=\"provide / inject\"></a>provide / inject</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：</p>\n<ul>\n<li><strong>provide</strong>：<code>Object | () =&gt; Object</code></li>\n<li><strong>inject</strong>：<code>Array&lt;string&gt; | { [key: string]: string | Symbol | Object }</code></li>\n</ul>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p class=\"tip\"><code>provide</code> 和 <code>inject</code> 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。</p>\n\n<p>这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。</p>\n<p><code>provide</code> 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 <code>Symbol</code> 和 <code>Reflect.ownKeys</code> 的环境下可工作。</p>\n<p><code>inject</code> 选项应该是：</p>\n<ul>\n<li>一个字符串数组，或</li>\n<li>一个对象，对象的 key 是本地的绑定名，value 是：<ul>\n<li>在可用的注入内容中搜索用的 key (字符串或 Symbol)，或</li>\n<li>一个对象，该对象的：<ul>\n<li><code>from</code> property 是在可用的注入内容中搜索用的 key (字符串或 Symbol)</li>\n<li><code>default</code> property 是降级情况下使用的 value</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>提示：<code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</p>\n</blockquote>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 父级组件提供 'foo'</span>\n<span class=\"hljs-keyword\">var</span> Provider = &#123;\n  <span class=\"hljs-attr\">provide</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// 子组件注入 'foo'</span>\n<span class=\"hljs-keyword\">var</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  created () &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.foo) <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n  &#125;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<p>利用 ES2015 Symbols、函数 <code>provide</code> 和对象 <code>inject</code>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> s = <span class=\"hljs-built_in\">Symbol</span>()\n\n<span class=\"hljs-keyword\">const</span> Provider = &#123;\n  provide () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      [s]: <span class=\"hljs-string\">'foo'</span>\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123; s &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<blockquote>\n<p>接下来 2 个例子只工作在 Vue 2.2.1 或更高版本。低于这个版本时，注入的值会在 <code>props</code> 和 <code>data</code> 初始化之后得到。</p>\n</blockquote>\n<p>使用一个注入的值作为一个 property 的默认值：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">bar</span>: &#123;\n      <span class=\"hljs-keyword\">default</span> () &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.foo\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>使用一个注入的值作为数据入口：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-keyword\">this</span>.foo\n    &#125;\n  &#125;\n&#125;</code></pre>\n<blockquote>\n<p>在 2.5.0+ 的注入可以通过设置默认值使其变成可选项：</p>\n</blockquote>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123; <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'foo'</span> &#125;\n  &#125;\n&#125;</code></pre>\n<p>如果它需要从一个不同名字的 property 注入，则使用 <code>from</code> 来表示其源 property：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123;\n      <span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">'bar'</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'foo'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>与 prop 的默认值类似，你需要对非原始值使用一个工厂方法：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123;\n      <span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">'bar'</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n    &#125;\n  &#125;\n&#125;</code></pre>\n</li>\n</ul>\n<h2 id=\"选项-其它\"><a href=\"#选项-其它\" class=\"headerlink\" title=\"选项 / 其它\"></a>选项 / 其它</h2><h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><ul>\n<li><p><strong>类型</strong>：<code>string</code></p>\n</li>\n<li><p><strong>限制</strong>：只有作为组件选项时起作用。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>允许组件模板递归地调用自身。注意，组件在全局用 <code>Vue.component()</code> 注册时，全局 ID 自动作为组件的 name。</p>\n<p>指定 <code>name</code> 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a>，未命名组件将显示成 <code>&lt;AnonymousComponent&gt;</code>，这很没有语义。通过提供 <code>name</code> 选项，可以获得更有语义信息的组件树。</p>\n</li>\n</ul>\n<h3 id=\"delimiters\"><a href=\"#delimiters\" class=\"headerlink\" title=\"delimiters\"></a>delimiters</h3><ul>\n<li><p><strong>类型</strong>：<code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>[\"{{\", \"}}\"]</code></p>\n</li>\n<li><p><strong>限制</strong>：这个选项只在完整构建版本中的浏览器内编译时可用。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>改变纯文本插入分隔符。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">delimiters</span>: [<span class=\"hljs-string\">'$&#123;'</span>, <span class=\"hljs-string\">'&#125;'</span>]\n&#125;)\n\n<span class=\"hljs-comment\">// 分隔符变成了 ES6 模板字符串的风格</span></code></pre>\n</li>\n</ul>\n<h3 id=\"functional\"><a href=\"#functional\" class=\"headerlink\" title=\"functional\"></a>functional</h3><ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>使组件无状态 (没有 <code>data</code>) 和无实例 (没有 <code>this</code> 上下文)。他们用一个简单的 <code>render</code> 函数返回虚拟节点使它们渲染的代价更小。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/render-function.html#函数式组件\">函数式组件</a></p>\n</li>\n</ul>\n<h3 id=\"model\"><a href=\"#model\" class=\"headerlink\" title=\"model\"></a>model</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>{ prop?: string, event?: string }</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>允许一个自定义组件在使用 <code>v-model</code> 时定制 prop 和 event。默认情况下，一个组件上的 <code>v-model</code> 会把 <code>value</code> 用作 prop 且把 <code>input</code> 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 <code>value</code> prop 来达到不同的目的。使用 <code>model</code> 选项可以回避这些情况产生的冲突。</p>\n</li>\n<li><p><strong>Example</strong>：</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-checkbox'</span>, &#123;\n  <span class=\"hljs-attr\">model</span>: &#123;\n    <span class=\"hljs-attr\">prop</span>: <span class=\"hljs-string\">'checked'</span>,\n    <span class=\"hljs-attr\">event</span>: <span class=\"hljs-string\">'change'</span>\n  &#125;,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// this allows using the `value` prop for a different purpose</span>\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-comment\">// use `checked` as the prop which take the place of `value`</span>\n    <span class=\"hljs-attr\">checked</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">0</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-checkbox</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"foo\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"some value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-checkbox</span>&gt;</span></code></pre>\n<p>上述代码相当于：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-checkbox</span>\n  <span class=\"hljs-attr\">:checked</span>=<span class=\"hljs-string\">\"foo\"</span>\n  @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">\"val =&gt; &#123; foo = val &#125;\"</span>\n  <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"some value\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-checkbox</span>&gt;</span></code></pre>\n</li>\n</ul>\n<h3 id=\"inheritAttrs\"><a href=\"#inheritAttrs\" class=\"headerlink\" title=\"inheritAttrs\"></a>inheritAttrs</h3><blockquote>\n<p>2.4.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>true</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 <code>inheritAttrs</code> 到 <code>false</code>，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例 property <code>$attrs</code> 可以让这些 attribute 生效，且可以通过 <code>v-bind</code> 显性的绑定到非根元素上。</p>\n<p>注意：这个选项<strong>不影响</strong> <code>class</code> 和 <code>style</code> 绑定。</p>\n</li>\n</ul>\n<h3 id=\"comments\"><a href=\"#comments\" class=\"headerlink\" title=\"comments\"></a>comments</h3><blockquote>\n<p>2.4.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>false</code></p>\n</li>\n<li><p><strong>限制</strong>：这个选项只在完整构建版本中的浏览器内编译时可用。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当设为 <code>true</code> 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。</p>\n</li>\n</ul>\n<h2 id=\"实例-property\"><a href=\"#实例-property\" class=\"headerlink\" title=\"实例 property\"></a>实例 property</h2><h3 id=\"vm-data\"><a href=\"#vm-data\" class=\"headerlink\" title=\"vm.$data\"></a>vm.$data</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象 property 的访问。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"#data\">选项 / 数据 - data</a></p>\n</li>\n</ul>\n<h3 id=\"vm-props\"><a href=\"#vm-props\" class=\"headerlink\" title=\"vm.$props\"></a>vm.$props</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象 property 的访问。</p>\n</li>\n</ul>\n<h3 id=\"vm-el\"><a href=\"#vm-el\" class=\"headerlink\" title=\"vm.$el\"></a>vm.$el</h3><ul>\n<li><p><strong>类型</strong>：<code>Element</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>Vue 实例使用的根 DOM 元素。</p>\n</li>\n</ul>\n<h3 id=\"vm-options\"><a href=\"#vm-options\" class=\"headerlink\" title=\"vm.$options\"></a>vm.$options</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>用于当前 Vue 实例的初始化选项。需要在选项中包含自定义 property 时会有用处：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">customOption</span>: <span class=\"hljs-string\">'foo'</span>,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$options.customOption) <span class=\"hljs-comment\">// =&gt; 'foo'</span>\n  &#125;\n&#125;)</code></pre>\n</li>\n</ul>\n<h3 id=\"vm-parent\"><a href=\"#vm-parent\" class=\"headerlink\" title=\"vm.$parent\"></a>vm.$parent</h3><ul>\n<li><p><strong>类型</strong>：<code>Vue instance</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>父实例，如果当前实例有的话。</p>\n</li>\n</ul>\n<h3 id=\"vm-root\"><a href=\"#vm-root\" class=\"headerlink\" title=\"vm.$root\"></a>vm.$root</h3><ul>\n<li><p><strong>类型</strong>：<code>Vue instance</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。</p>\n</li>\n</ul>\n<h3 id=\"vm-children\"><a href=\"#vm-children\" class=\"headerlink\" title=\"vm.$children\"></a>vm.$children</h3><ul>\n<li><p><strong>类型</strong>：<code>Array&lt;Vue instance&gt;</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当前实例的直接子组件。<strong>需要注意 <code>$children</code> 并不保证顺序，也不是响应式的。</strong>如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 Array 作为真正的来源。</p>\n</li>\n</ul>\n<h3 id=\"vm-slots\"><a href=\"#vm-slots\" class=\"headerlink\" title=\"vm.$slots\"></a>vm.$slots</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [name: string]: ?Array&lt;VNode&gt; }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>用来访问被<a href=\"../guide/components.html#通过插槽分发内容\">插槽分发</a>的内容。每个<a href=\"../guide/components-slots.html#具名插槽\">具名插槽</a>有其相应的 property (例如：<code>v-slot:foo</code> 中的内容将会在 <code>vm.$slots.foo</code> 中被找到)。<code>default</code> property 包括了所有没有被包含在具名插槽中的节点，或 <code>v-slot:default</code> 的内容。</p>\n<p><strong>注意：</strong><code>v-slot:foo</code> 在 2.6 以上的版本才支持。对于之前的版本，你可以使用<a href=\"../guide/components-slots.html#废弃了的语法\">废弃了的语法</a>。</p>\n<p>在使用<a href=\"../guide/render-function.html\">渲染函数</a>书写一个组件时，访问 <code>vm.$slots</code> 最有帮助。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>About Me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Copyright 2016 Evan You<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>.\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> header = <span class=\"hljs-keyword\">this</span>.$slots.header\n    <span class=\"hljs-keyword\">var</span> body   = <span class=\"hljs-keyword\">this</span>.$slots.default\n    <span class=\"hljs-keyword\">var</span> footer = <span class=\"hljs-keyword\">this</span>.$slots.footer\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, [\n      createElement(<span class=\"hljs-string\">'header'</span>, header),\n      createElement(<span class=\"hljs-string\">'main'</span>, body),\n      createElement(<span class=\"hljs-string\">'footer'</span>, footer)\n    ])\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"#slot\"><code>&lt;slot&gt;</code> 组件</a></li>\n<li><a href=\"../guide/components.html#通过插槽分发内容\">通过插槽分发内容</a></li>\n<li><a href=\"../guide/render-function.html#插槽\">渲染函数 - 插槽</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-scopedSlots\"><a href=\"#vm-scopedSlots\" class=\"headerlink\" title=\"vm.$scopedSlots\"></a>vm.$scopedSlots</h3><blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>{ [name: string]: props =&gt; Array&lt;VNode&gt; | undefined }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>用来访问<a href=\"../guide/components-slots.html#作用域插槽\">作用域插槽</a>。对于包括 <code>默认 slot</code> 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。</p>\n<p><code>vm.$scopedSlots</code> 在使用<a href=\"../guide/render-function.html\">渲染函数</a>开发一个组件时特别有用。</p>\n<p><strong>注意</strong>：从 2.6.0 开始，这个 property 有两个变化：</p>\n<ol>\n<li><p>作用域插槽函数现在保证返回一个 VNode 数组，除非在返回值无效的情况下返回 <code>undefined</code>。</p>\n</li>\n<li><p>所有的 <code>$slots</code> 现在都会作为函数暴露在 <code>$scopedSlots</code> 中。如果你在使用渲染函数，不论当前插槽是否带有作用域，我们都推荐始终通过 <code>$scopedSlots</code> 访问它们。这不仅仅使得在未来添加作用域变得简单，也可以让你最终轻松迁移到所有插槽都是函数的 Vue 3。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"#slot\"><code>&lt;slot&gt;</code> 组件</a></li>\n<li><a href=\"../guide/components-slots.html#作用域插槽\">作用域插槽</a></li>\n<li><a href=\"../guide/render-function.html#插槽\">渲染函数 - 插槽</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-refs\"><a href=\"#vm-refs\" class=\"headerlink\" title=\"vm.$refs\"></a>vm.$refs</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>一个对象，持有注册过 <a href=\"#ref\"><code>ref</code> attribute</a> 的所有 DOM 元素和组件实例。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/components-edge-cases.html#访问子组件实例或子元素\">子组件 ref</a></li>\n<li><a href=\"#ref\">特殊 attribute - ref</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-isServer\"><a href=\"#vm-isServer\" class=\"headerlink\" title=\"vm.$isServer\"></a>vm.$isServer</h3><ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当前 Vue 实例是否运行于服务器。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/ssr.html\">服务端渲染</a></p>\n</li>\n</ul>\n<h3 id=\"vm-attrs\"><a href=\"#vm-attrs\" class=\"headerlink\" title=\"vm.$attrs\"></a>vm.$attrs</h3><blockquote>\n<p>2.4.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: string }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (<code>class</code> 和 <code>style</code> 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (<code>class</code> 和 <code>style</code> 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</p>\n</li>\n</ul>\n<h3 id=\"vm-listeners\"><a href=\"#vm-listeners\" class=\"headerlink\" title=\"vm.$listeners\"></a>vm.$listeners</h3><blockquote>\n<p>2.4.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: Function | Array&lt;Function&gt; }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</p>\n</li>\n</ul>\n<h2 id=\"实例方法-数据\"><a href=\"#实例方法-数据\" class=\"headerlink\" title=\"实例方法 / 数据\"></a>实例方法 / 数据</h2><h3 id=\"vm-watch-expOrFn-callback-options\"><a href=\"#vm-watch-expOrFn-callback-options\" class=\"headerlink\" title=\"vm.$watch( expOrFn, callback, [options] )\"></a>vm.$watch( expOrFn, callback, [options] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string | Function} expOrFn</code></li>\n<li><code>{Function | Object} callback</code></li>\n<li><code>{Object} [options]</code><ul>\n<li><code>{boolean} deep</code></li>\n<li><code>{boolean} immediate</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>返回值</strong>：<code>{Function} unwatch</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代。</p>\n<p class=\"tip\">注意：在变更 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变更之前值的副本。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 键路径</span>\nvm.$watch(<span class=\"hljs-string\">'a.b.c'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newVal, oldVal</span>) </span>&#123;\n  <span class=\"hljs-comment\">// 做点什么</span>\n&#125;)\n\n<span class=\"hljs-comment\">// 函数</span>\nvm.$watch(\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// 表达式 `this.a + this.b` 每次得出一个不同的结果时</span>\n    <span class=\"hljs-comment\">// 处理函数都会被调用。</span>\n    <span class=\"hljs-comment\">// 这就像监听一个未被定义的计算属性</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a + <span class=\"hljs-keyword\">this</span>.b\n  &#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newVal, oldVal</span>) </span>&#123;\n    <span class=\"hljs-comment\">// 做点什么</span>\n  &#125;\n)</code></pre>\n<p><code>vm.$watch</code> 返回一个取消观察函数，用来停止触发回调：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(<span class=\"hljs-string\">'a'</span>, cb)\n<span class=\"hljs-comment\">// 之后取消观察</span>\nunwatch()</code></pre>\n</li>\n<li><p><strong>选项：deep</strong></p>\n<p>为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code>。注意监听数组的变更不需要这么做。</p>\n<pre><code class=\"hljs js\">vm.$watch(<span class=\"hljs-string\">'someObject'</span>, callback, &#123;\n  <span class=\"hljs-attr\">deep</span>: <span class=\"hljs-literal\">true</span>\n&#125;)\nvm.someObject.nestedValue = <span class=\"hljs-number\">123</span>\n<span class=\"hljs-comment\">// callback is fired</span></code></pre>\n</li>\n<li><p><strong>选项：immediate</strong></p>\n<p>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调：</p>\n<pre><code class=\"hljs js\">vm.$watch(<span class=\"hljs-string\">'a'</span>, callback, &#123;\n  <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span>\n&#125;)\n<span class=\"hljs-comment\">// 立即以 `a` 的当前值触发回调</span></code></pre>\n<p>注意在带有 <code>immediate</code> 选项时，你不能在第一次回调时取消侦听给定的 property。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 这会导致报错</span>\n<span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(\n  <span class=\"hljs-string\">'value'</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    doSomething()\n    unwatch()\n  &#125;,\n  &#123; <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span> &#125;\n)</code></pre>\n<p>如果你仍然希望在回调内部调用一个取消侦听的函数，你应该先检查其函数的可用性：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(\n  <span class=\"hljs-string\">'value'</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    doSomething()\n    <span class=\"hljs-keyword\">if</span> (unwatch) &#123;\n      unwatch()\n    &#125;\n  &#125;,\n  &#123; <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span> &#125;\n)</code></pre>\n</li>\n</ul>\n<h3 id=\"vm-set-target-propertyName-index-value\"><a href=\"#vm-set-target-propertyName-index-value\" class=\"headerlink\" title=\"vm.$set( target, propertyName/index, value )\"></a>vm.$set( target, propertyName/index, value )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>返回值</strong>：设置的值。</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>这是全局 <code>Vue.set</code> 的<strong>别名</strong>。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"#Vue-set\">Vue.set</a></p>\n</li>\n</ul>\n<h3 id=\"vm-delete-target-propertyName-index\"><a href=\"#vm-delete-target-propertyName-index\" class=\"headerlink\" title=\"vm.$delete( target, propertyName/index )\"></a>vm.$delete( target, propertyName/index )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>这是全局 <code>Vue.delete</code> 的<strong>别名</strong>。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"#Vue-delete\">Vue.delete</a></p>\n</li>\n</ul>\n<h2 id=\"实例方法-事件\"><a href=\"#实例方法-事件\" class=\"headerlink\" title=\"实例方法 / 事件\"></a>实例方法 / 事件</h2><h3 id=\"vm-on-event-callback\"><a href=\"#vm-on-event-callback\" class=\"headerlink\" title=\"vm.$on( event, callback )\"></a>vm.$on( event, callback )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string | Array&lt;string&gt;} event</code> (数组只在 2.2.0+ 中支持)</li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>监听当前实例上的自定义事件。事件可以由 <code>vm.$emit</code> 触发。回调函数会接收所有传入事件触发函数的额外参数。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\">vm.$on(<span class=\"hljs-string\">'test'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">msg</span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(msg)\n&#125;)\nvm.$emit(<span class=\"hljs-string\">'test'</span>, <span class=\"hljs-string\">'hi'</span>)\n<span class=\"hljs-comment\">// =&gt; \"hi\"</span></code></pre>\n</li>\n</ul>\n<h3 id=\"vm-once-event-callback\"><a href=\"#vm-once-event-callback\" class=\"headerlink\" title=\"vm.$once( event, callback )\"></a>vm.$once( event, callback )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。</p>\n</li>\n</ul>\n<h3 id=\"vm-off-event-callback\"><a href=\"#vm-off-event-callback\" class=\"headerlink\" title=\"vm.$off( [event, callback] )\"></a>vm.$off( [event, callback] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string | Array&lt;string&gt;} event</code> (只在 2.2.2+ 支持数组)</li>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>移除自定义事件监听器。</p>\n<ul>\n<li><p>如果没有提供参数，则移除所有的事件监听器；</p>\n</li>\n<li><p>如果只提供了事件，则移除该事件所有的监听器；</p>\n</li>\n<li><p>如果同时提供了事件与回调，则只移除这个回调的监听器。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-emit-eventName-…args\"><a href=\"#vm-emit-eventName-…args\" class=\"headerlink\" title=\"vm.$emit( eventName, […args] )\"></a>vm.$emit( eventName, […args] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} eventName</code></li>\n<li><code>[...args]</code></li>\n</ul>\n<p>触发当前实例上的事件。附加参数都会传给监听器回调。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<p>只配合一个事件名使用 <code>$emit</code>：</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'welcome-button'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;button v-on:click=\"$emit('welcome')\"&gt;\n      Click me to be welcomed\n    &lt;/button&gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"emit-example-simple\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">welcome-button</span> <span class=\"hljs-attr\">v-on:welcome</span>=<span class=\"hljs-string\">\"sayHi\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">welcome-button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#emit-example-simple'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">sayHi</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      alert(<span class=\"hljs-string\">'Hi!'</span>)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n  <div id=\"emit-example-simple\" class=\"demo\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  <script>\n    Vue.component('welcome-button', {\n      template: `\n        <button v-on:click=\"$emit('welcome')\">\n          Click me to be welcomed\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-simple',\n      methods: {\n        sayHi: function () {\n          alert('Hi!')\n        }\n      }\n    })\n  </script>\n  \n<p>配合额外的参数使用 <code>$emit</code>：</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'magic-eight-ball'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">possibleAdvice</span>: [<span class=\"hljs-string\">'Yes'</span>, <span class=\"hljs-string\">'No'</span>, <span class=\"hljs-string\">'Maybe'</span>]\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">giveAdvice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> randomAdviceIndex = <span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-keyword\">this</span>.possibleAdvice.length)\n      <span class=\"hljs-keyword\">this</span>.$emit(<span class=\"hljs-string\">'give-advice'</span>, <span class=\"hljs-keyword\">this</span>.possibleAdvice[randomAdviceIndex])\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;button v-on:click=\"giveAdvice\"&gt;\n      Click me for advice\n    &lt;/button&gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"emit-example-argument\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">magic-eight-ball</span> <span class=\"hljs-attr\">v-on:give-advice</span>=<span class=\"hljs-string\">\"showAdvice\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">magic-eight-ball</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#emit-example-argument'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">showAdvice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">advice</span>) </span>&#123;\n      alert(advice)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n  <div id=\"emit-example-argument\" class=\"demo\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  <script>\n    Vue.component('magic-eight-ball', {\n      data: function () {\n        return {\n          possibleAdvice: ['Yes', 'No', 'Maybe']\n        }\n      },\n      methods: {\n        giveAdvice: function () {\n          var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n          this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n        }\n      },\n      template: `\n        <button v-on:click=\"giveAdvice\">\n          Click me for advice\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-argument',\n      methods: {\n        showAdvice: function (advice) {\n          alert(advice)\n        }\n      }\n    })\n  </script>\n  \n</li>\n</ul>\n<h2 id=\"实例方法-生命周期\"><a href=\"#实例方法-生命周期\" class=\"headerlink\" title=\"实例方法 / 生命周期\"></a>实例方法 / 生命周期</h2><h3 id=\"vm-mount-elementOrSelector\"><a href=\"#vm-mount-elementOrSelector\" class=\"headerlink\" title=\"vm.$mount( [elementOrSelector] )\"></a>vm.$mount( [elementOrSelector] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Element | string} [elementOrSelector]</code></li>\n<li><code>{boolean} [hydrating]</code></li>\n</ul>\n</li>\n<li><p><strong>返回值</strong>：<code>vm</code> - 实例自身</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 <code>vm.$mount()</code> 手动地挂载一个未挂载的实例。</p>\n<p>如果没有提供 <code>elementOrSelector</code> 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。</p>\n<p>这个方法返回实例自身，因而可以链式调用其它实例方法。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> MyComponent = Vue.extend(&#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;Hello!&lt;/div&gt;'</span>\n&#125;)\n\n<span class=\"hljs-comment\">// 创建并挂载到 #app (会替换 #app)</span>\n<span class=\"hljs-keyword\">new</span> MyComponent().$mount(<span class=\"hljs-string\">'#app'</span>)\n\n<span class=\"hljs-comment\">// 同上</span>\n<span class=\"hljs-keyword\">new</span> MyComponent(&#123; <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span> &#125;)\n\n<span class=\"hljs-comment\">// 或者，在文档之外渲染并且随后挂载</span>\n<span class=\"hljs-keyword\">var</span> component = <span class=\"hljs-keyword\">new</span> MyComponent().$mount()\n<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'app'</span>).appendChild(component.$el)</code></pre>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></li>\n<li><a href=\"../guide/ssr.html\">服务端渲染</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-forceUpdate\"><a href=\"#vm-forceUpdate\" class=\"headerlink\" title=\"vm.$forceUpdate()\"></a>vm.$forceUpdate()</h3><ul>\n<li><p><strong>示例</strong>：</p>\n<p>迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>\n</li>\n</ul>\n<h3 id=\"vm-nextTick-callback\"><a href=\"#vm-nextTick-callback\" class=\"headerlink\" title=\"vm.$nextTick( [callback] )\"></a>vm.$nextTick( [callback] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 <code>Vue.nextTick</code> 一样，不同的是回调的 <code>this</code> 自动绑定到调用它的实例上。</p>\n<blockquote>\n<p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise (IE：你们都看我干嘛)，你得自行 polyfill。</p>\n</blockquote>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-attr\">example</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// 修改数据</span>\n      <span class=\"hljs-keyword\">this</span>.message = <span class=\"hljs-string\">'changed'</span>\n      <span class=\"hljs-comment\">// DOM 还没有更新</span>\n      <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-comment\">// DOM 现在更新了</span>\n        <span class=\"hljs-comment\">// `this` 绑定到当前实例</span>\n        <span class=\"hljs-keyword\">this</span>.doSomethingElse()\n      &#125;)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>参考</strong></p>\n<ul>\n<li><a href=\"#Vue-nextTick\">Vue.nextTick</a></li>\n<li><a href=\"../guide/reactivity.html#异步更新队列\">异步更新队列</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-destroy\"><a href=\"#vm-destroy\" class=\"headerlink\" title=\"vm.$destroy()\"></a>vm.$destroy()</h3><ul>\n<li><p><strong>用法</strong>：</p>\n<p>完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。</p>\n<p>触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 的钩子。</p>\n<p class=\"tip\">在大多数场景中你不应该调用这个方法。最好使用 <code>v-if</code> 和 <code>v-for</code> 指令以数据驱动的方式控制子组件的生命周期。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><h3 id=\"v-text\"><a href=\"#v-text\" class=\"headerlink\" title=\"v-text\"></a>v-text</h3><ul>\n<li><p><strong>预期</strong>：<code>string</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>更新元素的 <code>textContent</code>。如果要更新部分的 <code>textContent</code>，需要使用 <code>{{ Mustache }}</code> 插值。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-text</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 和下面的一样 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/syntax.html#插值\">数据绑定语法 - 插值</a></p>\n</li>\n</ul>\n<h3 id=\"v-html\"><a href=\"#v-html\" class=\"headerlink\" title=\"v-html\"></a>v-html</h3><ul>\n<li><p><strong>预期</strong>：<code>string</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>更新元素的 <code>innerHTML</code>。<strong>注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong>。如果试图使用 <code>v-html</code> 组合模板，可以重新考虑是否通过使用组件来替代。</p>\n<p class=\"tip\">在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\" target=\"_blank\" rel=\"noopener\">XSS 攻击</a>。只在可信内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上。</p>\n\n<p class=\"tip\">在<a href=\"../guide/single-file-components.html\">单文件组件</a>里，<code>scoped</code> 的样式不会应用在 <code>v-html</code> 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 <code>v-html</code> 的内容设置带作用域的 CSS，你可以替换为 <a href=\"https://vue-loader.vuejs.org/en/features/css-modules.html\" target=\"_blank\" rel=\"noopener\">CSS Modules</a> 或用一个额外的全局 <code>&lt;style&gt;</code> 元素手动设置类似 BEM 的作用域策略。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"html\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/syntax.html#纯-HTML\">数据绑定语法 - 插值</a></p>\n</li>\n</ul>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><ul>\n<li><p><strong>预期</strong>：<code>any</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>根据表达式之真假值，切换元素的 <code>display</code> CSS property。</p>\n<p>当条件变化时该指令触发过渡效果。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/conditional.html#v-show\">条件渲染 - v-show</a></p>\n</li>\n</ul>\n<h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><ul>\n<li><p><strong>预期</strong>：<code>any</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>根据表达式的值的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy\" target=\"_blank\" rel=\"noopener\">truthiness</a> 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <code>&lt;template&gt;</code>，将提出它的内容作为条件块。</p>\n<p>当条件变化时该指令触发过渡效果。</p>\n<p class=\"tip\">当和 <code>v-if</code> 一起使用时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高。详见<a href=\"../guide/list.html#v-for-with-v-if\">列表渲染教程</a></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/conditional.html\">条件渲染 - v-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a>v-else</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>限制</strong>：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>为 <code>v-if</code> 或者 <code>v-else-if</code> 添加“else 块”。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"Math.random() &gt; 0.5\"</span>&gt;</span>\n  Now you see me\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Now you don't\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/conditional.html#v-else\">条件渲染 - v-else</a></p>\n</li>\n</ul>\n<h3 id=\"v-else-if\"><a href=\"#v-else-if\" class=\"headerlink\" title=\"v-else-if\"></a>v-else-if</h3><blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>any</code></p>\n</li>\n<li><p><strong>限制</strong>：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>表示 <code>v-if</code> 的“else if 块”。可以链式调用。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"type === 'A'\"</span>&gt;</span>\n  A\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'B'\"</span>&gt;</span>\n  B\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'C'\"</span>&gt;</span>\n  C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Not A/B/C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/conditional.html#v-else-if\">条件渲染 - v-else-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h3><ul>\n<li><p><strong>预期</strong>：<code>Array | Object | number | string | Iterable (2.6 新增)</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 <code>alias in expression</code>，为当前遍历的元素提供别名：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span>&gt;</span>\n  &#123;&#123; item.text &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>另外也可以为数组索引指定别名 (或者用于对象的键)：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(item, index) in items\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(val, key) in object\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(val, name, index) in object\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p><code>v-for</code> 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute <code>key</code> 来提供一个排序提示：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>\n  &#123;&#123; item.text &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>从 2.6 起，<code>v-for</code> 也可以在实现了<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#可迭代协议\" target=\"_blank\" rel=\"noopener\">可迭代协议</a>的值上使用，包括原生的 <code>Map</code> 和 <code>Set</code>。不过应该注意的是 Vue 2.x 目前并不支持可响应的 <code>Map</code> 和 <code>Set</code> 值，所以无法自动探测变更。</p>\n<p class=\"tip\">当和 <code>v-if</code> 一起使用时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高。详见<a href=\"../guide/list.html#v-for-with-v-if\">列表渲染教程</a></p>\n\n<p><code>v-for</code> 的详细用法可以通过以下链接查看教程详细说明。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/list.html\">列表渲染</a></li>\n<li><a href=\"../guide/list.html#key\">key</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h3><ul>\n<li><p><strong>缩写</strong>：<code>@</code></p>\n</li>\n<li><p><strong>预期</strong>：<code>Function | Inline Statement | Object</code></p>\n</li>\n<li><p><strong>参数</strong>：<code>event</code></p>\n</li>\n<li><p><strong>修饰符</strong>：</p>\n<ul>\n<li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</li>\n<li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</li>\n<li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</li>\n<li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>\n<li><code>.{keyCode | keyAlias}</code> - 只当事件是从特定键触发时才触发回调。</li>\n<li><code>.native</code> - 监听组件根元素的原生事件。</li>\n<li><code>.once</code> - 只触发一次回调。</li>\n<li><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</li>\n<li><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</li>\n<li><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</li>\n<li><code>.passive</code> - (2.3.0) 以 <code>{ passive: true }</code> 模式添加侦听器</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p>\n<p>用在普通元素上时，只能监听<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Events\" target=\"_blank\" rel=\"noopener\"><strong>原生 DOM 事件</strong></a>。用在自定义元素组件上时，也可以监听子组件触发的<strong>自定义事件</strong>。</p>\n<p>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 <code>$event</code> property：<code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>。</p>\n<p>从 <code>2.4.0</code> 开始，<code>v-on</code> 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 方法处理器 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态事件 (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:</span>[<span class=\"hljs-attr\">event</span>]=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 内联语句 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doThat('hello', $event)\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 缩写 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态事件缩写 (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @[<span class=\"hljs-attr\">event</span>]=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 停止冒泡 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.stop</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 阻止默认行为 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.prevent</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 阻止默认行为，没有表达式 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> @<span class=\"hljs-attr\">submit.prevent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!--  串联修饰符 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.stop.prevent</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 键修饰符，键别名 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> @<span class=\"hljs-attr\">keyup.enter</span>=<span class=\"hljs-string\">\"onEnter\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 键修饰符，键代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> @<span class=\"hljs-attr\">keyup.13</span>=<span class=\"hljs-string\">\"onEnter\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 点击回调只会触发一次 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click.once</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 对象语法 (2.4.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"&#123; mousedown: doThis, mouseup: doThat &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">my-event</span>=<span class=\"hljs-string\">\"handleThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 内联语句 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">my-event</span>=<span class=\"hljs-string\">\"handleThis(123, $event)\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 组件中的原生事件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">click.native</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/events.html\">事件处理器</a></li>\n<li><a href=\"../guide/components.html#监听子组件事件\">组件 - 自定义事件</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h3><ul>\n<li><p><strong>缩写</strong>：<code>:</code></p>\n</li>\n<li><p><strong>预期</strong>：<code>any (with argument) | Object (without argument)</code></p>\n</li>\n<li><p><strong>参数</strong>：<code>attrOrProp (optional)</code></p>\n</li>\n<li><p><strong>修饰符</strong>：</p>\n<ul>\n<li><code>.prop</code> - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(<a href=\"https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028\" target=\"_blank\" rel=\"noopener\">差别在哪里？</a>)</li>\n<li><code>.camel</code> - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)</li>\n<li><code>.sync</code> (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 <code>v-on</code> 侦听器。</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</p>\n<p>在绑定 <code>class</code> 或 <code>style</code> attribute 时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</p>\n<p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p>\n<p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 <code>class</code> 和 <code>style</code> 绑定不支持数组和对象。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 绑定一个 attribute --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">v-bind:src</span>=<span class=\"hljs-string\">\"imageSrc\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-bind:</span>[<span class=\"hljs-attr\">key</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 缩写 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">\"imageSrc\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">:</span>[<span class=\"hljs-attr\">key</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 内联字符串拼接 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">\"'/path/to/images/' + fileName\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- class 绑定 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"&#123; red: isRed &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[classA, classB]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[classA, &#123; classB: isB, classC: isC &#125;]\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- style 绑定 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"&#123; fontSize: size + 'px' &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"[styleObjectA, styleObjectB]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 绑定一个全是 attribute 的对象 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"&#123; id: someProp, 'other-attr': otherProp &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:text-content.prop</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">:prop</span>=<span class=\"hljs-string\">\"someThing\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child-component</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"$props\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">child-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- XLink --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:xlink:special</span>=<span class=\"hljs-string\">\"foo\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span></code></pre>\n<p><code>.camel</code> 修饰符允许在使用 DOM 模板时将 <code>v-bind</code> property 名称驼峰化，例如 SVG 的 <code>viewBox</code> property：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">:view-box.camel</span>=<span class=\"hljs-string\">\"viewBox\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span></code></pre>\n<p>在使用字符串模板或通过 <code>vue-loader</code>/<code>vueify</code> 编译时，无需使用 <code>.camel</code>。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/class-and-style.html\">Class 与 Style 绑定</a></li>\n<li><a href=\"../guide/components.html#通过-Prop-向子组件传递数据\">组件 - Props</a></li>\n<li><a href=\"../guide/components-custom-events.html#sync-修饰符\">组件 - <code>.sync</code> 修饰符</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h3><ul>\n<li><p><strong>预期</strong>：随表单控件类型不同而不同。</p>\n</li>\n<li><p><strong>限制</strong>：</p>\n<ul>\n<li><code>&lt;input&gt;</code></li>\n<li><code>&lt;select&gt;</code></li>\n<li><code>&lt;textarea&gt;</code></li>\n<li>components</li>\n</ul>\n</li>\n<li><p><strong>修饰符</strong>：</p>\n<ul>\n<li><a href=\"../guide/forms.html#lazy\"><code>.lazy</code></a> - 取代 <code>input</code> 监听 <code>change</code> 事件</li>\n<li><a href=\"../guide/forms.html#number\"><code>.number</code></a> - 输入字符串转为有效的数字</li>\n<li><a href=\"../guide/forms.html#trim\"><code>.trim</code></a> - 输入首尾空格过滤</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>在表单控件或者组件上创建双向绑定。细节请看下面的教程链接。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/forms.html\">表单控件绑定</a></li>\n<li><a href=\"../guide/components-custom-events.html#将原生事件绑定到组件\">组件 - 在输入组件上使用自定义事件</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-slot\"><a href=\"#v-slot\" class=\"headerlink\" title=\"v-slot\"></a>v-slot</h3><ul>\n<li><p><strong>缩写</strong>：<code>#</code></p>\n</li>\n<li><p><strong>预期</strong>：可放置在函数参数位置的 JavaScript 表达式 (在<a href=\"../guide/components-slots.html#解构插槽-Props\">支持的环境下</a>可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。</p>\n</li>\n<li><p><strong>参数</strong>：插槽名 (可选，默认值是 <code>default</code>)</p>\n</li>\n<li><p><strong>限用于</strong></p>\n<ul>\n<li><code>&lt;template&gt;</code></li>\n<li><a href=\"../guide/components-slots.html#独占默认插槽的缩写语法\">组件</a> (对于一个单独的带 prop 的默认插槽)</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>提供具名插槽或需要接收 prop 的插槽。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 具名插槽 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    Header content\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  Default slot content\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    Footer content\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 接收 prop 的具名插槽 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">infinite-scroll</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:item</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"item\"</span>&gt;</span>\n      &#123;&#123; slotProps.item.text &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">infinite-scroll</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 接收 prop 的默认插槽，使用了解构 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mouse-position</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; x, y &#125;\"</span>&gt;</span>\n  Mouse position: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mouse-position</span>&gt;</span></code></pre>\n<p>更多细节请查阅以下链接。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/components-slots.html\">组件 - 插槽</a></li>\n<li><a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md\" target=\"_blank\" rel=\"noopener\">RFC-0001</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-pre\"><a href=\"#v-pre\" class=\"headerlink\" title=\"v-pre\"></a>v-pre</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n</li>\n</ul>\n<h3 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-attr\">[v-cloak]</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: none;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-cloak</span>&gt;</span>\n  &#123;&#123; message &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p><div> 不会显示，直到编译结束。</div></p>\n</li>\n</ul>\n<h3 id=\"v-once\"><a href=\"#v-once\" class=\"headerlink\" title=\"v-once\"></a>v-once</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>只渲染元素和组件<strong>一次</strong>。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 单个元素 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 有子元素 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>comment<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 组件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-once</span> <span class=\"hljs-attr\">:comment</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- `v-for` 指令--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"i in list\"</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/syntax.html#插值\">数据绑定语法- 插值</a></li>\n<li><a href=\"../guide/components-edge-cases.html#通过-v-once-创建低开销的静态组件\">组件 - 对低开销的静态组件使用 <code>v-once</code></a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"特殊-attribute\"><a href=\"#特殊-attribute\" class=\"headerlink\" title=\"特殊 attribute\"></a>特殊 attribute</h2><h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><ul>\n<li><p><strong>预期</strong>：<code>number | string</code></p>\n<p><code>key</code> 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p>\n<p>有相同父元素的子元素必须有<strong>独特的 key</strong>。重复的 key 会造成渲染错误。</p>\n<p>最常见的用例是结合 <code>v-for</code>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p>\n<ul>\n<li>完整地触发组件的生命周期钩子</li>\n<li>触发过渡</li>\n</ul>\n<p>例如：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span></code></pre>\n<p>当 <code>text</code> 发生改变时，<code>&lt;span&gt;</code> 总是会被替换而不是被修改，因此会触发过渡。</p>\n</li>\n</ul>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><p><strong>预期</strong>：<code>string</code></p>\n<p><code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"p\"</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- `vm.$refs.child` will be the child component instance --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child-component</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"child\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">child-component</span>&gt;</span></code></pre>\n<p>当 <code>v-for</code> 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。</p>\n<p>关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components-edge-cases.html#访问子组件实例或子元素\">子组件 ref</a></p>\n</li>\n</ul>\n<h3 id=\"is\"><a href=\"#is\" class=\"headerlink\" title=\"is\"></a>is</h3><ul>\n<li><p><strong>预期</strong>：<code>string | Object (组件的选项对象)</code></p>\n<p>用于<a href=\"../guide/components.html#动态组件\">动态组件</a>且基于 <a href=\"../guide/components.html#解析-DOM-模板时的注意事项\">DOM 内模板的限制</a>来工作。</p>\n<p>示例：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">v-bind:is</span>=<span class=\"hljs-string\">\"currentView\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">is</span>=<span class=\"hljs-string\">\"my-row\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></code></pre>\n<p>更多的使用细节，请移步至下面的链接。</p>\n</li>\n<li><p><strong>See also</strong>：</p>\n<ul>\n<li><a href=\"../guide/components.html#动态组件\">动态组件</a></li>\n<li><a href=\"../guide/components.html#解析-DOM-模板时的注意事项\">DOM 模板解析说明</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"slot-废弃\"><a href=\"#slot-废弃\" class=\"headerlink\" title=\"slot 废弃\"></a>slot <sup style=\"color:#c92222\">废弃</sup></h3><p><strong>推荐 2.6.0 新增的 <a href=\"#v-slot\">v-slot</a>。</strong></p>\n<ul>\n<li><p><strong>预期</strong>：<code>string</code></p>\n<p>用于标记往哪个具名插槽中插入子组件内容。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components-slots.html#具名插槽\">具名插槽</a></p>\n</li>\n</ul>\n<h3 id=\"slot-scope-废弃\"><a href=\"#slot-scope-废弃\" class=\"headerlink\" title=\"slot-scope 废弃\"></a>slot-scope <sup style=\"color:#c92222\">废弃</sup></h3><p><strong>推荐 2.6.0 新增的 <a href=\"#v-slot\">v-slot</a>。</strong></p>\n<ul>\n<li><p><strong>预期</strong>：<code>function argument expression</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>用于将元素或组件表示为作用域插槽。attribute 的值应该是可以出现在函数签名的参数位置的合法的 JavaScript 表达式。这意味着在支持的环境中，你还可以在表达式中使用 ES2015 解构。它在 2.5.0+ 中替代了 <a href=\"#scope-replaced\"><code>scope</code></a>。</p>\n<p>此 attribute 不支持动态绑定。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components-slots.html#作用域插槽\">作用域插槽</a></p>\n</li>\n</ul>\n<h3 id=\"scope-移除\"><a href=\"#scope-移除\" class=\"headerlink\" title=\"scope 移除\"></a>scope <sup style=\"color:#c92222\">移除</sup></h3><p><strong>被 2.5.0 新增的 <a href=\"#slot-scope\">slot-scope</a> 取代。推荐 2.6.0 新增的 <a href=\"#v-slot\">v-slot</a>。</strong></p>\n<p>用于表示一个作为带作用域的插槽的 <code>&lt;template&gt;</code> 元素，它在 2.5.0+ 中被 <a href=\"#slot-scope\"><code>slot-scope</code></a> 替代。</p>\n<ul>\n<li><p><strong>用法：</strong></p>\n<p>除了 <code>scope</code> 只可以用于 <code>&lt;template&gt;</code> 元素，其它和 <a href=\"#slot-scope\"><code>slot-scope</code></a> 都相同。</p>\n</li>\n</ul>\n<h2 id=\"内置的组件\"><a href=\"#内置的组件\" class=\"headerlink\" title=\"内置的组件\"></a>内置的组件</h2><h3 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h3><ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>\n<li><code>inline-template</code> - boolean</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>渲染一个“元组件”为动态组件。依 <code>is</code> 的值，来决定哪个组件被渲染。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 动态组件由 vm 实例的 `componentId` property 控制 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"componentId\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"$options.components.child\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components.html#动态组件\">动态组件</a></p>\n</li>\n</ul>\n<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>name</code> - string，用于自动生成 CSS 过渡类名。例如：<code>name: &#39;fade&#39;</code> 将自动拓展为 <code>.fade-enter</code>，<code>.fade-enter-active</code> 等。默认类名为 <code>&quot;v&quot;</code></li>\n<li><code>appear</code> - boolean，是否在初始渲染时使用过渡。默认为 <code>false</code>。</li>\n<li><code>css</code> - boolean，是否使用 CSS 过渡类。默认为 <code>true</code>。如果设置为 <code>false</code>，将只通过组件事件触发注册的 JavaScript 钩子。</li>\n<li><code>type</code> - string，指定过渡事件类型，侦听过渡何时结束。有效值为 <code>&quot;transition&quot;</code> 和 <code>&quot;animation&quot;</code>。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li>\n<li><code>mode</code> - string，控制离开/进入过渡的时间序列。有效的模式有 <code>&quot;out-in&quot;</code> 和 <code>&quot;in-out&quot;</code>；默认同时进行。</li>\n<li><code>duration</code> - number | { <code>enter</code>: number, <code>leave</code>: number } 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件。</li>\n<li><code>enter-class</code> - string</li>\n<li><code>leave-class</code> - string</li>\n<li><code>appear-class</code> - string</li>\n<li><code>enter-to-class</code> - string</li>\n<li><code>leave-to-class</code> - string</li>\n<li><code>appear-to-class</code> - string</li>\n<li><code>enter-active-class</code> - string</li>\n<li><code>leave-active-class</code> - string</li>\n<li><code>appear-active-class</code> - string</li>\n</ul>\n</li>\n<li><p><strong>事件</strong>：</p>\n<ul>\n<li><code>before-enter</code></li>\n<li><code>before-leave</code></li>\n<li><code>before-appear</code></li>\n<li><code>enter</code></li>\n<li><code>leave</code></li>\n<li><code>appear</code></li>\n<li><code>after-enter</code></li>\n<li><code>after-leave</code></li>\n<li><code>after-appear</code></li>\n<li><code>enter-cancelled</code></li>\n<li><code>leave-cancelled</code> (<code>v-show</code> only)</li>\n<li><code>appear-cancelled</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p><code>&lt;transition&gt;</code> 元素作为<strong>单个</strong>元素/组件的过渡效果。<code>&lt;transition&gt;</code> 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 简单元素 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>toggled content<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态组件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"fade\"</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">\"out-in\"</span> <span class=\"hljs-attr\">appear</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 事件钩子 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"transition-demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span> @<span class=\"hljs-attr\">after-enter</span>=<span class=\"hljs-string\">\"transitionComplete\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-show</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>toggled content<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  ...\n  methods: &#123;\n    <span class=\"hljs-attr\">transitionComplete</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el</span>) </span>&#123;\n      <span class=\"hljs-comment\">// 传入 'el' 这个 DOM 元素作为参数。</span>\n    &#125;\n  &#125;\n  ...\n&#125;).$mount(<span class=\"hljs-string\">'#transition-demo'</span>)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/transitions.html\">过渡：进入，离开和列表</a></p>\n</li>\n</ul>\n<h3 id=\"transition-group\"><a href=\"#transition-group\" class=\"headerlink\" title=\"transition-group\"></a>transition-group</h3><ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>tag</code> - string，默认为 <code>span</code></li>\n<li><code>move-class</code> - 覆盖移动过渡期间应用的 CSS 类。</li>\n<li>除了 <code>mode</code>，其他 attribute 和 <code>&lt;transition&gt;</code> 相同。</li>\n</ul>\n</li>\n<li><p><strong>事件</strong>：</p>\n<ul>\n<li>事件和 <code>&lt;transition&gt;</code> 相同。</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p><code>&lt;transition-group&gt;</code> 元素作为多个元素/组件的过渡效果。<code>&lt;transition-group&gt;</code> 渲染一个真实的 DOM 元素。默认渲染 <code>&lt;span&gt;</code>，可以通过 <code>tag</code> attribute 配置哪个元素应该被渲染。</p>\n<p>注意，每个 <code>&lt;transition-group&gt;</code> 的子节点必须有<strong>独立的 key</strong>，动画才能正常工作</p>\n<p><code>&lt;transition-group&gt;</code> 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它会被应用一个移动中的 CSS 类 (通过 <code>name</code> attribute 或配置 <code>move-class</code> attribute 自动生成)。如果 CSS <code>transform</code> property 是“可过渡”property，当应用移动类时，将会使用 <a href=\"https://aerotwist.com/blog/flip-your-animations/\" target=\"_blank\" rel=\"noopener\">FLIP 技术</a>使元素流畅地到达动画终点。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition-group</span> <span class=\"hljs-attr\">tag</span>=<span class=\"hljs-string\">\"ul\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"slide\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>\n    &#123;&#123; item.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition-group</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/transitions.html\">过渡：进入，离开和列表</a></p>\n</li>\n</ul>\n<h3 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a>keep-alive</h3><ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>\n<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>\n<li><code>max</code> - 数字。最多可以缓存多少组件实例。</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p>\n<p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>\n<blockquote>\n<p>在 2.2.0 及其更高版本中，<code>activated</code> 和 <code>deactivated</code> 将会在 <code>&lt;keep-alive&gt;</code> 树内的所有嵌套组件中触发。</p>\n</blockquote>\n<p>主要用于保留组件状态或避免重新渲染。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 基本 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 多个条件判断的子组件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">comp-a</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"a &gt; 1\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">comp-a</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">comp-b</span> <span class=\"hljs-attr\">v-else</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">comp-b</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span></code></pre>\n<p>注意，<code>&lt;keep-alive&gt;</code> 是用在其一个直属的子组件被开关的情形。如果你在其中有 <code>v-for</code> 则不会工作。如果有上述的多个条件性的子元素，<code>&lt;keep-alive&gt;</code> 要求同时只有一个子元素被渲染。</p>\n</li>\n<li><p><strong><code>include</code> and <code>exclude</code></strong></p>\n<blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<p><code>include</code> 和 <code>exclude</code> prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 逗号分隔字符串 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">include</span>=<span class=\"hljs-string\">\"a,b\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:include</span>=<span class=\"hljs-string\">\"/a|b/\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 数组 (使用 `v-bind`) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:include</span>=<span class=\"hljs-string\">\"['a', 'b']\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p>匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)。匿名组件不能被匹配。</p>\n</li>\n<li><p><strong><code>max</code></strong></p>\n<blockquote>\n<p>2.5.0 新增</p>\n</blockquote>\n<p>最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:max</span>=<span class=\"hljs-string\">\"10\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p class=\"tip\"><code>&lt;keep-alive&gt;</code> 不会在函数式组件中正常工作，因为它们没有缓存实例。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components-dynamic-async.html#在动态组件上使用-keep-alive\">动态组件 - keep-alive</a></p>\n</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>name</code> - string，用于命名插槽。</li>\n</ul>\n</li>\n<li><p><strong>Usage</strong>：</p>\n<p><code>&lt;slot&gt;</code> 元素作为组件模板之中的内容分发插槽。<code>&lt;slot&gt;</code> 元素自身将被替换。</p>\n<p>详细用法，请参考下面教程的链接。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components.html#通过插槽分发内容\">通过插槽分发内容</a></p>\n</li>\n</ul>\n<h2 id=\"VNode-接口\"><a href=\"#VNode-接口\" class=\"headerlink\" title=\"VNode 接口\"></a>VNode 接口</h2><ul>\n<li>请参考 <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js\" target=\"_blank\" rel=\"noopener\">VNode class declaration</a>。</li>\n</ul>\n<h2 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h2><ul>\n<li>请参考 <a href=\"https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer\" target=\"_blank\" rel=\"noopener\">vue-server-renderer package documentation</a>。</li>\n</ul>\n<!-- zhlint ignore: { `enter`: number, `leave`: number } -->\n<!-- zhlint ignore: ( , ) -->\n<!-- zhlint ignore: vm.$destroy() -->\n<!-- zhlint ignore: vm.$forceUpdate() -->\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><p><code>Vue.config</code> 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property：</p>\n<h3 id=\"silent\"><a href=\"#silent\" class=\"headerlink\" title=\"silent\"></a>silent</h3><ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>false</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.silent = <span class=\"hljs-literal\">true</span></code></pre>\n<p>取消 Vue 所有的日志与警告。</p>\n</li>\n</ul>\n<h3 id=\"optionMergeStrategies\"><a href=\"#optionMergeStrategies\" class=\"headerlink\" title=\"optionMergeStrategies\"></a>optionMergeStrategies</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>{}</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.optionMergeStrategies._my_option = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">parent, child, vm</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> child + <span class=\"hljs-number\">1</span>\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Profile = Vue.extend(&#123;\n  <span class=\"hljs-attr\">_my_option</span>: <span class=\"hljs-number\">1</span>\n&#125;)\n\n<span class=\"hljs-comment\">// Profile.options._my_option = 2</span></code></pre>\n<p>自定义合并策略的选项。</p>\n<p>合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。</p>\n</li>\n<li><p><strong>参考</strong><a href=\"../guide/mixins.html#自定义选项混入策略\">自定义选项的混入策略</a></p>\n</li>\n</ul>\n<h3 id=\"devtools\"><a href=\"#devtools\" class=\"headerlink\" title=\"devtools\"></a>devtools</h3><ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>true</code> (生产版为 <code>false</code>)</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 务必在加载 Vue 之后，立即同步设置以下内容</span>\nVue.config.devtools = <span class=\"hljs-literal\">true</span></code></pre>\n<p>配置是否允许 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a> 检查代码。开发版本默认为 <code>true</code>，生产版本默认为 <code>false</code>。生产版本设为 <code>true</code> 可以启用检查。</p>\n</li>\n</ul>\n<h3 id=\"errorHandler\"><a href=\"#errorHandler\" class=\"headerlink\" title=\"errorHandler\"></a>errorHandler</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>undefined</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.errorHandler = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, vm, info</span>) </span>&#123;\n  <span class=\"hljs-comment\">// handle error</span>\n  <span class=\"hljs-comment\">// `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span>\n  <span class=\"hljs-comment\">// 只在 2.2.0+ 可用</span>\n&#125;</code></pre>\n<p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p>\n<blockquote>\n<p>从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩溃。</p>\n</blockquote>\n<blockquote>\n<p>从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。</p>\n</blockquote>\n<blockquote>\n<p>从 2.6.0 起，这个钩子也会捕获 <code>v-on</code> DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。</p>\n</blockquote>\n<blockquote>\n<p>错误追踪服务 <a href=\"https://sentry.io\" target=\"_blank\" rel=\"noopener\">Sentry</a> 和 <a href=\"https://docs.bugsnag.com/platforms/browsers/vue/\" target=\"_blank\" rel=\"noopener\">Bugsnag</a> 都通过此选项提供了官方支持。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"warnHandler\"><a href=\"#warnHandler\" class=\"headerlink\" title=\"warnHandler\"></a>warnHandler</h3><blockquote>\n<p>2.4.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>undefined</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.warnHandler = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">msg, vm, trace</span>) </span>&#123;\n  <span class=\"hljs-comment\">// `trace` 是组件的继承关系追踪</span>\n&#125;</code></pre>\n<p>为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。</p>\n</li>\n</ul>\n<h3 id=\"ignoredElements\"><a href=\"#ignoredElements\" class=\"headerlink\" title=\"ignoredElements\"></a>ignoredElements</h3><ul>\n<li><p><strong>类型</strong>：<code>Array&lt;string | RegExp&gt;</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>[]</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.ignoredElements = [\n  'my-custom-web-component',\n  'another-web-component',\n  // 用一个 `RegExp` 忽略所有“ion-”开头的元素\n  // 仅在 2.5+ 支持\n  /^ion-/\n]</code></pre>\n<p>须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 <code>Unknown custom element</code> 的警告。</p>\n</li>\n</ul>\n<h3 id=\"keyCodes\"><a href=\"#keyCodes\" class=\"headerlink\" title=\"keyCodes\"></a>keyCodes</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: number | Array&lt;number&gt; }</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>{}</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\">Vue.config.keyCodes = &#123;\n  <span class=\"hljs-attr\">v</span>: <span class=\"hljs-number\">86</span>,\n  <span class=\"hljs-attr\">f1</span>: <span class=\"hljs-number\">112</span>,\n  <span class=\"hljs-comment\">// camelCase 不可用</span>\n  <span class=\"hljs-attr\">mediaPlayPause</span>: <span class=\"hljs-number\">179</span>,\n  <span class=\"hljs-comment\">// 取而代之的是 kebab-case 且用双引号括起来</span>\n  <span class=\"hljs-string\">\"media-play-pause\"</span>: <span class=\"hljs-number\">179</span>,\n  <span class=\"hljs-attr\">up</span>: [<span class=\"hljs-number\">38</span>, <span class=\"hljs-number\">87</span>]\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> @<span class=\"hljs-attr\">keyup.media-play-pause</span>=<span class=\"hljs-string\">\"method\"</span>&gt;</span></code></pre>\n<p>给 <code>v-on</code> 自定义键位别名。</p>\n</li>\n</ul>\n<h3 id=\"performance\"><a href=\"#performance\" class=\"headerlink\" title=\"performance\"></a>performance</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>false (自 2.2.3 起)</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>设置为 <code>true</code> 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark\" target=\"_blank\" rel=\"noopener\"><code>performance.mark</code></a> API 的浏览器上。</p>\n</li>\n</ul>\n<h3 id=\"productionTip\"><a href=\"#productionTip\" class=\"headerlink\" title=\"productionTip\"></a>productionTip</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>true</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>设置为 <code>false</code> 以阻止 vue 在启动时生成生产提示。</p>\n</li>\n</ul>\n<h2 id=\"全局-API\"><a href=\"#全局-API\" class=\"headerlink\" title=\"全局 API\"></a>全局 API</h2><h3 id=\"Vue-extend-options\"><a href=\"#Vue-extend-options\" class=\"headerlink\" title=\"Vue.extend( options )\"></a>Vue.extend( options )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object} options</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>\n<p><code>data</code> 选项是特例，需要注意 - 在 <code>Vue.extend()</code> 中它必须是函数</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"mount-point\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 创建构造器</span>\n<span class=\"hljs-keyword\">var</span> Profile = Vue.extend(&#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Walter'</span>,\n      <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'White'</span>,\n      <span class=\"hljs-attr\">alias</span>: <span class=\"hljs-string\">'Heisenberg'</span>\n    &#125;\n  &#125;\n&#125;)\n<span class=\"hljs-comment\">// 创建 Profile 实例，并挂载到一个元素上。</span>\n<span class=\"hljs-keyword\">new</span> Profile().$mount(<span class=\"hljs-string\">'#mount-point'</span>)</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Walter White aka Heisenberg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components.html\">组件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-nextTick-callback-context\"><a href=\"#Vue-nextTick-callback-context\" class=\"headerlink\" title=\"Vue.nextTick( [callback, context] )\"></a>Vue.nextTick( [callback, context] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n<li><code>{Object} [context]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 修改数据</span>\nvm.msg = <span class=\"hljs-string\">'Hello'</span>\n<span class=\"hljs-comment\">// DOM 还没有更新</span>\nVue.nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// DOM 更新了</span>\n&#125;)\n\n<span class=\"hljs-comment\">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span>\nVue.nextTick()\n  .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// DOM 更新了</span>\n  &#125;)</code></pre>\n<blockquote>\n<p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。</p>\n</blockquote>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/reactivity.html#异步更新队列\">异步更新队列</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-set-target-propertyName-index-value\"><a href=\"#Vue-set-target-propertyName-index-value\" class=\"headerlink\" title=\"Vue.set( target, propertyName/index, value )\"></a>Vue.set( target, propertyName/index, value )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>返回值</strong>：设置的值。</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 <code>this.myObject.newProperty = &#39;hi&#39;</code>)</p>\n<p class=\"tip\">注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</p>\n\n</li>\n</ul>\n<h3 id=\"Vue-delete-target-propertyName-index\"><a href=\"#Vue-delete-target-propertyName-index\" class=\"headerlink\" title=\"Vue.delete( target, propertyName/index )\"></a>Vue.delete( target, propertyName/index )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n</ul>\n<blockquote>\n<p>仅在 2.2.0+ 版本中支持 Array + index 用法。</p>\n</blockquote>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。</p>\n<blockquote>\n<p>在 2.2.0+ 中同样支持在数组上工作。</p>\n</blockquote>\n<p class=\"tip\">目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-directive-id-definition\"><a href=\"#Vue-directive-id-definition\" class=\"headerlink\" title=\"Vue.directive( id, [definition] )\"></a>Vue.directive( id, [definition] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>注册或获取全局指令。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 注册</span>\nVue.directive(<span class=\"hljs-string\">'my-directive'</span>, &#123;\n  <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">componentUpdated</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">unbind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;\n&#125;)\n\n<span class=\"hljs-comment\">// 注册 (指令函数)</span>\nVue.directive(<span class=\"hljs-string\">'my-directive'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// 这里将会被 `bind` 和 `update` 调用</span>\n&#125;)\n\n<span class=\"hljs-comment\">// getter，返回已注册的指令</span>\n<span class=\"hljs-keyword\">var</span> myDirective = Vue.directive(<span class=\"hljs-string\">'my-directive'</span>)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/custom-directive.html\">自定义指令</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-filter-id-definition\"><a href=\"#Vue-filter-id-definition\" class=\"headerlink\" title=\"Vue.filter( id, [definition] )\"></a>Vue.filter( id, [definition] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>注册或获取全局过滤器。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 注册</span>\nVue.filter(<span class=\"hljs-string\">'my-filter'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-comment\">// 返回处理后的值</span>\n&#125;)\n\n<span class=\"hljs-comment\">// getter，返回已注册的过滤器</span>\n<span class=\"hljs-keyword\">var</span> myFilter = Vue.filter(<span class=\"hljs-string\">'my-filter'</span>)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/filters.html\">过滤器</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-component-id-definition\"><a href=\"#Vue-component-id-definition\" class=\"headerlink\" title=\"Vue.component( id, [definition] )\"></a>Vue.component( id, [definition] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>注册或获取全局组件。注册还会自动使用给定的 <code>id</code> 设置组件的名称</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 注册组件，传入一个扩展过的构造器</span>\nVue.component(<span class=\"hljs-string\">'my-component'</span>, Vue.extend(&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;))\n\n<span class=\"hljs-comment\">// 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span>\nVue.component(<span class=\"hljs-string\">'my-component'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)\n\n<span class=\"hljs-comment\">// 获取注册的组件 (始终返回构造器)</span>\n<span class=\"hljs-keyword\">var</span> MyComponent = Vue.component(<span class=\"hljs-string\">'my-component'</span>)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components.html\">组件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-use-plugin\"><a href=\"#Vue-use-plugin\" class=\"headerlink\" title=\"Vue.use( plugin )\"></a>Vue.use( plugin )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object | Function} plugin</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>安装 Vue.js 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。</p>\n<p>该方法需要在调用 <code>new Vue()</code> 之前被调用。</p>\n<p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/plugins.html\">插件</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-mixin-mixin\"><a href=\"#Vue-mixin-mixin\" class=\"headerlink\" title=\"Vue.mixin( mixin )\"></a>Vue.mixin( mixin )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object} mixin</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。<strong>不推荐在应用代码中使用</strong>。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/mixins.html#全局混入\">全局混入</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-compile-template\"><a href=\"#Vue-compile-template\" class=\"headerlink\" title=\"Vue.compile( template )\"></a>Vue.compile( template )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} template</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>将一个模板字符串编译成 render 函数。<strong>只在完整版时可用</strong>。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> res = Vue.compile(<span class=\"hljs-string\">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'hello'</span>\n  &#125;,\n  <span class=\"hljs-attr\">render</span>: res.render,\n  <span class=\"hljs-attr\">staticRenderFns</span>: res.staticRenderFns\n&#125;)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/render-function.html\">渲染函数</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-observable-object\"><a href=\"#Vue-observable-object\" class=\"headerlink\" title=\"Vue.observable( object )\"></a>Vue.observable( object )</h3><blockquote>\n<p>2.6.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object} object</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>让一个对象可响应。Vue 内部会用它来处理 <code>data</code> 函数返回的对象。</p>\n<p>返回的对象可以直接用于<a href=\"../guide/render-function.html\">渲染函数</a>和<a href=\"../guide/computed.html\">计算属性</a>内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> state = Vue.observable(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span> &#125;)\n\n<span class=\"hljs-keyword\">const</span> Demo = &#123;\n  render(h) &#123;\n    <span class=\"hljs-keyword\">return</span> h(<span class=\"hljs-string\">'button'</span>, &#123;\n      <span class=\"hljs-attr\">on</span>: &#123; <span class=\"hljs-attr\">click</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123; state.count++ &#125;&#125;\n    &#125;, <span class=\"hljs-string\">`count is: <span class=\"hljs-subst\">$&#123;state.count&#125;</span>`</span>)\n  &#125;\n&#125;</code></pre>\n<p class=\"tip\">在 Vue 2.x 中，被传入的对象会直接被 <code>Vue.observable</code> 变更，所以如<a href=\"../guide/instance.html#数据与方法\">这里展示的</a>，它和被返回的对象是同一个对象。在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的。因此，为了向前兼容，我们推荐始终操作使用 <code>Vue.observable</code> 返回的对象，而不是传入源对象。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-version\"><a href=\"#Vue-version\" class=\"headerlink\" title=\"Vue.version\"></a>Vue.version</h3><ul>\n<li><p><strong>细节</strong>：提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> version = <span class=\"hljs-built_in\">Number</span>(Vue.version.split(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>])\n\n<span class=\"hljs-keyword\">if</span> (version === <span class=\"hljs-number\">2</span>) &#123;\n  <span class=\"hljs-comment\">// Vue v2.x.x</span>\n&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (version === <span class=\"hljs-number\">1</span>) &#123;\n  <span class=\"hljs-comment\">// Vue v1.x.x</span>\n&#125; <span class=\"hljs-keyword\">else</span> &#123;\n  <span class=\"hljs-comment\">// Unsupported versions of Vue</span>\n&#125;</code></pre>\n</li>\n</ul>\n<h2 id=\"选项-数据\"><a href=\"#选项-数据\" class=\"headerlink\" title=\"选项 / 数据\"></a>选项 / 数据</h2><h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><ul>\n<li><p><strong>类型</strong>：<code>Object | Function</code></p>\n</li>\n<li><p><strong>限制</strong>：组件的定义只接受 <code>function</code>。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>Vue 实例的数据对象。Vue 将会递归将 data 的 property 转换为 getter/setter，从而让 data 的 property 能够响应数据变化。<strong>对象必须是纯粹的对象 (含有零个或多个的 key/value 对)</strong>：浏览器 API 创建的原生对象，原型上的 property 会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。</p>\n<p>一旦观察过，你就无法在根数据对象上添加响应式 property。因此推荐在创建实例之前，就声明所有的根级响应式 property。</p>\n<p>实例创建之后，可以通过 <code>vm.$data</code> 访问原始数据对象。Vue 实例也代理了 data 对象上所有的 property，因此访问 <code>vm.a</code> 等价于访问 <code>vm.$data.a</code>。</p>\n<p>以 <code>_</code> 或 <code>$</code> 开头的 property <strong>不会</strong>被 Vue 实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些 property。</p>\n<p>当一个<strong>组件</strong>被定义，<code>data</code> 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 <code>data</code> 仍然是一个纯粹的对象，则所有的实例将<strong>共享引用</strong>同一个数据对象！通过提供 <code>data</code> 函数，每次创建一个新实例后，我们能够调用 <code>data</code> 函数，从而返回初始数据的一个全新副本数据对象。</p>\n<p>如果需要，可以通过将 <code>vm.$data</code> 传入 <code>JSON.parse(JSON.stringify(...))</code> 得到深拷贝的原始数据对象。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> data = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n\n<span class=\"hljs-comment\">// 直接创建一个实例</span>\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: data\n&#125;)\nvm.a <span class=\"hljs-comment\">// =&gt; 1</span>\nvm.$data === data <span class=\"hljs-comment\">// =&gt; true</span>\n\n<span class=\"hljs-comment\">// Vue.extend() 中 data 必须是函数</span>\n<span class=\"hljs-keyword\">var</span> Component = Vue.extend(&#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n  &#125;\n&#125;)</code></pre>\n<p>注意，如果你为 <code>data</code> property 使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-params\">vm</span> =&gt;</span> (&#123; <span class=\"hljs-attr\">a</span>: vm.myProp &#125;)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/reactivity.html\">深入响应式原理</a></p>\n</li>\n</ul>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><ul>\n<li><p><strong>类型</strong>：<code>Array&lt;string&gt; | Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。</p>\n<p>你可以基于对象的语法使用以下选项：</p>\n<ul>\n<li><code>type</code>：可以是下列原生构造函数中的一种：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code>、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的<a href=\"../guide/components-props.html#Prop-类型\">更多信息在此</a>。</li>\n<li><code>default</code>：<code>any</code><br>为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。</li>\n<li><code>required</code>：<code>Boolean</code><br>定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。</li>\n<li><code>validator</code>：<code>Function</code><br>自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在<a href=\"../guide/components-props.html#Prop-验证\">这里</a>查阅更多 prop 验证的相关信息。</li>\n</ul>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 简单语法</span>\nVue.component(<span class=\"hljs-string\">'props-demo-simple'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'size'</span>, <span class=\"hljs-string\">'myMessage'</span>]\n&#125;)\n\n<span class=\"hljs-comment\">// 对象语法，提供验证</span>\nVue.component(<span class=\"hljs-string\">'props-demo-advanced'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// 检测类型</span>\n    <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">Number</span>,\n    <span class=\"hljs-comment\">// 检测类型 + 其他验证</span>\n    <span class=\"hljs-attr\">age</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> value &gt;= <span class=\"hljs-number\">0</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components-props.html\">Props</a></p>\n</li>\n</ul>\n<h3 id=\"propsData\"><a href=\"#propsData\" class=\"headerlink\" title=\"propsData\"></a>propsData</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: any }</code></p>\n</li>\n<li><p><strong>限制</strong>：只用于 <code>new</code> 创建的实例中。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>创建实例时传递 props。主要作用是方便测试。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> Comp = Vue.extend(&#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'msg'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span>\n&#125;)\n\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Comp(&#123;\n  <span class=\"hljs-attr\">propsData</span>: &#123;\n    <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'hello'</span>\n  &#125;\n&#125;)</code></pre>\n</li>\n</ul>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>\n<p>注意如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p>\n<pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">aDouble</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">vm</span> =&gt;</span> vm.a * <span class=\"hljs-number\">2</span>\n&#125;</code></pre>\n<p>计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是<strong>不会</strong>被更新的。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-comment\">// 仅读取</span>\n    <span class=\"hljs-attr\">aDouble</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a * <span class=\"hljs-number\">2</span>\n    &#125;,\n    <span class=\"hljs-comment\">// 读取和设置</span>\n    <span class=\"hljs-attr\">aPlus</span>: &#123;\n      <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a + <span class=\"hljs-number\">1</span>\n      &#125;,\n      <span class=\"hljs-attr\">set</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">v</span>) </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.a = v - <span class=\"hljs-number\">1</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;)\nvm.aPlus   <span class=\"hljs-comment\">// =&gt; 2</span>\nvm.aPlus = <span class=\"hljs-number\">3</span>\nvm.a       <span class=\"hljs-comment\">// =&gt; 2</span>\nvm.aDouble <span class=\"hljs-comment\">// =&gt; 4</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/computed.html\">计算属性</a></p>\n</li>\n</ul>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 <code>this</code> 自动绑定为 Vue 实例。</p>\n<p class=\"tip\">注意，<strong>不应该使用箭头函数来定义 method 函数</strong> (例如 <code>plus: () =&gt; this.a++</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">plus</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.a++\n    &#125;\n  &#125;\n&#125;)\nvm.plus()\nvm.a <span class=\"hljs-comment\">// 2</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/events.html\">事件处理器</a></p>\n</li>\n</ul>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: string | Function | Object | Array }</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个 property。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span>,\n    <span class=\"hljs-attr\">d</span>: <span class=\"hljs-number\">4</span>,\n    <span class=\"hljs-attr\">e</span>: &#123;\n      <span class=\"hljs-attr\">f</span>: &#123;\n        <span class=\"hljs-attr\">g</span>: <span class=\"hljs-number\">5</span>\n      &#125;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">watch</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'new: %s, old: %s'</span>, val, oldVal)\n    &#125;,\n    <span class=\"hljs-comment\">// 方法名</span>\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">'someMethod'</span>,\n    <span class=\"hljs-comment\">// 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</span>\n    <span class=\"hljs-attr\">c</span>: &#123;\n      <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n      <span class=\"hljs-attr\">deep</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-comment\">// 该回调将会在侦听开始之后被立即调用</span>\n    <span class=\"hljs-attr\">d</span>: &#123;\n      <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-string\">'someMethod'</span>,\n      <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-comment\">// 你可以传入回调数组，它们会被逐一调用</span>\n    <span class=\"hljs-attr\">e</span>: [\n      <span class=\"hljs-string\">'handle1'</span>,\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handle2</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n      &#123;\n        <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handle3</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n        <span class=\"hljs-comment\">/* ... */</span>\n      &#125;\n    ],\n    <span class=\"hljs-comment\">// watch vm.e.f's value: &#123;g: 5&#125;</span>\n    <span class=\"hljs-string\">'e.f'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n  &#125;\n&#125;)\nvm.a = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// =&gt; new: 2, old: 1</span></code></pre>\n<p class=\"tip\">注意，<strong>不应该使用箭头函数来定义 watcher 函数</strong> (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.updateAutocomplete</code> 将是 undefined。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"#vm-watch\">实例方法 / 数据 - vm.$watch</a></p>\n</li>\n</ul>\n<h2 id=\"选项-DOM\"><a href=\"#选项-DOM\" class=\"headerlink\" title=\"选项 / DOM\"></a>选项 / DOM</h2><h3 id=\"el\"><a href=\"#el\" class=\"headerlink\" title=\"el\"></a>el</h3><ul>\n<li><p><strong>类型</strong>：<code>string | Element</code></p>\n</li>\n<li><p><strong>限制</strong>：只在用 <code>new</code> 创建实例时生效。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p>\n<p>在实例挂载之后，元素可以用 <code>vm.$el</code> 访问。</p>\n<p>如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 <code>vm.$mount()</code> 手动开启编译。</p>\n<p class=\"tip\"> 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载 root 实例到 <code>&lt;html&gt;</code> 或者 <code>&lt;body&gt;</code> 上。</p>\n\n<p class=\"tip\">如果 <code>render</code> 函数和 <code>template</code> property 都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></li>\n<li><a href=\"../guide/installation.html#运行时-编译器-vs-只包含运行时\">运行时 + 编译器 vs. 只包含运行时</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h3><ul>\n<li><p><strong>类型</strong>：<code>string</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>一个字符串模板作为 Vue 实例的标识使用。模板将会<strong>替换</strong>挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</p>\n<p>如果值以 <code>#</code> 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <code>&lt;script type=&quot;x-template&quot;&gt;</code> 包含模板。</p>\n<p class=\"tip\">出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。</p>\n\n<p class=\"tip\">如果 Vue 选项中包含渲染函数，该模板将被忽略。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></li>\n<li><a href=\"../guide/components.html#通过插槽分发内容\">通过插槽分发内容</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><ul>\n<li><p><strong>类型</strong>：<code>(createElement: () =&gt; VNode) =&gt; VNode</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>。</p>\n<p>如果组件是一个函数组件，渲染函数还会接收一个额外的 <code>context</code> 参数，为没有实例的函数组件提供上下文信息。</p>\n<p class=\"tip\">Vue 选项中的 <code>render</code> 函数若存在，则 Vue 构造函数不会从 <code>template</code> 选项或通过 <code>el</code> 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/render-function.html\">渲染函数</a></p>\n</li>\n</ul>\n<h3 id=\"renderError\"><a href=\"#renderError\" class=\"headerlink\" title=\"renderError\"></a>renderError</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>(createElement: () =&gt; VNode, error: Error) =&gt; VNode</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p><strong>只在开发者环境下工作。</strong></p>\n<p>当 <code>render</code> 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 <code>renderError</code>。这个功能配合 hot-reload 非常实用。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  render (h) &#123;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'oops'</span>)\n  &#125;,\n  renderError (h, err) &#123;\n    <span class=\"hljs-keyword\">return</span> h(<span class=\"hljs-string\">'pre'</span>, &#123; <span class=\"hljs-attr\">style</span>: &#123; <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'red'</span> &#125;&#125;, err.stack)\n  &#125;\n&#125;).$mount(<span class=\"hljs-string\">'#app'</span>)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/render-function.html\">渲染函数</a></p>\n</li>\n</ul>\n<h2 id=\"选项-生命周期钩子\"><a href=\"#选项-生命周期钩子\" class=\"headerlink\" title=\"选项 / 生命周期钩子\"></a>选项 / 生命周期钩子</h2><p class=\"tip\">所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 Vue 实例不同，<code>this.fetchTodos</code> 的行为未定义。</p>\n\n<h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> property 目前尚不可用。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>\n<p>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a href=\"#vm-nextTick\">vm.$nextTick</a>：</p>\n<pre><code class=\"hljs js\">mounted: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// Code that will run only after the</span>\n    <span class=\"hljs-comment\">// entire view has been rendered</span>\n  &#125;)\n&#125;</code></pre>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>\n<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a href=\"#computed\">计算属性</a>或 <a href=\"#watch\">watcher</a> 取而代之。</p>\n<p>注意 <code>updated</code> <strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a href=\"#vm-nextTick\">vm.$nextTick</a>：</p>\n<pre><code class=\"hljs js\">updated: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// Code that will run only after the</span>\n    <span class=\"hljs-comment\">// entire view has been re-rendered</span>\n  &#125;)\n&#125;</code></pre>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>被 keep-alive 缓存的组件激活时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"#keep-alive\">构建组件 - keep-alive</a></li>\n<li><a href=\"../guide/components-dynamic-async.html#在动态组件上使用-keep-alive\">动态组件 - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>被 keep-alive 缓存的组件停用时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"#keep-alive\">构建组件 - keep-alive</a></li>\n<li><a href=\"../guide/components-dynamic-async.html#在动态组件上使用-keep-alive\">动态组件 - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h3 id=\"errorCaptured\"><a href=\"#errorCaptured\" class=\"headerlink\" title=\"errorCaptured\"></a>errorCaptured</h3><blockquote>\n<p>2.5.0+ 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p>\n<p class=\"tip\">你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p>\n\n<p><strong>错误传播规则</strong></p>\n<ul>\n<li><p>默认情况下，如果全局的 <code>config.errorHandler</code> 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</p>\n</li>\n<li><p>如果一个组件的继承或父级从属链路中存在多个 <code>errorCaptured</code> 钩子，则它们将会被相同的错误逐个唤起。</p>\n</li>\n<li><p>如果此 <code>errorCaptured</code> 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 <code>config.errorHandler</code>。</p>\n</li>\n<li><p>一个 <code>errorCaptured</code> 钩子能够返回 <code>false</code> 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 <code>errorCaptured</code> 钩子和全局的 <code>config.errorHandler</code>。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"选项-资源\"><a href=\"#选项-资源\" class=\"headerlink\" title=\"选项 / 资源\"></a>选项 / 资源</h2><h3 id=\"directives\"><a href=\"#directives\" class=\"headerlink\" title=\"directives\"></a>directives</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n</li>\n</ul>\n<p>包含 Vue 实例可用指令的哈希表。</p>\n<ul>\n<li><strong>参考</strong>：<a href=\"../guide/custom-directive.html\">自定义指令</a></li>\n</ul>\n<h3 id=\"filters\"><a href=\"#filters\" class=\"headerlink\" title=\"filters\"></a>filters</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n</li>\n</ul>\n<p>包含 Vue 实例可用过滤器的哈希表。</p>\n<ul>\n<li><strong>参考</strong>：<a href=\"#Vue-filter\"><code>Vue.filter</code></a></li>\n</ul>\n<h3 id=\"components\"><a href=\"#components\" class=\"headerlink\" title=\"components\"></a>components</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n</li>\n</ul>\n<p>包含 Vue 实例可用组件的哈希表。</p>\n<ul>\n<li><strong>参考</strong>：<a href=\"../guide/components.html\">组件</a></li>\n</ul>\n<h2 id=\"选项-组合\"><a href=\"#选项-组合\" class=\"headerlink\" title=\"选项 / 组合\"></a>选项 / 组合</h2><h3 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h3><ul>\n<li><p><strong>类型</strong>：<code>Vue instance</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 <code>this.$parent</code> 访问父实例，子实例被推入父实例的 <code>$children</code> 数组中。</p>\n<p class=\"tip\">节制地使用 <code>$parent</code> 和 <code>$children</code> - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信</p>\n\n</li>\n</ul>\n<h3 id=\"mixins\"><a href=\"#mixins\" class=\"headerlink\" title=\"mixins\"></a>mixins</h3><ul>\n<li><p><strong>类型</strong>：<code>Array&lt;Object&gt;</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p><code>mixins</code> 选项接收一个混入对象的数组。这些混入对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用的是和 <code>Vue.extend()</code> 一样的选项合并逻辑。也就是说，如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。</p>\n<p>Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> mixin = &#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>) &#125;\n&#125;\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>) &#125;,\n  <span class=\"hljs-attr\">mixins</span>: [mixin]\n&#125;)\n<span class=\"hljs-comment\">// =&gt; 1</span>\n<span class=\"hljs-comment\">// =&gt; 2</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/mixins.html\">混入</a></p>\n</li>\n</ul>\n<h3 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h3><ul>\n<li><p><strong>类型</strong>：<code>Object | Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 <code>Vue.extend</code>。这主要是为了便于扩展单文件组件。</p>\n<p>这和 <code>mixins</code> 类似。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> CompA = &#123; ... &#125;\n\n<span class=\"hljs-comment\">// 在没有调用 `Vue.extend` 时候继承 CompA</span>\n<span class=\"hljs-keyword\">var</span> CompB = &#123;\n  <span class=\"hljs-attr\">extends</span>: CompA,\n  ...\n&#125;</code></pre>\n</li>\n</ul>\n<h3 id=\"provide-inject\"><a href=\"#provide-inject\" class=\"headerlink\" title=\"provide / inject\"></a>provide / inject</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：</p>\n<ul>\n<li><strong>provide</strong>：<code>Object | () =&gt; Object</code></li>\n<li><strong>inject</strong>：<code>Array&lt;string&gt; | { [key: string]: string | Symbol | Object }</code></li>\n</ul>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p class=\"tip\"><code>provide</code> 和 <code>inject</code> 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。</p>\n\n<p>这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。</p>\n<p><code>provide</code> 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 <code>Symbol</code> 和 <code>Reflect.ownKeys</code> 的环境下可工作。</p>\n<p><code>inject</code> 选项应该是：</p>\n<ul>\n<li>一个字符串数组，或</li>\n<li>一个对象，对象的 key 是本地的绑定名，value 是：<ul>\n<li>在可用的注入内容中搜索用的 key (字符串或 Symbol)，或</li>\n<li>一个对象，该对象的：<ul>\n<li><code>from</code> property 是在可用的注入内容中搜索用的 key (字符串或 Symbol)</li>\n<li><code>default</code> property 是降级情况下使用的 value</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>提示：<code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</p>\n</blockquote>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 父级组件提供 'foo'</span>\n<span class=\"hljs-keyword\">var</span> Provider = &#123;\n  <span class=\"hljs-attr\">provide</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// 子组件注入 'foo'</span>\n<span class=\"hljs-keyword\">var</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  created () &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.foo) <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n  &#125;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<p>利用 ES2015 Symbols、函数 <code>provide</code> 和对象 <code>inject</code>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> s = <span class=\"hljs-built_in\">Symbol</span>()\n\n<span class=\"hljs-keyword\">const</span> Provider = &#123;\n  provide () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      [s]: <span class=\"hljs-string\">'foo'</span>\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123; s &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<blockquote>\n<p>接下来 2 个例子只工作在 Vue 2.2.1 或更高版本。低于这个版本时，注入的值会在 <code>props</code> 和 <code>data</code> 初始化之后得到。</p>\n</blockquote>\n<p>使用一个注入的值作为一个 property 的默认值：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">bar</span>: &#123;\n      <span class=\"hljs-keyword\">default</span> () &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.foo\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>使用一个注入的值作为数据入口：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-keyword\">this</span>.foo\n    &#125;\n  &#125;\n&#125;</code></pre>\n<blockquote>\n<p>在 2.5.0+ 的注入可以通过设置默认值使其变成可选项：</p>\n</blockquote>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123; <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'foo'</span> &#125;\n  &#125;\n&#125;</code></pre>\n<p>如果它需要从一个不同名字的 property 注入，则使用 <code>from</code> 来表示其源 property：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123;\n      <span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">'bar'</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'foo'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>与 prop 的默认值类似，你需要对非原始值使用一个工厂方法：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123;\n      <span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">'bar'</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n    &#125;\n  &#125;\n&#125;</code></pre>\n</li>\n</ul>\n<h2 id=\"选项-其它\"><a href=\"#选项-其它\" class=\"headerlink\" title=\"选项 / 其它\"></a>选项 / 其它</h2><h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><ul>\n<li><p><strong>类型</strong>：<code>string</code></p>\n</li>\n<li><p><strong>限制</strong>：只有作为组件选项时起作用。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>允许组件模板递归地调用自身。注意，组件在全局用 <code>Vue.component()</code> 注册时，全局 ID 自动作为组件的 name。</p>\n<p>指定 <code>name</code> 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a>，未命名组件将显示成 <code>&lt;AnonymousComponent&gt;</code>，这很没有语义。通过提供 <code>name</code> 选项，可以获得更有语义信息的组件树。</p>\n</li>\n</ul>\n<h3 id=\"delimiters\"><a href=\"#delimiters\" class=\"headerlink\" title=\"delimiters\"></a>delimiters</h3><ul>\n<li><p><strong>类型</strong>：<code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>[\"{{\", \"}}\"]</code></p>\n</li>\n<li><p><strong>限制</strong>：这个选项只在完整构建版本中的浏览器内编译时可用。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>改变纯文本插入分隔符。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">delimiters</span>: [<span class=\"hljs-string\">'$&#123;'</span>, <span class=\"hljs-string\">'&#125;'</span>]\n&#125;)\n\n<span class=\"hljs-comment\">// 分隔符变成了 ES6 模板字符串的风格</span></code></pre>\n</li>\n</ul>\n<h3 id=\"functional\"><a href=\"#functional\" class=\"headerlink\" title=\"functional\"></a>functional</h3><ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>使组件无状态 (没有 <code>data</code>) 和无实例 (没有 <code>this</code> 上下文)。他们用一个简单的 <code>render</code> 函数返回虚拟节点使它们渲染的代价更小。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/render-function.html#函数式组件\">函数式组件</a></p>\n</li>\n</ul>\n<h3 id=\"model\"><a href=\"#model\" class=\"headerlink\" title=\"model\"></a>model</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>{ prop?: string, event?: string }</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>允许一个自定义组件在使用 <code>v-model</code> 时定制 prop 和 event。默认情况下，一个组件上的 <code>v-model</code> 会把 <code>value</code> 用作 prop 且把 <code>input</code> 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 <code>value</code> prop 来达到不同的目的。使用 <code>model</code> 选项可以回避这些情况产生的冲突。</p>\n</li>\n<li><p><strong>Example</strong>：</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-checkbox'</span>, &#123;\n  <span class=\"hljs-attr\">model</span>: &#123;\n    <span class=\"hljs-attr\">prop</span>: <span class=\"hljs-string\">'checked'</span>,\n    <span class=\"hljs-attr\">event</span>: <span class=\"hljs-string\">'change'</span>\n  &#125;,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// this allows using the `value` prop for a different purpose</span>\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-comment\">// use `checked` as the prop which take the place of `value`</span>\n    <span class=\"hljs-attr\">checked</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">0</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-checkbox</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"foo\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"some value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-checkbox</span>&gt;</span></code></pre>\n<p>上述代码相当于：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-checkbox</span>\n  <span class=\"hljs-attr\">:checked</span>=<span class=\"hljs-string\">\"foo\"</span>\n  @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">\"val =&gt; &#123; foo = val &#125;\"</span>\n  <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"some value\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-checkbox</span>&gt;</span></code></pre>\n</li>\n</ul>\n<h3 id=\"inheritAttrs\"><a href=\"#inheritAttrs\" class=\"headerlink\" title=\"inheritAttrs\"></a>inheritAttrs</h3><blockquote>\n<p>2.4.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>true</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 <code>inheritAttrs</code> 到 <code>false</code>，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例 property <code>$attrs</code> 可以让这些 attribute 生效，且可以通过 <code>v-bind</code> 显性的绑定到非根元素上。</p>\n<p>注意：这个选项<strong>不影响</strong> <code>class</code> 和 <code>style</code> 绑定。</p>\n</li>\n</ul>\n<h3 id=\"comments\"><a href=\"#comments\" class=\"headerlink\" title=\"comments\"></a>comments</h3><blockquote>\n<p>2.4.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>默认值</strong>：<code>false</code></p>\n</li>\n<li><p><strong>限制</strong>：这个选项只在完整构建版本中的浏览器内编译时可用。</p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当设为 <code>true</code> 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。</p>\n</li>\n</ul>\n<h2 id=\"实例-property\"><a href=\"#实例-property\" class=\"headerlink\" title=\"实例 property\"></a>实例 property</h2><h3 id=\"vm-data\"><a href=\"#vm-data\" class=\"headerlink\" title=\"vm.$data\"></a>vm.$data</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象 property 的访问。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"#data\">选项 / 数据 - data</a></p>\n</li>\n</ul>\n<h3 id=\"vm-props\"><a href=\"#vm-props\" class=\"headerlink\" title=\"vm.$props\"></a>vm.$props</h3><blockquote>\n<p>2.2.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象 property 的访问。</p>\n</li>\n</ul>\n<h3 id=\"vm-el\"><a href=\"#vm-el\" class=\"headerlink\" title=\"vm.$el\"></a>vm.$el</h3><ul>\n<li><p><strong>类型</strong>：<code>Element</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>Vue 实例使用的根 DOM 元素。</p>\n</li>\n</ul>\n<h3 id=\"vm-options\"><a href=\"#vm-options\" class=\"headerlink\" title=\"vm.$options\"></a>vm.$options</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>用于当前 Vue 实例的初始化选项。需要在选项中包含自定义 property 时会有用处：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">customOption</span>: <span class=\"hljs-string\">'foo'</span>,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$options.customOption) <span class=\"hljs-comment\">// =&gt; 'foo'</span>\n  &#125;\n&#125;)</code></pre>\n</li>\n</ul>\n<h3 id=\"vm-parent\"><a href=\"#vm-parent\" class=\"headerlink\" title=\"vm.$parent\"></a>vm.$parent</h3><ul>\n<li><p><strong>类型</strong>：<code>Vue instance</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>父实例，如果当前实例有的话。</p>\n</li>\n</ul>\n<h3 id=\"vm-root\"><a href=\"#vm-root\" class=\"headerlink\" title=\"vm.$root\"></a>vm.$root</h3><ul>\n<li><p><strong>类型</strong>：<code>Vue instance</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。</p>\n</li>\n</ul>\n<h3 id=\"vm-children\"><a href=\"#vm-children\" class=\"headerlink\" title=\"vm.$children\"></a>vm.$children</h3><ul>\n<li><p><strong>类型</strong>：<code>Array&lt;Vue instance&gt;</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当前实例的直接子组件。<strong>需要注意 <code>$children</code> 并不保证顺序，也不是响应式的。</strong>如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 Array 作为真正的来源。</p>\n</li>\n</ul>\n<h3 id=\"vm-slots\"><a href=\"#vm-slots\" class=\"headerlink\" title=\"vm.$slots\"></a>vm.$slots</h3><ul>\n<li><p><strong>类型</strong>：<code>{ [name: string]: ?Array&lt;VNode&gt; }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>用来访问被<a href=\"../guide/components.html#通过插槽分发内容\">插槽分发</a>的内容。每个<a href=\"../guide/components-slots.html#具名插槽\">具名插槽</a>有其相应的 property (例如：<code>v-slot:foo</code> 中的内容将会在 <code>vm.$slots.foo</code> 中被找到)。<code>default</code> property 包括了所有没有被包含在具名插槽中的节点，或 <code>v-slot:default</code> 的内容。</p>\n<p><strong>注意：</strong><code>v-slot:foo</code> 在 2.6 以上的版本才支持。对于之前的版本，你可以使用<a href=\"../guide/components-slots.html#废弃了的语法\">废弃了的语法</a>。</p>\n<p>在使用<a href=\"../guide/render-function.html\">渲染函数</a>书写一个组件时，访问 <code>vm.$slots</code> 最有帮助。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>About Me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Copyright 2016 Evan You<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>.\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> header = <span class=\"hljs-keyword\">this</span>.$slots.header\n    <span class=\"hljs-keyword\">var</span> body   = <span class=\"hljs-keyword\">this</span>.$slots.default\n    <span class=\"hljs-keyword\">var</span> footer = <span class=\"hljs-keyword\">this</span>.$slots.footer\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, [\n      createElement(<span class=\"hljs-string\">'header'</span>, header),\n      createElement(<span class=\"hljs-string\">'main'</span>, body),\n      createElement(<span class=\"hljs-string\">'footer'</span>, footer)\n    ])\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"#slot\"><code>&lt;slot&gt;</code> 组件</a></li>\n<li><a href=\"../guide/components.html#通过插槽分发内容\">通过插槽分发内容</a></li>\n<li><a href=\"../guide/render-function.html#插槽\">渲染函数 - 插槽</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-scopedSlots\"><a href=\"#vm-scopedSlots\" class=\"headerlink\" title=\"vm.$scopedSlots\"></a>vm.$scopedSlots</h3><blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>{ [name: string]: props =&gt; Array&lt;VNode&gt; | undefined }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>用来访问<a href=\"../guide/components-slots.html#作用域插槽\">作用域插槽</a>。对于包括 <code>默认 slot</code> 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。</p>\n<p><code>vm.$scopedSlots</code> 在使用<a href=\"../guide/render-function.html\">渲染函数</a>开发一个组件时特别有用。</p>\n<p><strong>注意</strong>：从 2.6.0 开始，这个 property 有两个变化：</p>\n<ol>\n<li><p>作用域插槽函数现在保证返回一个 VNode 数组，除非在返回值无效的情况下返回 <code>undefined</code>。</p>\n</li>\n<li><p>所有的 <code>$slots</code> 现在都会作为函数暴露在 <code>$scopedSlots</code> 中。如果你在使用渲染函数，不论当前插槽是否带有作用域，我们都推荐始终通过 <code>$scopedSlots</code> 访问它们。这不仅仅使得在未来添加作用域变得简单，也可以让你最终轻松迁移到所有插槽都是函数的 Vue 3。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"#slot\"><code>&lt;slot&gt;</code> 组件</a></li>\n<li><a href=\"../guide/components-slots.html#作用域插槽\">作用域插槽</a></li>\n<li><a href=\"../guide/render-function.html#插槽\">渲染函数 - 插槽</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-refs\"><a href=\"#vm-refs\" class=\"headerlink\" title=\"vm.$refs\"></a>vm.$refs</h3><ul>\n<li><p><strong>类型</strong>：<code>Object</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>一个对象，持有注册过 <a href=\"#ref\"><code>ref</code> attribute</a> 的所有 DOM 元素和组件实例。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/components-edge-cases.html#访问子组件实例或子元素\">子组件 ref</a></li>\n<li><a href=\"#ref\">特殊 attribute - ref</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-isServer\"><a href=\"#vm-isServer\" class=\"headerlink\" title=\"vm.$isServer\"></a>vm.$isServer</h3><ul>\n<li><p><strong>类型</strong>：<code>boolean</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>当前 Vue 实例是否运行于服务器。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/ssr.html\">服务端渲染</a></p>\n</li>\n</ul>\n<h3 id=\"vm-attrs\"><a href=\"#vm-attrs\" class=\"headerlink\" title=\"vm.$attrs\"></a>vm.$attrs</h3><blockquote>\n<p>2.4.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: string }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (<code>class</code> 和 <code>style</code> 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (<code>class</code> 和 <code>style</code> 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</p>\n</li>\n</ul>\n<h3 id=\"vm-listeners\"><a href=\"#vm-listeners\" class=\"headerlink\" title=\"vm.$listeners\"></a>vm.$listeners</h3><blockquote>\n<p>2.4.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>{ [key: string]: Function | Array&lt;Function&gt; }</code></p>\n</li>\n<li><p><strong>只读</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</p>\n</li>\n</ul>\n<h2 id=\"实例方法-数据\"><a href=\"#实例方法-数据\" class=\"headerlink\" title=\"实例方法 / 数据\"></a>实例方法 / 数据</h2><h3 id=\"vm-watch-expOrFn-callback-options\"><a href=\"#vm-watch-expOrFn-callback-options\" class=\"headerlink\" title=\"vm.$watch( expOrFn, callback, [options] )\"></a>vm.$watch( expOrFn, callback, [options] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string | Function} expOrFn</code></li>\n<li><code>{Function | Object} callback</code></li>\n<li><code>{Object} [options]</code><ul>\n<li><code>{boolean} deep</code></li>\n<li><code>{boolean} immediate</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>返回值</strong>：<code>{Function} unwatch</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代。</p>\n<p class=\"tip\">注意：在变更 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变更之前值的副本。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 键路径</span>\nvm.$watch(<span class=\"hljs-string\">'a.b.c'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newVal, oldVal</span>) </span>&#123;\n  <span class=\"hljs-comment\">// 做点什么</span>\n&#125;)\n\n<span class=\"hljs-comment\">// 函数</span>\nvm.$watch(\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// 表达式 `this.a + this.b` 每次得出一个不同的结果时</span>\n    <span class=\"hljs-comment\">// 处理函数都会被调用。</span>\n    <span class=\"hljs-comment\">// 这就像监听一个未被定义的计算属性</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a + <span class=\"hljs-keyword\">this</span>.b\n  &#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newVal, oldVal</span>) </span>&#123;\n    <span class=\"hljs-comment\">// 做点什么</span>\n  &#125;\n)</code></pre>\n<p><code>vm.$watch</code> 返回一个取消观察函数，用来停止触发回调：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(<span class=\"hljs-string\">'a'</span>, cb)\n<span class=\"hljs-comment\">// 之后取消观察</span>\nunwatch()</code></pre>\n</li>\n<li><p><strong>选项：deep</strong></p>\n<p>为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code>。注意监听数组的变更不需要这么做。</p>\n<pre><code class=\"hljs js\">vm.$watch(<span class=\"hljs-string\">'someObject'</span>, callback, &#123;\n  <span class=\"hljs-attr\">deep</span>: <span class=\"hljs-literal\">true</span>\n&#125;)\nvm.someObject.nestedValue = <span class=\"hljs-number\">123</span>\n<span class=\"hljs-comment\">// callback is fired</span></code></pre>\n</li>\n<li><p><strong>选项：immediate</strong></p>\n<p>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调：</p>\n<pre><code class=\"hljs js\">vm.$watch(<span class=\"hljs-string\">'a'</span>, callback, &#123;\n  <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span>\n&#125;)\n<span class=\"hljs-comment\">// 立即以 `a` 的当前值触发回调</span></code></pre>\n<p>注意在带有 <code>immediate</code> 选项时，你不能在第一次回调时取消侦听给定的 property。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 这会导致报错</span>\n<span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(\n  <span class=\"hljs-string\">'value'</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    doSomething()\n    unwatch()\n  &#125;,\n  &#123; <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span> &#125;\n)</code></pre>\n<p>如果你仍然希望在回调内部调用一个取消侦听的函数，你应该先检查其函数的可用性：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(\n  <span class=\"hljs-string\">'value'</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    doSomething()\n    <span class=\"hljs-keyword\">if</span> (unwatch) &#123;\n      unwatch()\n    &#125;\n  &#125;,\n  &#123; <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span> &#125;\n)</code></pre>\n</li>\n</ul>\n<h3 id=\"vm-set-target-propertyName-index-value\"><a href=\"#vm-set-target-propertyName-index-value\" class=\"headerlink\" title=\"vm.$set( target, propertyName/index, value )\"></a>vm.$set( target, propertyName/index, value )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>返回值</strong>：设置的值。</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>这是全局 <code>Vue.set</code> 的<strong>别名</strong>。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"#Vue-set\">Vue.set</a></p>\n</li>\n</ul>\n<h3 id=\"vm-delete-target-propertyName-index\"><a href=\"#vm-delete-target-propertyName-index\" class=\"headerlink\" title=\"vm.$delete( target, propertyName/index )\"></a>vm.$delete( target, propertyName/index )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>这是全局 <code>Vue.delete</code> 的<strong>别名</strong>。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"#Vue-delete\">Vue.delete</a></p>\n</li>\n</ul>\n<h2 id=\"实例方法-事件\"><a href=\"#实例方法-事件\" class=\"headerlink\" title=\"实例方法 / 事件\"></a>实例方法 / 事件</h2><h3 id=\"vm-on-event-callback\"><a href=\"#vm-on-event-callback\" class=\"headerlink\" title=\"vm.$on( event, callback )\"></a>vm.$on( event, callback )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string | Array&lt;string&gt;} event</code> (数组只在 2.2.0+ 中支持)</li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>监听当前实例上的自定义事件。事件可以由 <code>vm.$emit</code> 触发。回调函数会接收所有传入事件触发函数的额外参数。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\">vm.$on(<span class=\"hljs-string\">'test'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">msg</span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(msg)\n&#125;)\nvm.$emit(<span class=\"hljs-string\">'test'</span>, <span class=\"hljs-string\">'hi'</span>)\n<span class=\"hljs-comment\">// =&gt; \"hi\"</span></code></pre>\n</li>\n</ul>\n<h3 id=\"vm-once-event-callback\"><a href=\"#vm-once-event-callback\" class=\"headerlink\" title=\"vm.$once( event, callback )\"></a>vm.$once( event, callback )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。</p>\n</li>\n</ul>\n<h3 id=\"vm-off-event-callback\"><a href=\"#vm-off-event-callback\" class=\"headerlink\" title=\"vm.$off( [event, callback] )\"></a>vm.$off( [event, callback] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string | Array&lt;string&gt;} event</code> (只在 2.2.2+ 支持数组)</li>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>移除自定义事件监听器。</p>\n<ul>\n<li><p>如果没有提供参数，则移除所有的事件监听器；</p>\n</li>\n<li><p>如果只提供了事件，则移除该事件所有的监听器；</p>\n</li>\n<li><p>如果同时提供了事件与回调，则只移除这个回调的监听器。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-emit-eventName-…args\"><a href=\"#vm-emit-eventName-…args\" class=\"headerlink\" title=\"vm.$emit( eventName, […args] )\"></a>vm.$emit( eventName, […args] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{string} eventName</code></li>\n<li><code>[...args]</code></li>\n</ul>\n<p>触发当前实例上的事件。附加参数都会传给监听器回调。</p>\n</li>\n<li><p><strong>示例：</strong></p>\n<p>只配合一个事件名使用 <code>$emit</code>：</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'welcome-button'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;button v-on:click=\"$emit('welcome')\"&gt;\n      Click me to be welcomed\n    &lt;/button&gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"emit-example-simple\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">welcome-button</span> <span class=\"hljs-attr\">v-on:welcome</span>=<span class=\"hljs-string\">\"sayHi\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">welcome-button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#emit-example-simple'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">sayHi</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      alert(<span class=\"hljs-string\">'Hi!'</span>)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n  <div id=\"emit-example-simple\" class=\"demo\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  <script>\n    Vue.component('welcome-button', {\n      template: `\n        <button v-on:click=\"$emit('welcome')\">\n          Click me to be welcomed\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-simple',\n      methods: {\n        sayHi: function () {\n          alert('Hi!')\n        }\n      }\n    })\n  </script>\n  \n<p>配合额外的参数使用 <code>$emit</code>：</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'magic-eight-ball'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">possibleAdvice</span>: [<span class=\"hljs-string\">'Yes'</span>, <span class=\"hljs-string\">'No'</span>, <span class=\"hljs-string\">'Maybe'</span>]\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">giveAdvice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> randomAdviceIndex = <span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-keyword\">this</span>.possibleAdvice.length)\n      <span class=\"hljs-keyword\">this</span>.$emit(<span class=\"hljs-string\">'give-advice'</span>, <span class=\"hljs-keyword\">this</span>.possibleAdvice[randomAdviceIndex])\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;button v-on:click=\"giveAdvice\"&gt;\n      Click me for advice\n    &lt;/button&gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"emit-example-argument\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">magic-eight-ball</span> <span class=\"hljs-attr\">v-on:give-advice</span>=<span class=\"hljs-string\">\"showAdvice\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">magic-eight-ball</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#emit-example-argument'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">showAdvice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">advice</span>) </span>&#123;\n      alert(advice)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n  <div id=\"emit-example-argument\" class=\"demo\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  <script>\n    Vue.component('magic-eight-ball', {\n      data: function () {\n        return {\n          possibleAdvice: ['Yes', 'No', 'Maybe']\n        }\n      },\n      methods: {\n        giveAdvice: function () {\n          var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n          this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n        }\n      },\n      template: `\n        <button v-on:click=\"giveAdvice\">\n          Click me for advice\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-argument',\n      methods: {\n        showAdvice: function (advice) {\n          alert(advice)\n        }\n      }\n    })\n  </script>\n  \n</li>\n</ul>\n<h2 id=\"实例方法-生命周期\"><a href=\"#实例方法-生命周期\" class=\"headerlink\" title=\"实例方法 / 生命周期\"></a>实例方法 / 生命周期</h2><h3 id=\"vm-mount-elementOrSelector\"><a href=\"#vm-mount-elementOrSelector\" class=\"headerlink\" title=\"vm.$mount( [elementOrSelector] )\"></a>vm.$mount( [elementOrSelector] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Element | string} [elementOrSelector]</code></li>\n<li><code>{boolean} [hydrating]</code></li>\n</ul>\n</li>\n<li><p><strong>返回值</strong>：<code>vm</code> - 实例自身</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 <code>vm.$mount()</code> 手动地挂载一个未挂载的实例。</p>\n<p>如果没有提供 <code>elementOrSelector</code> 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。</p>\n<p>这个方法返回实例自身，因而可以链式调用其它实例方法。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> MyComponent = Vue.extend(&#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;Hello!&lt;/div&gt;'</span>\n&#125;)\n\n<span class=\"hljs-comment\">// 创建并挂载到 #app (会替换 #app)</span>\n<span class=\"hljs-keyword\">new</span> MyComponent().$mount(<span class=\"hljs-string\">'#app'</span>)\n\n<span class=\"hljs-comment\">// 同上</span>\n<span class=\"hljs-keyword\">new</span> MyComponent(&#123; <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span> &#125;)\n\n<span class=\"hljs-comment\">// 或者，在文档之外渲染并且随后挂载</span>\n<span class=\"hljs-keyword\">var</span> component = <span class=\"hljs-keyword\">new</span> MyComponent().$mount()\n<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'app'</span>).appendChild(component.$el)</code></pre>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></li>\n<li><a href=\"../guide/ssr.html\">服务端渲染</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-forceUpdate\"><a href=\"#vm-forceUpdate\" class=\"headerlink\" title=\"vm.$forceUpdate()\"></a>vm.$forceUpdate()</h3><ul>\n<li><p><strong>示例</strong>：</p>\n<p>迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>\n</li>\n</ul>\n<h3 id=\"vm-nextTick-callback\"><a href=\"#vm-nextTick-callback\" class=\"headerlink\" title=\"vm.$nextTick( [callback] )\"></a>vm.$nextTick( [callback] )</h3><ul>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 <code>Vue.nextTick</code> 一样，不同的是回调的 <code>this</code> 自动绑定到调用它的实例上。</p>\n<blockquote>\n<p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise (IE：你们都看我干嘛)，你得自行 polyfill。</p>\n</blockquote>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-attr\">example</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// 修改数据</span>\n      <span class=\"hljs-keyword\">this</span>.message = <span class=\"hljs-string\">'changed'</span>\n      <span class=\"hljs-comment\">// DOM 还没有更新</span>\n      <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-comment\">// DOM 现在更新了</span>\n        <span class=\"hljs-comment\">// `this` 绑定到当前实例</span>\n        <span class=\"hljs-keyword\">this</span>.doSomethingElse()\n      &#125;)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>参考</strong></p>\n<ul>\n<li><a href=\"#Vue-nextTick\">Vue.nextTick</a></li>\n<li><a href=\"../guide/reactivity.html#异步更新队列\">异步更新队列</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-destroy\"><a href=\"#vm-destroy\" class=\"headerlink\" title=\"vm.$destroy()\"></a>vm.$destroy()</h3><ul>\n<li><p><strong>用法</strong>：</p>\n<p>完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。</p>\n<p>触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 的钩子。</p>\n<p class=\"tip\">在大多数场景中你不应该调用这个方法。最好使用 <code>v-if</code> 和 <code>v-for</code> 指令以数据驱动的方式控制子组件的生命周期。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/instance.html#生命周期图示\">生命周期图示</a></p>\n</li>\n</ul>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><h3 id=\"v-text\"><a href=\"#v-text\" class=\"headerlink\" title=\"v-text\"></a>v-text</h3><ul>\n<li><p><strong>预期</strong>：<code>string</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>更新元素的 <code>textContent</code>。如果要更新部分的 <code>textContent</code>，需要使用 <code>{{ Mustache }}</code> 插值。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-text</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 和下面的一样 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/syntax.html#插值\">数据绑定语法 - 插值</a></p>\n</li>\n</ul>\n<h3 id=\"v-html\"><a href=\"#v-html\" class=\"headerlink\" title=\"v-html\"></a>v-html</h3><ul>\n<li><p><strong>预期</strong>：<code>string</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>更新元素的 <code>innerHTML</code>。<strong>注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong>。如果试图使用 <code>v-html</code> 组合模板，可以重新考虑是否通过使用组件来替代。</p>\n<p class=\"tip\">在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\" target=\"_blank\" rel=\"noopener\">XSS 攻击</a>。只在可信内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上。</p>\n\n<p class=\"tip\">在<a href=\"../guide/single-file-components.html\">单文件组件</a>里，<code>scoped</code> 的样式不会应用在 <code>v-html</code> 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 <code>v-html</code> 的内容设置带作用域的 CSS，你可以替换为 <a href=\"https://vue-loader.vuejs.org/en/features/css-modules.html\" target=\"_blank\" rel=\"noopener\">CSS Modules</a> 或用一个额外的全局 <code>&lt;style&gt;</code> 元素手动设置类似 BEM 的作用域策略。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"html\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/syntax.html#纯-HTML\">数据绑定语法 - 插值</a></p>\n</li>\n</ul>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><ul>\n<li><p><strong>预期</strong>：<code>any</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>根据表达式之真假值，切换元素的 <code>display</code> CSS property。</p>\n<p>当条件变化时该指令触发过渡效果。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/conditional.html#v-show\">条件渲染 - v-show</a></p>\n</li>\n</ul>\n<h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><ul>\n<li><p><strong>预期</strong>：<code>any</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>根据表达式的值的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy\" target=\"_blank\" rel=\"noopener\">truthiness</a> 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <code>&lt;template&gt;</code>，将提出它的内容作为条件块。</p>\n<p>当条件变化时该指令触发过渡效果。</p>\n<p class=\"tip\">当和 <code>v-if</code> 一起使用时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高。详见<a href=\"../guide/list.html#v-for-with-v-if\">列表渲染教程</a></p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/conditional.html\">条件渲染 - v-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a>v-else</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>限制</strong>：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>为 <code>v-if</code> 或者 <code>v-else-if</code> 添加“else 块”。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"Math.random() &gt; 0.5\"</span>&gt;</span>\n  Now you see me\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Now you don't\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/conditional.html#v-else\">条件渲染 - v-else</a></p>\n</li>\n</ul>\n<h3 id=\"v-else-if\"><a href=\"#v-else-if\" class=\"headerlink\" title=\"v-else-if\"></a>v-else-if</h3><blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<ul>\n<li><p><strong>类型</strong>：<code>any</code></p>\n</li>\n<li><p><strong>限制</strong>：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>表示 <code>v-if</code> 的“else if 块”。可以链式调用。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"type === 'A'\"</span>&gt;</span>\n  A\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'B'\"</span>&gt;</span>\n  B\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'C'\"</span>&gt;</span>\n  C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Not A/B/C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/conditional.html#v-else-if\">条件渲染 - v-else-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h3><ul>\n<li><p><strong>预期</strong>：<code>Array | Object | number | string | Iterable (2.6 新增)</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 <code>alias in expression</code>，为当前遍历的元素提供别名：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span>&gt;</span>\n  &#123;&#123; item.text &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>另外也可以为数组索引指定别名 (或者用于对象的键)：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(item, index) in items\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(val, key) in object\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(val, name, index) in object\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p><code>v-for</code> 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute <code>key</code> 来提供一个排序提示：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>\n  &#123;&#123; item.text &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>从 2.6 起，<code>v-for</code> 也可以在实现了<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#可迭代协议\" target=\"_blank\" rel=\"noopener\">可迭代协议</a>的值上使用，包括原生的 <code>Map</code> 和 <code>Set</code>。不过应该注意的是 Vue 2.x 目前并不支持可响应的 <code>Map</code> 和 <code>Set</code> 值，所以无法自动探测变更。</p>\n<p class=\"tip\">当和 <code>v-if</code> 一起使用时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高。详见<a href=\"../guide/list.html#v-for-with-v-if\">列表渲染教程</a></p>\n\n<p><code>v-for</code> 的详细用法可以通过以下链接查看教程详细说明。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/list.html\">列表渲染</a></li>\n<li><a href=\"../guide/list.html#key\">key</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h3><ul>\n<li><p><strong>缩写</strong>：<code>@</code></p>\n</li>\n<li><p><strong>预期</strong>：<code>Function | Inline Statement | Object</code></p>\n</li>\n<li><p><strong>参数</strong>：<code>event</code></p>\n</li>\n<li><p><strong>修饰符</strong>：</p>\n<ul>\n<li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</li>\n<li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</li>\n<li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</li>\n<li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>\n<li><code>.{keyCode | keyAlias}</code> - 只当事件是从特定键触发时才触发回调。</li>\n<li><code>.native</code> - 监听组件根元素的原生事件。</li>\n<li><code>.once</code> - 只触发一次回调。</li>\n<li><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</li>\n<li><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</li>\n<li><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</li>\n<li><code>.passive</code> - (2.3.0) 以 <code>{ passive: true }</code> 模式添加侦听器</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p>\n<p>用在普通元素上时，只能监听<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Events\" target=\"_blank\" rel=\"noopener\"><strong>原生 DOM 事件</strong></a>。用在自定义元素组件上时，也可以监听子组件触发的<strong>自定义事件</strong>。</p>\n<p>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 <code>$event</code> property：<code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>。</p>\n<p>从 <code>2.4.0</code> 开始，<code>v-on</code> 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 方法处理器 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态事件 (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:</span>[<span class=\"hljs-attr\">event</span>]=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 内联语句 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doThat('hello', $event)\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 缩写 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态事件缩写 (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @[<span class=\"hljs-attr\">event</span>]=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 停止冒泡 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.stop</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 阻止默认行为 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.prevent</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 阻止默认行为，没有表达式 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> @<span class=\"hljs-attr\">submit.prevent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!--  串联修饰符 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.stop.prevent</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 键修饰符，键别名 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> @<span class=\"hljs-attr\">keyup.enter</span>=<span class=\"hljs-string\">\"onEnter\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 键修饰符，键代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> @<span class=\"hljs-attr\">keyup.13</span>=<span class=\"hljs-string\">\"onEnter\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 点击回调只会触发一次 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click.once</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 对象语法 (2.4.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"&#123; mousedown: doThis, mouseup: doThat &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">my-event</span>=<span class=\"hljs-string\">\"handleThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 内联语句 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">my-event</span>=<span class=\"hljs-string\">\"handleThis(123, $event)\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 组件中的原生事件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">click.native</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/events.html\">事件处理器</a></li>\n<li><a href=\"../guide/components.html#监听子组件事件\">组件 - 自定义事件</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h3><ul>\n<li><p><strong>缩写</strong>：<code>:</code></p>\n</li>\n<li><p><strong>预期</strong>：<code>any (with argument) | Object (without argument)</code></p>\n</li>\n<li><p><strong>参数</strong>：<code>attrOrProp (optional)</code></p>\n</li>\n<li><p><strong>修饰符</strong>：</p>\n<ul>\n<li><code>.prop</code> - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(<a href=\"https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028\" target=\"_blank\" rel=\"noopener\">差别在哪里？</a>)</li>\n<li><code>.camel</code> - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)</li>\n<li><code>.sync</code> (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 <code>v-on</code> 侦听器。</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</p>\n<p>在绑定 <code>class</code> 或 <code>style</code> attribute 时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</p>\n<p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p>\n<p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 <code>class</code> 和 <code>style</code> 绑定不支持数组和对象。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 绑定一个 attribute --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">v-bind:src</span>=<span class=\"hljs-string\">\"imageSrc\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-bind:</span>[<span class=\"hljs-attr\">key</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 缩写 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">\"imageSrc\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">:</span>[<span class=\"hljs-attr\">key</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 内联字符串拼接 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">\"'/path/to/images/' + fileName\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- class 绑定 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"&#123; red: isRed &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[classA, classB]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[classA, &#123; classB: isB, classC: isC &#125;]\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- style 绑定 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"&#123; fontSize: size + 'px' &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"[styleObjectA, styleObjectB]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 绑定一个全是 attribute 的对象 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"&#123; id: someProp, 'other-attr': otherProp &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:text-content.prop</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">:prop</span>=<span class=\"hljs-string\">\"someThing\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child-component</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"$props\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">child-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- XLink --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:xlink:special</span>=<span class=\"hljs-string\">\"foo\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span></code></pre>\n<p><code>.camel</code> 修饰符允许在使用 DOM 模板时将 <code>v-bind</code> property 名称驼峰化，例如 SVG 的 <code>viewBox</code> property：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">:view-box.camel</span>=<span class=\"hljs-string\">\"viewBox\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span></code></pre>\n<p>在使用字符串模板或通过 <code>vue-loader</code>/<code>vueify</code> 编译时，无需使用 <code>.camel</code>。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/class-and-style.html\">Class 与 Style 绑定</a></li>\n<li><a href=\"../guide/components.html#通过-Prop-向子组件传递数据\">组件 - Props</a></li>\n<li><a href=\"../guide/components-custom-events.html#sync-修饰符\">组件 - <code>.sync</code> 修饰符</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h3><ul>\n<li><p><strong>预期</strong>：随表单控件类型不同而不同。</p>\n</li>\n<li><p><strong>限制</strong>：</p>\n<ul>\n<li><code>&lt;input&gt;</code></li>\n<li><code>&lt;select&gt;</code></li>\n<li><code>&lt;textarea&gt;</code></li>\n<li>components</li>\n</ul>\n</li>\n<li><p><strong>修饰符</strong>：</p>\n<ul>\n<li><a href=\"../guide/forms.html#lazy\"><code>.lazy</code></a> - 取代 <code>input</code> 监听 <code>change</code> 事件</li>\n<li><a href=\"../guide/forms.html#number\"><code>.number</code></a> - 输入字符串转为有效的数字</li>\n<li><a href=\"../guide/forms.html#trim\"><code>.trim</code></a> - 输入首尾空格过滤</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>在表单控件或者组件上创建双向绑定。细节请看下面的教程链接。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/forms.html\">表单控件绑定</a></li>\n<li><a href=\"../guide/components-custom-events.html#将原生事件绑定到组件\">组件 - 在输入组件上使用自定义事件</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-slot\"><a href=\"#v-slot\" class=\"headerlink\" title=\"v-slot\"></a>v-slot</h3><ul>\n<li><p><strong>缩写</strong>：<code>#</code></p>\n</li>\n<li><p><strong>预期</strong>：可放置在函数参数位置的 JavaScript 表达式 (在<a href=\"../guide/components-slots.html#解构插槽-Props\">支持的环境下</a>可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。</p>\n</li>\n<li><p><strong>参数</strong>：插槽名 (可选，默认值是 <code>default</code>)</p>\n</li>\n<li><p><strong>限用于</strong></p>\n<ul>\n<li><code>&lt;template&gt;</code></li>\n<li><a href=\"../guide/components-slots.html#独占默认插槽的缩写语法\">组件</a> (对于一个单独的带 prop 的默认插槽)</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>提供具名插槽或需要接收 prop 的插槽。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 具名插槽 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    Header content\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  Default slot content\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    Footer content\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 接收 prop 的具名插槽 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">infinite-scroll</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:item</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"item\"</span>&gt;</span>\n      &#123;&#123; slotProps.item.text &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">infinite-scroll</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 接收 prop 的默认插槽，使用了解构 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mouse-position</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; x, y &#125;\"</span>&gt;</span>\n  Mouse position: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mouse-position</span>&gt;</span></code></pre>\n<p>更多细节请查阅以下链接。</p>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/components-slots.html\">组件 - 插槽</a></li>\n<li><a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md\" target=\"_blank\" rel=\"noopener\">RFC-0001</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-pre\"><a href=\"#v-pre\" class=\"headerlink\" title=\"v-pre\"></a>v-pre</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n</li>\n</ul>\n<h3 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p>\n</li>\n<li><p><strong>示例</strong>：</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-attr\">[v-cloak]</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: none;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-cloak</span>&gt;</span>\n  &#123;&#123; message &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p><div> 不会显示，直到编译结束。</div></p>\n</li>\n</ul>\n<h3 id=\"v-once\"><a href=\"#v-once\" class=\"headerlink\" title=\"v-once\"></a>v-once</h3><ul>\n<li><p><strong>不需要表达式</strong></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>只渲染元素和组件<strong>一次</strong>。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 单个元素 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 有子元素 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>comment<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 组件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-once</span> <span class=\"hljs-attr\">:comment</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- `v-for` 指令--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"i in list\"</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：</p>\n<ul>\n<li><a href=\"../guide/syntax.html#插值\">数据绑定语法- 插值</a></li>\n<li><a href=\"../guide/components-edge-cases.html#通过-v-once-创建低开销的静态组件\">组件 - 对低开销的静态组件使用 <code>v-once</code></a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"特殊-attribute\"><a href=\"#特殊-attribute\" class=\"headerlink\" title=\"特殊 attribute\"></a>特殊 attribute</h2><h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><ul>\n<li><p><strong>预期</strong>：<code>number | string</code></p>\n<p><code>key</code> 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p>\n<p>有相同父元素的子元素必须有<strong>独特的 key</strong>。重复的 key 会造成渲染错误。</p>\n<p>最常见的用例是结合 <code>v-for</code>：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p>\n<ul>\n<li>完整地触发组件的生命周期钩子</li>\n<li>触发过渡</li>\n</ul>\n<p>例如：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span></code></pre>\n<p>当 <code>text</code> 发生改变时，<code>&lt;span&gt;</code> 总是会被替换而不是被修改，因此会触发过渡。</p>\n</li>\n</ul>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><p><strong>预期</strong>：<code>string</code></p>\n<p><code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"p\"</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- `vm.$refs.child` will be the child component instance --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child-component</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"child\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">child-component</span>&gt;</span></code></pre>\n<p>当 <code>v-for</code> 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。</p>\n<p>关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components-edge-cases.html#访问子组件实例或子元素\">子组件 ref</a></p>\n</li>\n</ul>\n<h3 id=\"is\"><a href=\"#is\" class=\"headerlink\" title=\"is\"></a>is</h3><ul>\n<li><p><strong>预期</strong>：<code>string | Object (组件的选项对象)</code></p>\n<p>用于<a href=\"../guide/components.html#动态组件\">动态组件</a>且基于 <a href=\"../guide/components.html#解析-DOM-模板时的注意事项\">DOM 内模板的限制</a>来工作。</p>\n<p>示例：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">v-bind:is</span>=<span class=\"hljs-string\">\"currentView\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">is</span>=<span class=\"hljs-string\">\"my-row\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></code></pre>\n<p>更多的使用细节，请移步至下面的链接。</p>\n</li>\n<li><p><strong>See also</strong>：</p>\n<ul>\n<li><a href=\"../guide/components.html#动态组件\">动态组件</a></li>\n<li><a href=\"../guide/components.html#解析-DOM-模板时的注意事项\">DOM 模板解析说明</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"slot-废弃\"><a href=\"#slot-废弃\" class=\"headerlink\" title=\"slot 废弃\"></a>slot <sup style=\"color:#c92222\">废弃</sup></h3><p><strong>推荐 2.6.0 新增的 <a href=\"#v-slot\">v-slot</a>。</strong></p>\n<ul>\n<li><p><strong>预期</strong>：<code>string</code></p>\n<p>用于标记往哪个具名插槽中插入子组件内容。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components-slots.html#具名插槽\">具名插槽</a></p>\n</li>\n</ul>\n<h3 id=\"slot-scope-废弃\"><a href=\"#slot-scope-废弃\" class=\"headerlink\" title=\"slot-scope 废弃\"></a>slot-scope <sup style=\"color:#c92222\">废弃</sup></h3><p><strong>推荐 2.6.0 新增的 <a href=\"#v-slot\">v-slot</a>。</strong></p>\n<ul>\n<li><p><strong>预期</strong>：<code>function argument expression</code></p>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>用于将元素或组件表示为作用域插槽。attribute 的值应该是可以出现在函数签名的参数位置的合法的 JavaScript 表达式。这意味着在支持的环境中，你还可以在表达式中使用 ES2015 解构。它在 2.5.0+ 中替代了 <a href=\"#scope-replaced\"><code>scope</code></a>。</p>\n<p>此 attribute 不支持动态绑定。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components-slots.html#作用域插槽\">作用域插槽</a></p>\n</li>\n</ul>\n<h3 id=\"scope-移除\"><a href=\"#scope-移除\" class=\"headerlink\" title=\"scope 移除\"></a>scope <sup style=\"color:#c92222\">移除</sup></h3><p><strong>被 2.5.0 新增的 <a href=\"#slot-scope\">slot-scope</a> 取代。推荐 2.6.0 新增的 <a href=\"#v-slot\">v-slot</a>。</strong></p>\n<p>用于表示一个作为带作用域的插槽的 <code>&lt;template&gt;</code> 元素，它在 2.5.0+ 中被 <a href=\"#slot-scope\"><code>slot-scope</code></a> 替代。</p>\n<ul>\n<li><p><strong>用法：</strong></p>\n<p>除了 <code>scope</code> 只可以用于 <code>&lt;template&gt;</code> 元素，其它和 <a href=\"#slot-scope\"><code>slot-scope</code></a> 都相同。</p>\n</li>\n</ul>\n<h2 id=\"内置的组件\"><a href=\"#内置的组件\" class=\"headerlink\" title=\"内置的组件\"></a>内置的组件</h2><h3 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h3><ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>\n<li><code>inline-template</code> - boolean</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p>渲染一个“元组件”为动态组件。依 <code>is</code> 的值，来决定哪个组件被渲染。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 动态组件由 vm 实例的 `componentId` property 控制 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"componentId\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"$options.components.child\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components.html#动态组件\">动态组件</a></p>\n</li>\n</ul>\n<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>name</code> - string，用于自动生成 CSS 过渡类名。例如：<code>name: &#39;fade&#39;</code> 将自动拓展为 <code>.fade-enter</code>，<code>.fade-enter-active</code> 等。默认类名为 <code>&quot;v&quot;</code></li>\n<li><code>appear</code> - boolean，是否在初始渲染时使用过渡。默认为 <code>false</code>。</li>\n<li><code>css</code> - boolean，是否使用 CSS 过渡类。默认为 <code>true</code>。如果设置为 <code>false</code>，将只通过组件事件触发注册的 JavaScript 钩子。</li>\n<li><code>type</code> - string，指定过渡事件类型，侦听过渡何时结束。有效值为 <code>&quot;transition&quot;</code> 和 <code>&quot;animation&quot;</code>。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li>\n<li><code>mode</code> - string，控制离开/进入过渡的时间序列。有效的模式有 <code>&quot;out-in&quot;</code> 和 <code>&quot;in-out&quot;</code>；默认同时进行。</li>\n<li><code>duration</code> - number | { <code>enter</code>: number, <code>leave</code>: number } 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件。</li>\n<li><code>enter-class</code> - string</li>\n<li><code>leave-class</code> - string</li>\n<li><code>appear-class</code> - string</li>\n<li><code>enter-to-class</code> - string</li>\n<li><code>leave-to-class</code> - string</li>\n<li><code>appear-to-class</code> - string</li>\n<li><code>enter-active-class</code> - string</li>\n<li><code>leave-active-class</code> - string</li>\n<li><code>appear-active-class</code> - string</li>\n</ul>\n</li>\n<li><p><strong>事件</strong>：</p>\n<ul>\n<li><code>before-enter</code></li>\n<li><code>before-leave</code></li>\n<li><code>before-appear</code></li>\n<li><code>enter</code></li>\n<li><code>leave</code></li>\n<li><code>appear</code></li>\n<li><code>after-enter</code></li>\n<li><code>after-leave</code></li>\n<li><code>after-appear</code></li>\n<li><code>enter-cancelled</code></li>\n<li><code>leave-cancelled</code> (<code>v-show</code> only)</li>\n<li><code>appear-cancelled</code></li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p><code>&lt;transition&gt;</code> 元素作为<strong>单个</strong>元素/组件的过渡效果。<code>&lt;transition&gt;</code> 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 简单元素 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>toggled content<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态组件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"fade\"</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">\"out-in\"</span> <span class=\"hljs-attr\">appear</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 事件钩子 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"transition-demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span> @<span class=\"hljs-attr\">after-enter</span>=<span class=\"hljs-string\">\"transitionComplete\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-show</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>toggled content<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  ...\n  methods: &#123;\n    <span class=\"hljs-attr\">transitionComplete</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el</span>) </span>&#123;\n      <span class=\"hljs-comment\">// 传入 'el' 这个 DOM 元素作为参数。</span>\n    &#125;\n  &#125;\n  ...\n&#125;).$mount(<span class=\"hljs-string\">'#transition-demo'</span>)</code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/transitions.html\">过渡：进入，离开和列表</a></p>\n</li>\n</ul>\n<h3 id=\"transition-group\"><a href=\"#transition-group\" class=\"headerlink\" title=\"transition-group\"></a>transition-group</h3><ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>tag</code> - string，默认为 <code>span</code></li>\n<li><code>move-class</code> - 覆盖移动过渡期间应用的 CSS 类。</li>\n<li>除了 <code>mode</code>，其他 attribute 和 <code>&lt;transition&gt;</code> 相同。</li>\n</ul>\n</li>\n<li><p><strong>事件</strong>：</p>\n<ul>\n<li>事件和 <code>&lt;transition&gt;</code> 相同。</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p><code>&lt;transition-group&gt;</code> 元素作为多个元素/组件的过渡效果。<code>&lt;transition-group&gt;</code> 渲染一个真实的 DOM 元素。默认渲染 <code>&lt;span&gt;</code>，可以通过 <code>tag</code> attribute 配置哪个元素应该被渲染。</p>\n<p>注意，每个 <code>&lt;transition-group&gt;</code> 的子节点必须有<strong>独立的 key</strong>，动画才能正常工作</p>\n<p><code>&lt;transition-group&gt;</code> 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它会被应用一个移动中的 CSS 类 (通过 <code>name</code> attribute 或配置 <code>move-class</code> attribute 自动生成)。如果 CSS <code>transform</code> property 是“可过渡”property，当应用移动类时，将会使用 <a href=\"https://aerotwist.com/blog/flip-your-animations/\" target=\"_blank\" rel=\"noopener\">FLIP 技术</a>使元素流畅地到达动画终点。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition-group</span> <span class=\"hljs-attr\">tag</span>=<span class=\"hljs-string\">\"ul\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"slide\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>\n    &#123;&#123; item.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition-group</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/transitions.html\">过渡：进入，离开和列表</a></p>\n</li>\n</ul>\n<h3 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a>keep-alive</h3><ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>\n<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>\n<li><code>max</code> - 数字。最多可以缓存多少组件实例。</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p>\n<p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>\n<blockquote>\n<p>在 2.2.0 及其更高版本中，<code>activated</code> 和 <code>deactivated</code> 将会在 <code>&lt;keep-alive&gt;</code> 树内的所有嵌套组件中触发。</p>\n</blockquote>\n<p>主要用于保留组件状态或避免重新渲染。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 基本 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 多个条件判断的子组件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">comp-a</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"a &gt; 1\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">comp-a</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">comp-b</span> <span class=\"hljs-attr\">v-else</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">comp-b</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span></code></pre>\n<p>注意，<code>&lt;keep-alive&gt;</code> 是用在其一个直属的子组件被开关的情形。如果你在其中有 <code>v-for</code> 则不会工作。如果有上述的多个条件性的子元素，<code>&lt;keep-alive&gt;</code> 要求同时只有一个子元素被渲染。</p>\n</li>\n<li><p><strong><code>include</code> and <code>exclude</code></strong></p>\n<blockquote>\n<p>2.1.0 新增</p>\n</blockquote>\n<p><code>include</code> 和 <code>exclude</code> prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 逗号分隔字符串 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">include</span>=<span class=\"hljs-string\">\"a,b\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:include</span>=<span class=\"hljs-string\">\"/a|b/\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 数组 (使用 `v-bind`) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:include</span>=<span class=\"hljs-string\">\"['a', 'b']\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p>匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)。匿名组件不能被匹配。</p>\n</li>\n<li><p><strong><code>max</code></strong></p>\n<blockquote>\n<p>2.5.0 新增</p>\n</blockquote>\n<p>最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:max</span>=<span class=\"hljs-string\">\"10\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p class=\"tip\"><code>&lt;keep-alive&gt;</code> 不会在函数式组件中正常工作，因为它们没有缓存实例。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components-dynamic-async.html#在动态组件上使用-keep-alive\">动态组件 - keep-alive</a></p>\n</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>name</code> - string，用于命名插槽。</li>\n</ul>\n</li>\n<li><p><strong>Usage</strong>：</p>\n<p><code>&lt;slot&gt;</code> 元素作为组件模板之中的内容分发插槽。<code>&lt;slot&gt;</code> 元素自身将被替换。</p>\n<p>详细用法，请参考下面教程的链接。</p>\n</li>\n<li><p><strong>参考</strong>：<a href=\"../guide/components.html#通过插槽分发内容\">通过插槽分发内容</a></p>\n</li>\n</ul>\n<h2 id=\"VNode-接口\"><a href=\"#VNode-接口\" class=\"headerlink\" title=\"VNode 接口\"></a>VNode 接口</h2><ul>\n<li>请参考 <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js\" target=\"_blank\" rel=\"noopener\">VNode class declaration</a>。</li>\n</ul>\n<h2 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h2><ul>\n<li>请参考 <a href=\"https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer\" target=\"_blank\" rel=\"noopener\">vue-server-renderer package documentation</a>。</li>\n</ul>\n<!-- zhlint ignore: { `enter`: number, `leave`: number } -->\n<!-- zhlint ignore: ( , ) -->\n<!-- zhlint ignore: vm.$destroy() -->\n<!-- zhlint ignore: vm.$forceUpdate() -->\n"}],"Post":[{"layout":"post","title":"hello","date":"2019-02-18T10:01:31.000Z","_content":"\nhttps://vuejs.org/\n","source":"_posts/hello.md","raw":"---\nlayout: post\ntitle: hello\ndate: 2019-02-18 18:01:31\ntags:\n---\n\nhttps://vuejs.org/\n","slug":"hello","published":1,"updated":"2020-07-14T00:46:47.770Z","comments":1,"photos":[],"link":"","_id":"ckcwngnil00019lxkx7shdtak","content":"<p><a href=\"https://vuejs.org/\" target=\"_blank\" rel=\"noopener\">https://vuejs.org/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://vuejs.org/\" target=\"_blank\" rel=\"noopener\">https://vuejs.org/</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}